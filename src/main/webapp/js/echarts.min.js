! function(t, e) {
	"function" == typeof define && define.amd ? define([], e) : "object" == typeof module && module.exports ? module.exports = e() : t.echarts = e()
}(this, function() {
	var t, e;
	! function() {
		function i(t, e) {
			if (!e) return t;
			if (0 === t.indexOf(".")) {
				var i = e.split("/"),
					n = t.split("/"),
					r = i.length - 1,
					a = n.length,
					o = 0,
					s = 0;
				t: for (var l = 0; a > l; l++) switch (n[l]) {
					case "..":
						if (!(r > o)) break t;
						o++, s++;
						break;
					case ".":
						s++;
						break;
					default:
						break t
				}
				return i.length = r - o, n = n.slice(s), i.concat(n).join("/")
			}
			return t
		}

		function n(t) {
			function e(e, o) {
				if ("string" == typeof e) {
					var s = n[e];
					return s || (s = a(i(e, t)), n[e] = s), s
				}
				e instanceof Array && (o = o || function() {}, o.apply(this, r(e, o, t)))
			}
			var n = {};
			return e
		}

		function r(e, n, r) {
			for (var s = [], l = o[r], u = 0, c = Math.min(e.length, n.length); c > u; u++) {
				var h, d = i(e[u], r);
				switch (d) {
					case "require":
						h = l && l.require || t;
						break;
					case "exports":
						h = l.exports;
						break;
					case "module":
						h = l;
						break;
					default:
						h = a(d)
				}
				s.push(h)
			}
			return s
		}

		function a(t) {
			var e = o[t];
			if (!e) throw new Error("No " + t);
			if (!e.defined) {
				var i = e.factory,
					n = i.apply(this, r(e.deps || [], i, t));
				"undefined" != typeof n && (e.exports = n), e.defined = 1
			}
			return e.exports
		}
		var o = {};
		e = function(t, e, i) {
			o[t] = {
				id: t,
				deps: e,
				factory: i,
				defined: 0,
				exports: {},
				require: n(t)
			}
		}, t = n("")
	}();
	var i = "category",
		n = "../../util/number",
		r = "ordinal",
		a = "getAxis",
		o = "rotation",
		s = "../../echarts",
		l = "../core/util",
		u = "undefined",
		c = "parent",
		h = "getShallow",
		d = "normal",
		f = "emphasis",
		p = "applyTransform",
		m = "ecModel",
		v = "getItemVisual",
		g = "getName",
		y = "getComponent",
		x = "mergeOption",
		_ = "option",
		b = "getItemModel",
		w = "dimensions",
		M = "getContext",
		S = "contain",
		A = "getExtent",
		C = "opacity",
		L = "position",
		k = "center",
		z = "middle",
		P = "getBoundingRect",
		T = "getTextColor",
		D = "getFont",
		I = "textAlign",
		O = "textStyle",
		R = "coordinateSystem",
		E = "removeAll",
		B = "inherits",
		V = "number",
		Z = "function",
		N = "indexOf",
		G = "isArray",
		F = "replace",
		q = "seriesIndex",
		W = "mouseout",
		H = "mouseover",
		U = "getData",
		X = "splice",
		j = "series",
		Y = "eachSeries",
		Q = "trigger",
		$ = "length",
		K = "defaults",
		J = "dispatchAction",
		te = "extend",
		ee = "remove",
		ie = "isObject",
		ne = "update",
		re = "create",
		ae = "height",
		oe = "bottom",
		se = "ignore",
		le = "getHeight",
		ue = "getWidth",
		ce = "getModel",
		he = "string",
		de = "prototype",
		fe = "toLowerCase",
		pe = "filter",
		me = "zrender/core/util",
		ve = "require";
	e("echarts/chart/line", [ve, me, "../echarts", "./line/LineSeries", "./line/LineView", "../visual/symbol", "../layout/points", "../processor/dataSample", "../component/grid"], function(t) {
		var e = t(me),
			i = t("../echarts");
		t("./line/LineSeries"), t("./line/LineView"), i.registerVisualCoding("chart", e.curry(t("../visual/symbol"), "line", "circle", "line")), i.registerLayout(e.curry(t("../layout/points"), "line")), i.registerProcessor("statistic", e.curry(t("../processor/dataSample"), "line")), t("../component/grid")
	}), e("echarts/echarts", [ve, "./model/Global", "./ExtensionAPI", "./CoordinateSystem", "./model/OptionManager", "./model/Component", "./model/Series", "./view/Component", "./view/Chart", "./util/graphic", "zrender", me, "zrender/tool/color", "zrender/core/env", "zrender/mixin/Eventful", "./loading/default", "./visual/seriesColor", "./preprocessor/backwardCompat", "./util/number", "./util/format", "zrender/core/matrix", "zrender/core/vector"], function(t) {
		function e(t) {
			return function(e, i, n) {
				e = e && e[fe](), L[de][t].call(this, e, i, n)
			}
		}

		function i() {
			L.call(this)
		}

		function n(t, e, n) {
			n = n || {}, typeof e === he && (e = _e[e]), e && k(ye, function(t) {
				t(e)
			}), this.id, this.group, this._dom = t, this._zr = M.init(t, {
				renderer: n.renderer || "canvas",
				devicePixelRatio: n.devicePixelRatio
			}), this._theme = S.clone(e), this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._api = new m(this), this._coordSysMgr = new v, L.call(this), this._messageCenter = new i, this._initEvents(), this.resize = S.bind(this.resize, this)
		}

		function r(t, e) {
			var i = this._model;
			i && i.eachComponent({
				mainType: "series",
				query: e
			}, function(n) {
				var r = this._chartsMap[n.__viewId];
				r && r.__alive && r[t](n, i, this._api, e)
			}, this)
		}

		function a(t, e, i) {
			var n = this._api;
			k(this._componentsViews, function(r) {
				var a = r.__model;
				r[t](a, e, n, i), d(a, r)
			}, this), e[Y](function(r) {
				var a = this._chartsMap[r.__viewId];
				a[t](r, e, n, i), d(r, a)
			}, this)
		}

		function o(t, e) {
			for (var i = "component" === t, n = i ? this._componentsViews : this._chartsViews, r = i ? this._componentsMap : this._chartsMap, a = this._zr, o = 0; o < n[$]; o++) n[o].__alive = !1;
			e[i ? "eachComponent" : Y](function(t, o) {
				if (i) {
					if (t === j) return
				} else o = t;
				var s = o.id + "_" + o.type,
					l = r[s];
				if (!l) {
					var u = y.parseClassType(o.type),
						c = i ? _.getClass(u.main, u.sub) : b.getClass(u.sub);
					if (!c) return;
					l = new c, l.init(e, this._api), r[s] = l, n.push(l), a.add(l.group)
				}
				o.__viewId = s, l.__alive = !0, l.__id = s, l.__model = o
			}, this);
			for (var o = 0; o < n[$];) {
				var s = n[o];
				s.__alive ? o++ : (a[ee](s.group), s.dispose(e, this._api), n[X](o, 1), delete r[s.__id])
			}
		}

		function s(t, e) {
			k(P, function(i) {
				k(ge[i] || [], function(i) {
					i(t, e)
				})
			})
		}

		function l(t) {
			var e = {};
			t[Y](function(t) {
				var i = t.get("stack"),
					n = t[U]();
				if (i && "list" === n.type) {
					var r = e[i];
					r && (n.stackedOn = r), e[i] = n
				}
			})
		}

		function u(t, e) {
			var i = this._api;
			k(ve, function(n) {
				n(t, i, e)
			})
		}

		function c(t, e) {
			k(z, function(i) {
				k(xe[i] || [], function(i) {
					i(t, e)
				})
			})
		}

		function h(t, e) {
			var i = this._api;
			k(this._componentsViews, function(n) {
				var r = n.__model;
				n.render(r, t, i, e), d(r, n)
			}, this), k(this._chartsViews, function(t) {
				t.__alive = !1
			}, this), t[Y](function(n) {
				var r = this._chartsMap[n.__viewId];
				r.__alive = !0, r.render(n, t, i, e), d(n, r)
			}, this), k(this._chartsViews, function(e) {
				e.__alive || e[ee](t, i)
			}, this)
		}

		function d(t, e) {
			var i = t.get("z"),
				n = t.get("zlevel");
			e.group.traverse(function(t) {
				null != i && (t.z = i), null != n && (t.zlevel = n)
			})
		}

		function f(t) {
			function e(t, e) {
				for (var i = 0; i < t[$]; i++) {
					var n = t[i];
					n[a] = e
				}
			}
			var i = 0,
				n = 1,
				r = 2,
				a = "__connectUpdateStatus";
			S.each(E, function(o, s) {
				t._messageCenter.on(s, function(o) {
					if (we[t.group] && t[a] !== i) {
						var s = t.makeActionFromEvent(o),
							l = [];
						for (var u in be) {
							var c = be[u];
							c !== t && c.group === t.group && l.push(c)
						}
						e(l, i), k(l, function(t) {
							t[a] !== n && t[J](s)
						}), e(l, r)
					}
				})
			})
		}
		var p = t("./model/Global"),
			m = t("./ExtensionAPI"),
			v = t("./CoordinateSystem"),
			g = t("./model/OptionManager"),
			y = t("./model/Component"),
			x = t("./model/Series"),
			_ = t("./view/Component"),
			b = t("./view/Chart"),
			w = t("./util/graphic"),
			M = t("zrender"),
			S = t(me),
			A = t("zrender/tool/color"),
			C = t("zrender/core/env"),
			L = t("zrender/mixin/Eventful"),
			k = S.each,
			z = ["echarts", "chart", "component"],
			P = ["transform", pe, "statistic"];
		i[de].on = e("on"), i[de].off = e("off"), i[de].one = e("one"), S.mixin(i, L);
		var T = n[de];
		T.getDom = function() {
			return this._dom
		}, T.getZr = function() {
			return this._zr
		}, T.setOption = function(t, e, i) {
			(!this._model || e) && (this._model = new p(null, null, this._theme, new g(this._api))), this._model.setOption(t, ye), D.prepareAndUpdate.call(this), !i && this._zr.refreshImmediately()
		}, T.setTheme = function() {
			console.log("ECharts#setTheme() is DEPRECATED in ECharts 3.0")
		}, T[ce] = function() {
			return this._model
		}, T.getOption = function() {
			return this._model.getOption()
		}, T[ue] = function() {
			return this._zr[ue]()
		}, T[le] = function() {
			return this._zr[le]()
		}, T.getRenderedCanvas = function(t) {
			if (C.canvasSupported) {
				t = t || {}, t.pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor");
				var e = this._zr,
					i = e.storage.getDisplayList();
				return S.each(i, function(t) {
					t.stopAnimation(!0)
				}), e.painter.getRenderedCanvas(t)
			}
		}, T.getDataURL = function(t) {
			t = t || {};
			var e = t.excludeComponents,
				i = this._model,
				n = [],
				r = this;
			k(e, function(t) {
				i.eachComponent({
					mainType: t
				}, function(t) {
					var e = r._componentsMap[t.__viewId];
					e.group[se] || (n.push(e), e.group[se] = !0)
				})
			});
			var a = this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png"));
			return k(n, function(t) {
				t.group[se] = !1
			}), a
		}, T.getConnectedDataURL = function(t) {
			if (C.canvasSupported) {
				var e = this.group,
					i = Math.min,
					n = Math.max,
					r = 1 / 0;
				if (we[e]) {
					var a = r,
						o = r,
						s = -r,
						l = -r,
						u = [],
						c = t && t.pixelRatio || 1;
					for (var h in be) {
						var d = be[h];
						if (d.group === e) {
							var f = d.getRenderedCanvas(S.clone(t)),
								p = d.getDom().getBoundingClientRect();
							a = i(p.left, a), o = i(p.top, o), s = n(p.right, s), l = n(p[oe], l), u.push({
								dom: f,
								left: p.left,
								top: p.top
							})
						}
					}
					a *= c, o *= c, s *= c, l *= c;
					var m = s - a,
						v = l - o,
						g = S.createCanvas();
					g.width = m, g[ae] = v;
					var y = M.init(g);
					return k(u, function(t) {
						var e = new w.Image({
							style: {
								x: t.left * c - a,
								y: t.top * c - o,
								image: t.dom
							}
						});
						y.add(e)
					}), y.refreshImmediately(), g.toDataURL("image/" + (t && t.type || "png"))
				}
				return this.getDataURL(t)
			}
		};
		var D = {
			update: function(t) {
				var e = this._model,
					i = this._api,
					n = this._coordSysMgr;
				if (e) {
					e.restoreData(), n[re](this._model, this._api), s.call(this, e, i), l.call(this, e), n[ne](e, i), u.call(this, e, t), c.call(this, e, t), h.call(this, e, t);
					var r = e.get("backgroundColor") || "transparent",
						a = this._zr.painter;
					if (a.isSingleCanvas && a.isSingleCanvas()) this._zr.configLayer(0, {
						clearColor: r
					});
					else {
						if (!C.canvasSupported) {
							var o = A.parse(r);
							r = A.stringify(o, "rgb"), 0 === o[3] && (r = "transparent")
						}
						r = r, this._dom.style.backgroundColor = r
					}
				}
			},
			updateView: function(t) {
				var e = this._model;
				e && (u.call(this, e, t), c.call(this, e, t), a.call(this, "updateView", e, t))
			},
			updateVisual: function(t) {
				var e = this._model;
				e && (c.call(this, e, t), a.call(this, "updateVisual", e, t))
			},
			updateLayout: function(t) {
				var e = this._model;
				e && (u.call(this, e, t), a.call(this, "updateLayout", e, t))
			},
			highlight: function(t) {
				r.call(this, "highlight", t)
			},
			downplay: function(t) {
				r.call(this, "downplay", t)
			},
			prepareAndUpdate: function(t) {
				var e = this._model;
				o.call(this, "component", e), o.call(this, "chart", e), D[ne].call(this, t)
			}
		};
		T.resize = function() {
			this._zr.resize();
			var t = this._model && this._model.resetOption("media");
			D[t ? "prepareAndUpdate" : ne].call(this), this._loadingFX && this._loadingFX.resize()
		};
		var I = t("./loading/default");
		T.showLoading = function(t, e) {
			S[ie](t) && (e = t, t = "default"), this.hideLoading();
			var i = I(this._api, e),
				n = this._zr;
			this._loadingFX = i, n.add(i)
		}, T.hideLoading = function() {
			this._loadingFX && this._zr[ee](this._loadingFX), this._loadingFX = null
		}, T.makeActionFromEvent = function(t) {
			var e = S[te]({}, t);
			return e.type = E[t.type], e
		}, T[J] = function(t, e) {
			var i = R[t.type];
			if (i) {
				var n = i.actionInfo,
					r = n[ne] || ne,
					a = [t],
					o = !1;
				t.batch && (o = !0, a = S.map(t.batch, function(e) {
					return e = S[K](S[te]({}, e), t), e.batch = null, e
				}));
				for (var s, l = [], u = "highlight" === t.type || "downplay" === t.type, c = 0; c < a[$]; c++) {
					var h = a[c];
					s = i.action(h, this._model), s = s || S[te]({}, h), s.type = n.event || s.type, l.push(s), u && D[r].call(this, h)
				}
				"none" !== r && !u && D[r].call(this, t), e || (s = o ? {
					type: n.event || t.type,
					batch: l
				} : l[0], this._messageCenter[Q](s.type, s))
			}
		}, T.on = e("on"), T.off = e("off"), T.one = e("one");
		var O = ["click", "dblclick", H, W, "mousedown", "mouseup", "globalout"];
		T._initEvents = function() {
			var t = this._zr;
			k(O, function(e) {
				t.on(e, function(t) {
					var i = this[ce](),
						n = t.target;
					if (n && null != n.dataIndex) {
						var r = n.dataModel || i.getSeriesByIndex(n[q]),
							a = r && r.getDataParams(n.dataIndex) || {};
						a.event = t, a.type = e, this[Q](e, a)
					}
				}, this)
			}, this), k(E, function(t, e) {
				this._messageCenter.on(e, function(t) {
					this[Q](e, t)
				}, this)
			}, this)
		}, T.isDisposed = function() {
			return this._disposed
		}, T.clear = function() {
			this.setOption({}, !0)
		}, T.dispose = function() {
			this._disposed = !0;
			var t = this._api,
				e = this._model;
			k(this._componentsViews, function(i) {
				i.dispose(e, t)
			}), k(this._chartsViews, function(i) {
				i.dispose(e, t)
			}), this._zr.dispose(), delete be[this.id]
		}, S.mixin(n, L);
		var R = [],
			E = {},
			ve = [],
			ge = {},
			ye = [],
			xe = {},
			_e = {},
			be = {},
			we = {},
			Me = new Date - 0,
			Se = new Date - 0,
			Ae = "_echarts_instance_",
			Ce = {
				version: "3.1.6",
				dependencies: {
					zrender: "3.0.7"
				}
			};
		return Ce.init = function(t, e, i) {
			if (M.version[F](".", "") - 0 < Ce.dependencies.zrender[F](".", "") - 0) throw new Error("ZRender " + M.version + " is too old for ECharts " + Ce.version + ". Current version need ZRender " + Ce.dependencies.zrender + "+");
			if (!t) throw new Error("Initialize failed: invalid dom.");
			var r = new n(t, e, i);
			return r.id = "ec_" + Me++, be[r.id] = r, t.setAttribute && t.setAttribute(Ae, r.id), f(r), r
		}, Ce.connect = function(t) {
			if (S[G](t)) {
				var e = t;
				t = null, S.each(e, function(e) {
					null != e.group && (t = e.group)
				}), t = t || "g_" + Se++, S.each(e, function(e) {
					e.group = t
				})
			}
			return we[t] = !0, t
		}, Ce.disConnect = function(t) {
			we[t] = !1
		}, Ce.dispose = function(t) {
			S.isDom(t) ? t = Ce.getInstanceByDom(t) : typeof t === he && (t = be[t]), t instanceof n && !t.isDisposed() && t.dispose()
		}, Ce.getInstanceByDom = function(t) {
			var e = t.getAttribute(Ae);
			return be[e]
		}, Ce.getInstanceById = function(t) {
			return be[t]
		}, Ce.registerTheme = function(t, e) {
			_e[t] = e
		}, Ce.registerPreprocessor = function(t) {
			ye.push(t)
		}, Ce.registerProcessor = function(t, e) {
			if (S[N](P, t) < 0) throw new Error("stage should be one of " + P);
			var i = ge[t] || (ge[t] = []);
			i.push(e)
		}, Ce.registerAction = function(t, e, i) {
			typeof e === Z && (i = e, e = "");
			var n = S[ie](t) ? t.type : [t, t = {
				event: e
			}][0];
			t.event = (t.event || n)[fe](), e = t.event, R[n] || (R[n] = {
				action: i,
				actionInfo: t
			}), E[e] = n
		}, Ce.registerCoordinateSystem = function(t, e) {
			v.register(t, e)
		}, Ce.registerLayout = function(t) {
			S[N](ve, t) < 0 && ve.push(t)
		}, Ce.registerVisualCoding = function(t, e) {
			if (S[N](z, t) < 0) throw new Error("stage should be one of " + z);
			var i = xe[t] || (xe[t] = []);
			i.push(e)
		}, Ce.extendChartView = function(t) {
			return b[te](t)
		}, Ce.extendComponentModel = function(t) {
			return y[te](t)
		}, Ce.extendSeriesModel = function(t) {
			return x[te](t)
		}, Ce.extendComponentView = function(t) {
			return _[te](t)
		}, Ce.setCanvasCreator = function(t) {
			S.createCanvas = t
		}, Ce.registerVisualCoding("echarts", S.curry(t("./visual/seriesColor"), "", "itemStyle")), Ce.registerPreprocessor(t("./preprocessor/backwardCompat")), Ce.registerAction({
			type: "highlight",
			event: "highlight",
			update: "highlight"
		}, S.noop), Ce.registerAction({
			type: "downplay",
			event: "downplay",
			update: "downplay"
		}, S.noop), Ce.graphic = t("./util/graphic"), Ce[V] = t("./util/number"), Ce.format = t("./util/format"), Ce.matrix = t("zrender/core/matrix"), Ce.vector = t("zrender/core/vector"), Ce.util = {}, k(["map", "each", pe, N, B, "reduce", pe, "bind", "curry", G, "isString", ie, "isFunction", te], function(t) {
			Ce.util[t] = S[t]
		}), Ce
	}), e("echarts/chart/pie", [ve, me, "../echarts", "./pie/PieSeries", "./pie/PieView", "../action/createDataSelectAction", "../visual/dataColor", "./pie/pieLayout", "../processor/dataFilter"], function(t) {
		var e = t(me),
			i = t("../echarts");
		t("./pie/PieSeries"), t("./pie/PieView"), t("../action/createDataSelectAction")("pie", [{
			type: "pieToggleSelect",
			event: "pieselectchanged",
			method: "toggleSelected"
		}, {
			type: "pieSelect",
			event: "pieselected",
			method: "select"
		}, {
			type: "pieUnSelect",
			event: "pieunselected",
			method: "unSelect"
		}]), i.registerVisualCoding("chart", e.curry(t("../visual/dataColor"), "pie")), i.registerLayout(e.curry(t("./pie/pieLayout"), "pie")), i.registerProcessor(pe, e.curry(t("../processor/dataFilter"), "pie"))
	}), e("echarts/component/legend", [ve, "./legend/LegendModel", "./legend/legendAction", "./legend/LegendView", "../echarts", "./legend/legendFilter"], function(t) {
		t("./legend/LegendModel"), t("./legend/legendAction"), t("./legend/LegendView");
		var e = t("../echarts");
		e.registerProcessor(pe, t("./legend/legendFilter"))
	}), e("echarts/component/grid", [ve, "../util/graphic", me, "../coord/cartesian/Grid", "./axis", "../echarts"], function(t) {
		var e = t("../util/graphic"),
			i = t(me);
		t("../coord/cartesian/Grid"), t("./axis"), t("../echarts").extendComponentView({
			type: "grid",
			render: function(t) {
				this.group[E](), t.get("show") && this.group.add(new e.Rect({
					shape: t[R].getRect(),
					style: i[K]({
						fill: t.get("backgroundColor")
					}, t.getItemStyle()),
					silent: !0
				}))
			}
		})
	}), e("echarts/component/markPoint", [ve, "./marker/MarkPointModel", "./marker/MarkPointView", "../echarts"], function(t) {
		t("./marker/MarkPointModel"), t("./marker/MarkPointView"), t("../echarts").registerPreprocessor(function(t) {
			t.markPoint = t.markPoint || {}
		})
	}), e("echarts/component/title", [ve, "../echarts", "../util/graphic", "../util/layout"], function(t) {
		var e = t("../echarts"),
			i = t("../util/graphic"),
			n = t("../util/layout");
		e.extendComponentModel({
			type: "title",
			layoutMode: {
				type: "box",
				ignoreSize: !0
			},
			defaultOption: {
				zlevel: 0,
				z: 6,
				show: !0,
				text: "",
				target: "blank",
				subtext: "",
				subtarget: "blank",
				left: 0,
				top: 0,
				backgroundColor: "rgba(0,0,0,0)",
				borderColor: "#ccc",
				borderWidth: 0,
				padding: 5,
				itemGap: 10,
				textStyle: {
					fontSize: 18,
					fontWeight: "bolder",
					color: "#333"
				},
				subtextStyle: {
					color: "#aaa"
				}
			}
		}), e.extendComponentView({
			type: "title",
			render: function(t, e, r) {
				if (this.group[E](), t.get("show")) {
					var a = this.group,
						o = t[ce](O),
						s = t[ce]("subtextStyle"),
						l = t.get(I),
						u = new i.Text({
							style: {
								text: t.get("text"),
								textFont: o[D](),
								fill: o[T](),
								textBaseline: "top"
							},
							z2: 10
						}),
						c = u[P](),
						h = t.get("subtext"),
						d = new i.Text({
							style: {
								text: h,
								textFont: s[D](),
								fill: s[T](),
								y: c[ae] + t.get("itemGap"),
								textBaseline: "top"
							},
							z2: 10
						}),
						f = t.get("link"),
						p = t.get("sublink");
					u.silent = !f, d.silent = !p, f && u.on("click", function() {
						window.open(f, t.get("target"))
					}), p && d.on("click", function() {
						window.open(p, t.get("subtarget"))
					}), a.add(u), h && a.add(d);
					var m = a[P](),
						v = t.getBoxLayoutParams();
					v.width = m.width, v[ae] = m[ae];
					var g = n.getLayoutRect(v, {
						width: r[ue](),
						height: r[le]()
					}, t.get("padding"));
					l || (l = t.get("left") || t.get("right"), l === z && (l = k), "right" === l ? g.x += g.width : l === k && (g.x += g.width / 2)), a[L] = [g.x, g.y], u.setStyle(I, l), d.setStyle(I, l), m = a[P]();
					var y = g.margin,
						x = t.getItemStyle(["color", C]);
					x.fill = t.get("backgroundColor");
					var _ = new i.Rect({
						shape: {
							x: m.x - y[3],
							y: m.y - y[0],
							width: m.width + y[1] + y[3],
							height: m[ae] + y[0] + y[2]
						},
						style: x,
						silent: !0
					});
					i.subPixelOptimizeRect(_), a.add(_)
				}
			}
		})
	}), e("echarts/component/markLine", [ve, "./marker/MarkLineModel", "./marker/MarkLineView", "../echarts"], function(t) {
		t("./marker/MarkLineModel"), t("./marker/MarkLineView"), t("../echarts").registerPreprocessor(function(t) {
			t.markLine = t.markLine || {}
		})
	}), e("echarts/component/dataZoom", [ve, "./dataZoom/typeDefaulter", "./dataZoom/DataZoomModel", "./dataZoom/DataZoomView", "./dataZoom/SliderZoomModel", "./dataZoom/SliderZoomView", "./dataZoom/InsideZoomModel", "./dataZoom/InsideZoomView", "./dataZoom/dataZoomProcessor", "./dataZoom/dataZoomAction"], function(t) {
		t("./dataZoom/typeDefaulter"), t("./dataZoom/DataZoomModel"), t("./dataZoom/DataZoomView"), t("./dataZoom/SliderZoomModel"), t("./dataZoom/SliderZoomView"), t("./dataZoom/InsideZoomModel"), t("./dataZoom/InsideZoomView"), t("./dataZoom/dataZoomProcessor"), t("./dataZoom/dataZoomAction")
	}), e("echarts/scale/Log", [ve, me, "./Scale", "../util/number", "./Interval"], function(t) {
		var e = t(me),
			i = t("./Scale"),
			n = t("../util/number"),
			r = t("./Interval"),
			a = i[de],
			o = r[de],
			s = Math.floor,
			l = Math.ceil,
			u = Math.pow,
			c = 10,
			h = Math.log,
			d = i[te]({
				type: "log",
				getTicks: function() {
					return e.map(o.getTicks.call(this), function(t) {
						return n.round(u(c, t))
					})
				},
				getLabel: o.getLabel,
				scale: function(t) {
					return t = a.scale.call(this, t), u(c, t)
				},
				setExtent: function(t, e) {
					t = h(t) / h(c), e = h(e) / h(c), o.setExtent.call(this, t, e)
				},
				getExtent: function() {
					var t = a[A].call(this);
					return t[0] = u(c, t[0]), t[1] = u(c, t[1]), t
				},
				unionExtent: function(t) {
					t[0] = h(t[0]) / h(c), t[1] = h(t[1]) / h(c), a.unionExtent.call(this, t)
				},
				niceTicks: function(t) {
					t = t || 10;
					var e = this._extent,
						i = e[1] - e[0];
					if (!(1 / 0 === i || 0 >= i)) {
						var r = u(10, s(h(i / t) / Math.LN10)),
							a = t / i * r;
						.5 >= a && (r *= 10);
						var o = [n.round(l(e[0] / r) * r), n.round(s(e[1] / r) * r)];
						this._interval = r, this._niceExtent = o
					}
				},
				niceExtent: o.niceExtent
			});
		return e.each([S, "normalize"], function(t) {
			d[de][t] = function(e) {
				return e = h(e) / h(c), a[t].call(this, e)
			}
		}), d[re] = function() {
			return new d
		}, d
	}), e("echarts/scale/Time", [ve, me, "../util/number", "../util/format", "./Interval"], function(t) {
		var e = t(me),
			i = t("../util/number"),
			n = t("../util/format"),
			r = t("./Interval"),
			a = r[de],
			o = Math.ceil,
			s = Math.floor,
			l = 864e5,
			u = function(t, e, i, n) {
				for (; n > i;) {
					var r = i + n >>> 1;
					t[r][2] < e ? i = r + 1 : n = r
				}
				return i
			},
			c = r[te]({
				type: "time",
				getLabel: function(t) {
					var e = this._stepLvl,
						i = new Date(t);
					return n.formatTime(e[0], i)
				},
				niceExtent: function(t, e, n) {
					var r = this._extent;
					if (r[0] === r[1] && (r[0] -= l, r[1] += l), r[1] === -1 / 0 && 1 / 0 === r[0]) {
						var a = new Date;
						r[1] = new Date(a.getFullYear(), a.getMonth(), a.getDate()), r[0] = r[1] - l
					}
					this.niceTicks(t, e, n);
					var u = this._interval;
					e || (r[0] = i.round(s(r[0] / u) * u)), n || (r[1] = i.round(o(r[1] / u) * u))
				},
				niceTicks: function(t) {
					t = t || 10;
					var e = this._extent,
						n = e[1] - e[0],
						r = n / t,
						a = h[$],
						l = u(h, r, 0, a),
						c = h[Math.min(l, a - 1)],
						d = c[2];
					if ("year" === c[0]) {
						var f = n / d,
							p = i.nice(f / t, !0);
						d *= p
					}
					var m = [o(e[0] / d) * d, s(e[1] / d) * d];
					this._stepLvl = c, this._interval = d, this._niceExtent = m
				},
				parse: function(t) {
					return +i.parseDate(t)
				}
			});
		e.each([S, "normalize"], function(t) {
			c[de][t] = function(e) {
				return a[t].call(this, this.parse(e))
			}
		});
		var h = [
			["hh:mm:ss", 1, 1e3],
			["hh:mm:ss", 5, 5e3],
			["hh:mm:ss", 10, 1e4],
			["hh:mm:ss", 15, 15e3],
			["hh:mm:ss", 30, 3e4],
			["hh:mm\nMM-dd", 1, 6e4],
			["hh:mm\nMM-dd", 5, 3e5],
			["hh:mm\nMM-dd", 10, 6e5],
			["hh:mm\nMM-dd", 15, 9e5],
			["hh:mm\nMM-dd", 30, 18e5],
			["hh:mm\nMM-dd", 1, 36e5],
			["hh:mm\nMM-dd", 2, 72e5],
			["hh:mm\nMM-dd", 6, 216e5],
			["hh:mm\nMM-dd", 12, 432e5],
			["MM-dd\nyyyy", 1, l],
			["week", 7, 7 * l],
			["month", 1, 31 * l],
			["quarter", 3, 380 * l / 4],
			["half-year", 6, 380 * l / 2],
			["year", 1, 380 * l]
		];
		return c[re] = function() {
			return new c
		}, c
	}), e(me, [ve, "../graphic/Gradient"], function(t) {
		function e(t) {
			if ("object" == typeof t && null !== t) {
				var i = t;
				if (t instanceof Array) {
					i = [];
					for (var n = 0, r = t[$]; r > n; n++) i[n] = e(t[n])
				} else if (!S(t) && !A(t)) {
					i = {};
					for (var a in t) t.hasOwnProperty(a) && (i[a] = e(t[a]))
				}
				return i
			}
			return t
		}

		function i(t, n, r) {
			if (!w(n) || !w(t)) return r ? e(n) : t;
			for (var a in n)
				if (n.hasOwnProperty(a)) {
					var o = t[a],
						s = n[a];
					!w(s) || !w(o) || x(s) || x(o) || A(s) || A(o) || S(s) || S(o) ? !r && a in t || (t[a] = e(n[a], !0)) : i(o, s, r)
				}
			return t
		}

		function n(t, e) {
			for (var n = t[0], r = 1, a = t[$]; a > r; r++) n = i(n, t[r], e);
			return n
		}

		function r(t, e) {
			for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
			return t
		}

		function a(t, e, i) {
			for (var n in e) e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]);
			return t
		}

		function o() {
			return document.createElement("canvas")
		}

		function s() {
			return z || (z = F.createCanvas()[M]("2d")), z
		}

		function l(t, e) {
			if (t) {
				if (t[N]) return t[N](e);
				for (var i = 0, n = t[$]; n > i; i++)
					if (t[i] === e) return i
			}
			return -1
		}

		function u(t, e) {
			function i() {}
			var n = t[de];
			i[de] = e[de], t[de] = new i;
			for (var r in n) t[de][r] = n[r];
			t[de].constructor = t, t.superClass = e
		}

		function c(t, e, i) {
			t = de in t ? t[de] : t, e = de in e ? e[de] : e, a(t, e, i)
		}

		function h(t) {
			return t ? typeof t == he ? !1 : typeof t[$] == V : void 0
		}

		function d(t, e, i) {
			if (t && e)
				if (t.forEach && t.forEach === O) t.forEach(e, i);
				else if (t[$] === +t[$])
				for (var n = 0, r = t[$]; r > n; n++) e.call(i, t[n], n, t);
			else
				for (var a in t) t.hasOwnProperty(a) && e.call(i, t[a], a, t)
		}

		function f(t, e, i) {
			if (t && e) {
				if (t.map && t.map === B) return t.map(e, i);
				for (var n = [], r = 0, a = t[$]; a > r; r++) n.push(e.call(i, t[r], r, t));
				return n
			}
		}

		function p(t, e, i, n) {
			if (t && e) {
				if (t.reduce && t.reduce === G) return t.reduce(e, i, n);
				for (var r = 0, a = t[$]; a > r; r++) i = e.call(n, i, t[r], r, t);
				return i
			}
		}

		function m(t, e, i) {
			if (t && e) {
				if (t[pe] && t[pe] === R) return t[pe](e, i);
				for (var n = [], r = 0, a = t[$]; a > r; r++) e.call(i, t[r], r, t) && n.push(t[r]);
				return n
			}
		}

		function v(t, e, i) {
			if (t && e)
				for (var n = 0, r = t[$]; r > n; n++)
					if (e.call(i, t[n], n, t)) return t[n]
		}

		function g(t, e) {
			var i = E.call(arguments, 2);
			return function() {
				return t.apply(e, i.concat(E.call(arguments)))
			}
		}

		function y(t) {
			var e = E.call(arguments, 1);
			return function() {
				return t.apply(this, e.concat(E.call(arguments)))
			}
		}

		function x(t) {
			return "[object Array]" === D.call(t)
		}

		function _(t) {
			return typeof t === Z
		}

		function b(t) {
			return "[object String]" === D.call(t)
		}

		function w(t) {
			var e = typeof t;
			return e === Z || !!t && "object" == e
		}

		function S(t) {
			return !!T[D.call(t)] || t instanceof P
		}

		function A(t) {
			return t && 1 === t.nodeType && typeof t.nodeName == he
		}

		function C() {
			for (var t = 0, e = arguments[$]; e > t; t++)
				if (null != arguments[t]) return arguments[t]
		}

		function L() {
			return Function.call.apply(E, arguments)
		}

		function k(t, e) {
			if (!t) throw new Error(e)
		}
		var z, P = t("../graphic/Gradient"),
			T = {
				"[object Function]": 1,
				"[object RegExp]": 1,
				"[object Date]": 1,
				"[object Error]": 1,
				"[object CanvasGradient]": 1
			},
			D = Object[de].toString,
			I = Array[de],
			O = I.forEach,
			R = I[pe],
			E = I.slice,
			B = I.map,
			G = I.reduce,
			F = {
				inherits: u,
				mixin: c,
				clone: e,
				merge: i,
				mergeAll: n,
				extend: r,
				defaults: a,
				getContext: s,
				createCanvas: o,
				indexOf: l,
				slice: L,
				find: v,
				isArrayLike: h,
				each: d,
				map: f,
				reduce: p,
				filter: m,
				bind: g,
				curry: y,
				isArray: x,
				isString: b,
				isObject: w,
				isFunction: _,
				isBuildInObject: S,
				isDom: A,
				retrieve: C,
				assert: k,
				noop: function() {}
			};
		return F
	}), e("echarts/chart/line/LineSeries", [ve, "../helper/createListFromArray", "../../model/Series"], function(t) {
		var e = t("../helper/createListFromArray"),
			i = t("../../model/Series");
		return i[te]({
			type: "series.line",
			dependencies: ["grid", "polar"],
			getInitialData: function(t, i) {
				return e(t.data, this, i)
			},
			defaultOption: {
				zlevel: 0,
				z: 2,
				coordinateSystem: "cartesian2d",
				legendHoverLink: !0,
				hoverAnimation: !0,
				xAxisIndex: 0,
				yAxisIndex: 0,
				polarIndex: 0,
				clipOverflow: !0,
				label: {
					normal: {
						position: "top"
					}
				},
				lineStyle: {
					normal: {
						width: 2,
						type: "solid"
					}
				},
				symbol: "emptyCircle",
				symbolSize: 4,
				showSymbol: !0,
				animationEasing: "linear"
			}
		})
	}), e("echarts/layout/points", [ve], function() {
		return function(t, e) {
			e.eachSeriesByType(t, function(t) {
				var e = t[U](),
					i = t[R],
					n = i[w];
				e.each(n, function(t, n, r) {
					var a;
					a = isNaN(t) || isNaN(n) ? [0 / 0, 0 / 0] : i.dataToPoint([t, n]), e.setItemLayout(r, a)
				}, !0)
			})
		}
	}), e("echarts/visual/symbol", [ve], function() {
		return function(t, e, i, n) {
			n.eachRawSeriesByType(t, function(t) {
				var r = t[U](),
					a = t.get("symbol") || e,
					o = t.get("symbolSize");
				r.setVisual({
					legendSymbol: i || a,
					symbol: a,
					symbolSize: o
				}), n.isSeriesFiltered(t) || (typeof o === Z && r.each(function(e) {
					var i = t.getRawValue(e),
						n = t.getDataParams(e);
					r.setItemVisual(e, "symbolSize", o(i, n))
				}), r.each(function(t) {
					var e = r[b](t),
						i = e.get("symbol", !0),
						n = e.get("symbolSize", !0);
					null != i && r.setItemVisual(t, "symbol", i), null != n && r.setItemVisual(t, "symbolSize", n)
				}))
			})
		}
	}), e("echarts/ExtensionAPI", [ve, me], function(t) {
		function e(t) {
			i.each(n, function(e) {
				this[e] = i.bind(t[e], t)
			}, this)
		}
		var i = t(me),
			n = ["getDom", "getZr", ue, le, J, "on", "off", "getDataURL", "getConnectedDataURL", ce, "getOption"];
		return e
	}), e("echarts/processor/dataSample", [], function() {
		var t = {
				average: function(t) {
					for (var e = 0, i = 0, n = 0; n < t[$]; n++) isNaN(t[n]) || (e += t[n], i++);
					return 0 === i ? 0 / 0 : e / i
				},
				sum: function(t) {
					for (var e = 0, i = 0; i < t[$]; i++) e += t[i] || 0;
					return e
				},
				max: function(t) {
					for (var e = -1 / 0, i = 0; i < t[$]; i++) t[i] > e && (e = t[i]);
					return e
				},
				min: function(t) {
					for (var e = 1 / 0, i = 0; i < t[$]; i++) t[i] < e && (e = t[i]);
					return e
				}
			},
			e = function(t) {
				return Math.round(t[$] / 2)
			};
		return function(i, n) {
			n.eachSeriesByType(i, function(i) {
				var n = i[U](),
					r = i.get("sampling"),
					a = i[R];
				if ("cartesian2d" === a.type && r) {
					var o = a.getBaseAxis(),
						s = a.getOtherAxis(o),
						l = o[A](),
						u = l[1] - l[0],
						c = Math.round(n.count() / u);
					if (c > 1) {
						var h;
						typeof r === he ? h = t[r] : typeof r === Z && (h = r), h && (n = n.downSample(s.dim, 1 / c, h, e), i.setData(n))
					}
				}
			}, this)
		}
	}), e("echarts/model/Global", [ve, me, "../util/model", "./Model", "./Component", "./globalDefault"], function(t) {
		function e(t, e) {
			for (var i in e) y.hasClass(i) || ("object" == typeof e[i] ? t[i] = t[i] ? u.merge(t[i], e[i], !1) : u.clone(e[i]) : null == t[i] && (t[i] = e[i]))
		}

		function i(t) {
			t = t, this[_] = {}, this[_][w] = 1, this._componentsMap = {}, this._seriesIndices = null, e(t, this._theme[_]), u.merge(t, b, !1), this[x](t)
		}

		function n(t, e) {
			u[G](e) || (e = e ? [e] : []);
			var i = {};
			return d(e, function(e) {
				i[e] = (t[e] || []).slice()
			}), i
		}

		function r(t, e) {
			var i = {};
			d(e, function(t) {
				var e = t.exist;
				e && (i[e.id] = t)
			}), d(e, function(e) {
				var n = e[_];
				if (u.assert(!n || null == n.id || !i[n.id] || i[n.id] === e, "id duplicates: " + (n && n.id)), n && null != n.id && (i[n.id] = e), g(n)) {
					var r = a(t, n, e.exist);
					e.keyInfo = {
						mainType: t,
						subType: r
					}
				}
			}), d(e, function(t) {
				var e = t.exist,
					n = t[_],
					r = t.keyInfo;
				if (g(n)) {
					if (r.name = null != n.name ? n.name + "" : e ? e.name : "\x00-", e) r.id = e.id;
					else if (null != n.id) r.id = n.id + "";
					else {
						var a = 0;
						do r.id = "\x00" + r.name + "\x00" + a++; while (i[r.id])
					}
					i[r.id] = t
				}
			})
		}

		function a(t, e, i) {
			var n = e.type ? e.type : i ? i.subType : y.determineSubType(t, e);
			return n
		}

		function o(t) {
			return p(t, function(t) {
				return t.componentIndex
			}) || []
		}

		function s(t, e) {
			return e.hasOwnProperty("subType") ? f(t, function(t) {
				return t.subType === e.subType
			}) : t
		}

		function l(t) {
			if (!t._seriesIndices) throw new Error("Series has not been initialized yet.")
		}
		var u = t(me),
			c = t("../util/model"),
			h = t("./Model"),
			d = u.each,
			f = u[pe],
			p = u.map,
			m = u[G],
			v = u[N],
			g = u[ie],
			y = t("./Component"),
			b = t("./globalDefault"),
			w = "\x00_ec_inner",
			M = h[te]({
				constructor: M,
				init: function(t, e, i, n) {
					i = i || {}, this[_] = null, this._theme = new h(i), this._optionManager = n
				},
				setOption: function(t, e) {
					u.assert(!(w in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), this.resetOption()
				},
				resetOption: function(t) {
					var e = !1,
						n = this._optionManager;
					if (!t || "recreate" === t) {
						var r = n.mountOption("recreate" === t);
						this[_] && "recreate" !== t ? (this.restoreData(), this[x](r)) : i.call(this, r), e = !0
					}
					if (("timeline" === t || "media" === t) && this.restoreData(), !t || "recreate" === t || "timeline" === t) {
						var a = n.getTimelineOption(this);
						a && (this[x](a), e = !0)
					}
					if (!t || "recreate" === t || "media" === t) {
						var o = n.getMediaOption(this, this._api);
						o[$] && d(o, function(t) {
							this[x](t, e = !0)
						}, this)
					}
					return e
				},
				mergeOption: function(t) {
					function e(e, s) {
						var l = c.normalizeToArray(t[e]),
							h = c.mappingToExists(a[e], l);
						r(e, h);
						var f = n(a, s);
						i[e] = [], a[e] = [], d(h, function(t, n) {
							var r = t.exist,
								o = t[_];
							if (u.assert(g(o) || r, "Empty component definition"), o) {
								var s = y.getClass(e, t.keyInfo.subType, !0);
								r && r instanceof s ? (r[x](o, this), r.optionUpdated(this)) : (r = new s(o, this, this, u[te]({
									dependentModels: f,
									componentIndex: n
								}, t.keyInfo)), r.optionUpdated(this))
							} else r[x]({}, this), r.optionUpdated(this);
							a[e][n] = r, i[e][n] = r[_]
						}, this), e === j && (this._seriesIndices = o(a[j]))
					}
					var i = this[_],
						a = this._componentsMap,
						s = [];
					d(t, function(t, e) {
						null != t && (y.hasClass(e) ? s.push(e) : i[e] = null == i[e] ? u.clone(t) : u.merge(i[e], t, !0))
					}), y.topologicalTravel(s, y.getAllClassMainTypes(), e, this)
				},
				getOption: function() {
					var t = u.clone(this[_]);
					return d(t, function(e, i) {
						if (y.hasClass(i)) {
							for (var e = c.normalizeToArray(e), n = e[$] - 1; n >= 0; n--) c.isIdInner(e[n]) && e[X](n, 1);
							t[i] = e
						}
					}), delete t[w], t
				},
				getTheme: function() {
					return this._theme
				},
				getComponent: function(t, e) {
					var i = this._componentsMap[t];
					return i ? i[e || 0] : void 0
				},
				queryComponents: function(t) {
					var e = t.mainType;
					if (!e) return [];
					var i = t.index,
						n = t.id,
						r = t.name,
						a = this._componentsMap[e];
					if (!a || !a[$]) return [];
					var o;
					if (null != i) m(i) || (i = [i]), o = f(p(i, function(t) {
						return a[t]
					}), function(t) {
						return !!t
					});
					else if (null != n) {
						var l = m(n);
						o = f(a, function(t) {
							return l && v(n, t.id) >= 0 || !l && t.id === n
						})
					} else if (null != r) {
						var u = m(r);
						o = f(a, function(t) {
							return u && v(r, t.name) >= 0 || !u && t.name === r
						})
					}
					return s(o, t)
				},
				findComponents: function(t) {
					function e(t) {
						var e = r + "Index",
							i = r + "Id",
							n = r + "Name";
						return t && (t.hasOwnProperty(e) || t.hasOwnProperty(i) || t.hasOwnProperty(n)) ? {
							mainType: r,
							index: t[e],
							id: t[i],
							name: t[n]
						} : null
					}

					function i(e) {
						return t[pe] ? f(e, t[pe]) : e
					}
					var n = t.query,
						r = t.mainType,
						a = e(n),
						o = a ? this.queryComponents(a) : this._componentsMap[r];
					return i(s(o, t))
				},
				eachComponent: function(t, e, i) {
					var n = this._componentsMap;
					if (typeof t === Z) i = e, e = t, d(n, function(t, n) {
						d(t, function(t, r) {
							e.call(i, n, t, r)
						})
					});
					else if (u.isString(t)) d(n[t], e, i);
					else if (g(t)) {
						var r = this.findComponents(t);
						d(r, e, i)
					}
				},
				getSeriesByName: function(t) {
					var e = this._componentsMap[j];
					return f(e, function(e) {
						return e.name === t
					})
				},
				getSeriesByIndex: function(t) {
					return this._componentsMap[j][t]
				},
				getSeriesByType: function(t) {
					var e = this._componentsMap[j];
					return f(e, function(e) {
						return e.subType === t
					})
				},
				getSeries: function() {
					return this._componentsMap[j].slice()
				},
				eachSeries: function(t, e) {
					l(this), d(this._seriesIndices, function(i) {
						var n = this._componentsMap[j][i];
						t.call(e, n, i)
					}, this)
				},
				eachRawSeries: function(t, e) {
					d(this._componentsMap[j], t, e)
				},
				eachSeriesByType: function(t, e, i) {
					l(this), d(this._seriesIndices, function(n) {
						var r = this._componentsMap[j][n];
						r.subType === t && e.call(i, r, n)
					}, this)
				},
				eachRawSeriesByType: function(t, e, i) {
					return d(this.getSeriesByType(t), e, i)
				},
				isSeriesFiltered: function(t) {
					return l(this), u[N](this._seriesIndices, t.componentIndex) < 0
				},
				filterSeries: function(t, e) {
					l(this);
					var i = f(this._componentsMap[j], t, e);
					this._seriesIndices = o(i)
				},
				restoreData: function() {
					var t = this._componentsMap;
					this._seriesIndices = o(t[j]);
					var e = [];
					d(t, function(t, i) {
						e.push(i)
					}), y.topologicalTravel(e, y.getAllClassMainTypes(), function(e) {
						d(t[e], function(t) {
							t.restoreData()
						})
					})
				}
			});
		return M
	}), e("echarts/CoordinateSystem", [ve], function() {
		function t() {
			this._coordinateSystems = []
		}
		var e = {};
		return t[de] = {
			constructor: t,
			create: function(t, i) {
				var n = [];
				for (var r in e) {
					var a = e[r][re](t, i);
					a && (n = n.concat(a))
				}
				this._coordinateSystems = n
			},
			update: function(t, e) {
				for (var i = this._coordinateSystems, n = 0; n < i[$]; n++) i[n][ne] && i[n][ne](t, e)
			}
		}, t.register = function(t, i) {
			e[t] = i
		}, t.get = function(t) {
			return e[t]
		}, t
	}), e("echarts/model/OptionManager", [ve, me, "../util/model", "./Component"], function(t) {
		function e(t) {
			this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newOptionBackup
		}

		function i(t, e) {
			var i, n, r = [],
				a = [],
				o = t.timeline;
			if (t.baseOption && (n = t.baseOption), (o || t.options) && (n = n || {}, r = (t.options || []).slice()), t.media) {
				n = n || {};
				var l = t.media;
				c(l, function(t) {
					t && t[_] && (t.query ? a.push(t) : i || (i = t))
				})
			}
			return n || (n = t), n.timeline || (n.timeline = o), c([n].concat(r).concat(s.map(a, function(t) {
				return t[_]
			})), function(t) {
				c(e, function(e) {
					e(t)
				})
			}), {
				baseOption: n,
				timelineOptions: r,
				mediaDefault: i,
				mediaList: a
			}
		}

		function n(t, e, i) {
			var n = {
					width: e,
					height: i,
					aspectratio: e / i
				},
				a = !0;
			return s.each(t, function(t, e) {
				var i = e.match(p);
				if (i && i[1] && i[2]) {
					var o = i[1],
						s = i[2][fe]();
					r(n[s], t, o) || (a = !1)
				}
			}), a
		}

		function r(t, e, i) {
			return "min" === i ? t >= e : "max" === i ? e >= t : t === e
		}

		function a(t, e) {
			return t.join(",") === e.join(",")
		}

		function o(t, e) {
			e = e || {}, c(e, function(e, i) {
				if (null != e) {
					var n = t[i];
					if (u.hasClass(i)) {
						e = l.normalizeToArray(e), n = l.normalizeToArray(n);
						var r = l.mappingToExists(n, e);
						t[i] = d(r, function(t) {
							return t[_] && t.exist ? f(t.exist, t[_], !0) : t.exist || t[_]
						})
					} else t[i] = f(n, e, !0)
				}
			})
		}
		var s = t(me),
			l = t("../util/model"),
			u = t("./Component"),
			c = s.each,
			h = s.clone,
			d = s.map,
			f = s.merge,
			p = /^(min|max)?(.+)$/;
		return e[de] = {
			constructor: e,
			setOption: function(t, e) {
				t = h(t, !0);
				var n = this._optionBackup,
					r = this._newOptionBackup = i.call(this, t, e);
				n ? (o(n.baseOption, r.baseOption), r.timelineOptions[$] && (n.timelineOptions = r.timelineOptions), r.mediaList[$] && (n.mediaList = r.mediaList), r.mediaDefault && (n.mediaDefault = r.mediaDefault)) : this._optionBackup = r
			},
			mountOption: function(t) {
				var e = t ? this._optionBackup : this._newOptionBackup;
				return this._timelineOptions = d(e.timelineOptions, h), this._mediaList = d(e.mediaList, h), this._mediaDefault = h(e.mediaDefault), this._currentMediaIndices = [], h(e.baseOption)
			},
			getTimelineOption: function(t) {
				var e, i = this._timelineOptions;
				if (i[$]) {
					var n = t[y]("timeline");
					n && (e = h(i[n.getCurrentIndex()], !0))
				}
				return e
			},
			getMediaOption: function() {
				var t = this._api[ue](),
					e = this._api[le](),
					i = this._mediaList,
					r = this._mediaDefault,
					o = [],
					s = [];
				if (!i[$] && !r) return s;
				for (var l = 0, u = i[$]; u > l; l++) n(i[l].query, t, e) && o.push(l);
				return !o[$] && r && (o = [-1]), o[$] && !a(o, this._currentMediaIndices) && (s = d(o, function(t) {
					return h(-1 === t ? r[_] : i[t][_])
				})), this._currentMediaIndices = o, s
			}
		}, e
	}), e("echarts/model/Series", [ve, me, "../util/format", "../util/model", "./Component"], function(t) {
		var e = t(me),
			i = t("../util/format"),
			n = t("../util/model"),
			r = t("./Component"),
			a = i.encodeHTML,
			o = i.addCommas,
			s = r[te]({
				type: "series.__base__",
				seriesIndex: 0,
				coordinateSystem: null,
				defaultOption: null,
				legendDataProvider: null,
				init: function(t, e, i) {
					this[q] = this.componentIndex, this.mergeDefaultAndTheme(t, i), this._dataBeforeProcessed = this.getInitialData(t, i), this._data = this._dataBeforeProcessed.cloneShallow()
				},
				mergeDefaultAndTheme: function(t, i) {
					e.merge(t, i.getTheme().get(this.subType)), e.merge(t, this.getDefaultOption()), n.defaultEmphasis(t.label, [L, "show", O, "distance", "formatter"]);
					for (var r = t.data || [], a = 0; a < r[$]; a++) r[a] && r[a].label && n.defaultEmphasis(r[a].label, [L, "show", O, "distance", "formatter"])
				},
				mergeOption: function(t, i) {
					t = e.merge(this[_], t, !0);
					var n = this.getInitialData(t, i);
					n && (this._data = n, this._dataBeforeProcessed = n.cloneShallow())
				},
				getInitialData: function() {},
				getData: function() {
					return this._data
				},
				setData: function(t) {
					this._data = t
				},
				getRawData: function() {
					return this._dataBeforeProcessed
				},
				getRawDataArray: function() {
					return this[_].data
				},
				coordDimToDataDim: function(t) {
					return [t]
				},
				dataDimToCoordDim: function(t) {
					return t
				},
				getBaseAxis: function() {
					var t = this[R];
					return t && t.getBaseAxis && t.getBaseAxis()
				},
				formatTooltip: function(t, i) {
					var n = this._data,
						r = this.getRawValue(t),
						s = e[G](r) ? e.map(r, o).join(", ") : o(r),
						l = n[g](t),
						u = n[v](t, "color"),
						c = '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + u + '"></span>';
					return i ? c + a(this.name) + " : " + s : a(this.name) + "<br />" + c + (l ? a(l) + " : " + s : s)
				},
				restoreData: function() {
					this._data = this._dataBeforeProcessed.cloneShallow()
				}
			});
		return e.mixin(s, n.dataFormatMixin), s
	}), e("echarts/view/Component", [ve, "zrender/container/Group", "../util/component", "../util/clazz"], function(t) {
		var e = t("zrender/container/Group"),
			i = t("../util/component"),
			n = t("../util/clazz"),
			r = function() {
				this.group = new e, this.uid = i.getUID("viewComponent")
			};
		r[de] = {
			constructor: r,
			init: function() {},
			render: function() {},
			dispose: function() {}
		};
		var a = r[de];
		return a.updateView = a.updateLayout = a.updateVisual = function() {}, n.enableClassExtend(r), n.enableClassManagement(r, {
			registerWhenExtend: !0
		}), r
	}), e("echarts/model/Component", [ve, "./Model", me, "../util/component", "../util/clazz", "../util/layout", "./mixin/boxLayout"], function(t) {
		function e(t) {
			var e = [];
			return n.each(l.getClassesByMainType(t), function(t) {
				r.apply(e, t[de].dependencies || [])
			}), n.map(e, function(t) {
				return o.parseClassType(t).main
			})
		}
		var i = t("./Model"),
			n = t(me),
			r = Array[de].push,
			a = t("../util/component"),
			o = t("../util/clazz"),
			s = t("../util/layout"),
			l = i[te]({
				type: "component",
				id: "",
				name: "",
				mainType: "",
				subType: "",
				componentIndex: 0,
				defaultOption: null,
				ecModel: null,
				dependentModels: [],
				uid: null,
				layoutMode: null,
				init: function() {
					this.mergeDefaultAndTheme(this[_], this[m])
				},
				mergeDefaultAndTheme: function(t, e) {
					var i = this.layoutMode,
						r = i ? s.getLayoutParams(t) : {},
						a = e.getTheme();
					n.merge(t, a.get(this.mainType)), n.merge(t, this.getDefaultOption()), i && s.mergeLayoutParam(t, r, i)
				},
				mergeOption: function(t) {
					n.merge(this[_], t, !0);
					var e = this.layoutMode;
					e && s.mergeLayoutParam(this[_], t, e)
				},
				optionUpdated: function() {},
				getDefaultOption: function() {
					if (!this.hasOwnProperty("__defaultOption")) {
						for (var t = [], e = this.constructor; e;) {
							var i = e[de].defaultOption;
							i && t.push(i), e = e.superClass
						}
						for (var r = {}, a = t[$] - 1; a >= 0; a--) r = n.merge(r, t[a], !0);
						this.__defaultOption = r
					}
					return this.__defaultOption
				}
			});
		return o.enableClassExtend(l, function(t, e, i, r) {
			n[te](this, r), this.uid = a.getUID("componentModel")
		}), o.enableClassManagement(l, {
			registerWhenExtend: !0
		}), a.enableSubTypeDefaulter(l), a.enableTopologicalTravel(l, e), n.mixin(l, t("./mixin/boxLayout")), l
	}), e("echarts/util/graphic", [ve, me, "zrender/tool/path", "zrender/graphic/Path", "zrender/tool/color", "zrender/core/matrix", "zrender/core/vector", "zrender/graphic/Gradient", "zrender/container/Group", "zrender/graphic/Image", "zrender/graphic/Text", "zrender/graphic/shape/Circle", "zrender/graphic/shape/Sector", "zrender/graphic/shape/Ring", "zrender/graphic/shape/Polygon", "zrender/graphic/shape/Polyline", "zrender/graphic/shape/Rect", "zrender/graphic/shape/Line", "zrender/graphic/shape/BezierCurve", "zrender/graphic/shape/Arc", "zrender/graphic/LinearGradient", "zrender/graphic/RadialGradient", "zrender/core/BoundingRect"], function(t) {
		function e(t) {
			if (!t.__isHover) {
				if (t.__hoverStlDirty) {
					var e = t.style.stroke,
						i = t.style.fill,
						n = t.__hoverStl,
						r = _.lift;
					n.fill = n.fill || i && (i instanceof M ? i : r(i, -.1)), n.stroke = n.stroke || e && (e instanceof M ? e : r(e, -.1));
					var a = {};
					for (var o in n) n.hasOwnProperty(o) && (a[o] = t.style[o]);
					t.__normalStl = a, t.__hoverStlDirty = !1
				}
				t.setStyle(t.__hoverStl), t.z2 += 1, t.__isHover = !0
			}
		}

		function i(t) {
			if (t.__isHover) {
				var e = t.__normalStl;
				e && t.setStyle(e), t.z2 -= 1, t.__isHover = !1
			}
		}

		function n(t) {
			"group" === t.type ? t.traverse(function(t) {
				"group" !== t.type && e(t)
			}) : e(t)
		}

		function r(t) {
			"group" === t.type ? t.traverse(function(t) {
				"group" !== t.type && i(t)
			}) : i(t)
		}

		function a(t, e) {
			t.__hoverStl = t.hoverStyle || e || {}, t.__hoverStlDirty = !0
		}

		function o() {
			!this.__isEmphasis && n(this)
		}

		function s() {
			!this.__isEmphasis && r(this)
		}

		function l() {
			this.__isEmphasis = !0, n(this)
		}

		function u() {
			this.__isEmphasis = !1, r(this)
		}

		function m(t, e, i, n, r) {
			var a = t ? "Update" : "",
				o = n && n[h]("animationDuration" + a),
				s = n && n[h]("animationEasing" + a);
			n && n[h]("animation") ? e.animateTo(i, o, s, r) : (e.attr(i), r && r())
		}
		var v = t(me),
			g = t("zrender/tool/path"),
			y = Math.round,
			x = t("zrender/graphic/Path"),
			_ = t("zrender/tool/color"),
			b = t("zrender/core/matrix"),
			w = t("zrender/core/vector"),
			M = t("zrender/graphic/Gradient"),
			S = {};
		return S.Group = t("zrender/container/Group"), S.Image = t("zrender/graphic/Image"), S.Text = t("zrender/graphic/Text"), S.Circle = t("zrender/graphic/shape/Circle"), S.Sector = t("zrender/graphic/shape/Sector"), S.Ring = t("zrender/graphic/shape/Ring"), S.Polygon = t("zrender/graphic/shape/Polygon"), S.Polyline = t("zrender/graphic/shape/Polyline"), S.Rect = t("zrender/graphic/shape/Rect"), S.Line = t("zrender/graphic/shape/Line"), S.BezierCurve = t("zrender/graphic/shape/BezierCurve"), S.Arc = t("zrender/graphic/shape/Arc"), S.LinearGradient = t("zrender/graphic/LinearGradient"), S.RadialGradient = t("zrender/graphic/RadialGradient"), S.BoundingRect = t("zrender/core/BoundingRect"), S.extendShape = function(t) {
			return x[te](t)
		}, S.extendPath = function(t, e) {
			return g.extendFromString(t, e)
		}, S.makePath = function(t, e, i, n) {
			var r = g.createFromString(t, e),
				a = r[P]();
			if (i) {
				var o = a.width / a[ae];
				if (n === k) {
					var s, l = i[ae] * o;
					l <= i.width ? s = i[ae] : (l = i.width, s = l / o);
					var u = i.x + i.width / 2,
						c = i.y + i[ae] / 2;
					i.x = u - l / 2, i.y = c - s / 2, i.width = l, i[ae] = s
				}
				this.resizePath(r, i)
			}
			return r
		}, S.mergePath = g.mergePath, S.resizePath = function(t, e) {
			if (t[p]) {
				var i = t[P](),
					n = i.calculateTransform(e);
				t[p](n)
			}
		}, S.subPixelOptimizeLine = function(t) {
			var e = S.subPixelOptimize,
				i = t.shape,
				n = t.style.lineWidth;
			return y(2 * i.x1) === y(2 * i.x2) && (i.x1 = i.x2 = e(i.x1, n, !0)), y(2 * i.y1) === y(2 * i.y2) && (i.y1 = i.y2 = e(i.y1, n, !0)), t
		}, S.subPixelOptimizeRect = function(t) {
			var e = S.subPixelOptimize,
				i = t.shape,
				n = t.style.lineWidth,
				r = i.x,
				a = i.y,
				o = i.width,
				s = i[ae];
			return i.x = e(i.x, n, !0), i.y = e(i.y, n, !0), i.width = Math.max(e(r + o, n, !1) - i.x, 0 === o ? 0 : 1), i[ae] = Math.max(e(a + s, n, !1) - i.y, 0 === s ? 0 : 1), t
		}, S.subPixelOptimize = function(t, e, i) {
			var n = y(2 * t);
			return (n + y(e)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2
		}, S.setHoverStyle = function(t, e) {
			"group" === t.type ? t.traverse(function(t) {
				"group" !== t.type && a(t, e)
			}) : a(t, e), t.on(H, o).on(W, s), t.on(f, l).on(d, u)
		}, S.setText = function(t, e, i) {
			var n = e[h](L) || "inside",
				r = n[N]("inside") >= 0 ? "white" : i,
				a = e[ce](O);
			v[te](t, {
				textDistance: e[h]("distance") || 5,
				textFont: a[D](),
				textPosition: n,
				textFill: a[T]() || r
			})
		}, S.updateProps = v.curry(m, !0), S.initProps = v.curry(m, !1), S.getTransform = function(t, e) {
			for (var i = b.identity([]); t && t !== e;) b.mul(i, t.getLocalTransform(), i), t = t[c];
			return i
		}, S[p] = function(t, e, i) {
			return i && (e = b.invert([], e)), w[p]([], t, e)
		}, S.transformDirection = function(t, e, i) {
			var n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]),
				r = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]),
				a = ["left" === t ? -n : "right" === t ? n : 0, "top" === t ? -r : t === oe ? r : 0];
			return a = S[p](a, e, i), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? oe : "top"
		}, S
	}), e("echarts/view/Chart", [ve, "zrender/container/Group", "../util/component", "../util/clazz"], function(t) {
		function e() {
			this.group = new r, this.uid = a.getUID("viewChart")
		}

		function i(t, e) {
			if (t && (t[Q](e), "group" === t.type))
				for (var n = 0; n < t.childCount(); n++) i(t.childAt(n), e)
		}

		function n(t, e, n) {
			if (null != e.dataIndex) {
				var r = t.getItemGraphicEl(e.dataIndex);
				i(r, n)
			} else if (e.name) {
				var a = t.indexOfName(e.name),
					r = t.getItemGraphicEl(a);
				i(r, n)
			} else t.eachItemGraphicEl(function(t) {
				i(t, n)
			})
		}
		var r = t("zrender/container/Group"),
			a = t("../util/component"),
			o = t("../util/clazz");
		e[de] = {
			type: "chart",
			init: function() {},
			render: function() {},
			highlight: function(t, e, i, r) {
				n(t[U](), r, f)
			},
			downplay: function(t, e, i, r) {
				n(t[U](), r, d)
			},
			remove: function() {
				this.group[E]()
			},
			dispose: function() {}
		};
		var s = e[de];
		return s.updateView = s.updateLayout = s.updateVisual = function(t, e, i, n) {
			this.render(t, e, i, n)
		}, o.enableClassExtend(e), o.enableClassManagement(e, {
			registerWhenExtend: !0
		}), e
	}), e("zrender/zrender", [ve, "./core/guid", "./core/env", "./Handler", "./Storage", "./animation/Animation", "./Painter"], function(t) {
		function e(t) {
			delete u[t]
		}
		var i = t("./core/guid"),
			n = t("./core/env"),
			r = t("./Handler"),
			a = t("./Storage"),
			o = t("./animation/Animation"),
			s = !n.canvasSupported,
			l = {
				canvas: t("./Painter")
			},
			u = {},
			c = {};
		c.version = "3.0.7", c.init = function(t, e) {
			var n = new h(i(), t, e);
			return u[n.id] = n, n
		}, c.dispose = function(t) {
			if (t) t.dispose();
			else {
				for (var e in u) u[e].dispose();
				u = {}
			}
			return c
		}, c.getInstance = function(t) {
			return u[t]
		}, c.registerPainter = function(t, e) {
			l[t] = e
		};
		var h = function(t, e, i) {
			i = i || {}, this.dom = e, this.id = t;
			var u = this,
				c = new a,
				h = i.renderer;
			if (s) {
				if (!l.vml) throw new Error("You need to require 'zrender/vml/vml' to support IE8");
				h = "vml"
			} else h && l[h] || (h = "canvas");
			var d = new l[h](e, c, i);
			this.storage = c, this.painter = d, n.node || (this.handler = new r(d.getViewportRoot(), c, d)), this.animation = new o({
				stage: {
					update: function() {
						u._needsRefresh && u.refreshImmediately()
					}
				}
			}), this.animation.start(), this._needsRefresh;
			var f = c.delFromMap,
				p = c.addToMap;
			c.delFromMap = function(t) {
				var e = c.get(t);
				f.call(c, t), e && e.removeSelfFromZr(u)
			}, c.addToMap = function(t) {
				p.call(c, t), t.addSelfToZr(u)
			}
		};
		return h[de] = {
			constructor: h,
			getId: function() {
				return this.id
			},
			add: function(t) {
				this.storage.addRoot(t), this._needsRefresh = !0
			},
			remove: function(t) {
				this.storage.delRoot(t), this._needsRefresh = !0
			},
			configLayer: function(t, e) {
				this.painter.configLayer(t, e), this._needsRefresh = !0
			},
			refreshImmediately: function() {
				this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1
			},
			refresh: function() {
				this._needsRefresh = !0
			},
			resize: function() {
				this.painter.resize(), this.handler && this.handler.resize()
			},
			clearAnimation: function() {
				this.animation.clear()
			},
			getWidth: function() {
				return this.painter[ue]()
			},
			getHeight: function() {
				return this.painter[le]()
			},
			toDataURL: function(t, e, i) {
				return this.painter.toDataURL(t, e, i)
			},
			pathToImage: function(t, e, n) {
				var r = i();
				return this.painter.pathToImage(r, t, e, n)
			},
			setDefaultCursorStyle: function(t) {
				this.handler.setDefaultCursorStyle(t)
			},
			on: function(t, e, i) {
				this.handler && this.handler.on(t, e, i)
			},
			off: function(t, e) {
				this.handler && this.handler.off(t, e)
			},
			trigger: function(t, e) {
				this.handler && this.handler[Q](t, e)
			},
			clear: function() {
				this.storage.delRoot(), this.painter.clear()
			},
			dispose: function() {
				this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler && this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, e(this.id)
			}
		}, c
	}), e("zrender/tool/color", [ve], function() {
		function t(t) {
			return t = Math.round(t), 0 > t ? 0 : t > 255 ? 255 : t
		}

		function e(t) {
			return t = Math.round(t), 0 > t ? 0 : t > 360 ? 360 : t
		}

		function i(t) {
			return 0 > t ? 0 : t > 1 ? 1 : t
		}

		function n(e) {
			return t(e[$] && "%" === e.charAt(e[$] - 1) ? parseFloat(e) / 100 * 255 : parseInt(e, 10))
		}

		function r(t) {
			return i(t[$] && "%" === t.charAt(t[$] - 1) ? parseFloat(t) / 100 : parseFloat(t))
		}

		function a(t, e, i) {
			return 0 > i ? i += 1 : i > 1 && (i -= 1), 1 > 6 * i ? t + (e - t) * i * 6 : 1 > 2 * i ? e : 2 > 3 * i ? t + (e - t) * (2 / 3 - i) * 6 : t
		}

		function o(t, e, i) {
			return t + (e - t) * i
		}

		function s(t) {
			if (t) {
				t += "";
				var e = t[F](/ /g, "")[fe]();
				if (e in y) return y[e].slice();
				if ("#" !== e.charAt(0)) {
					var i = e[N]("("),
						a = e[N](")");
					if (-1 !== i && a + 1 === e[$]) {
						var o = e.substr(0, i),
							s = e.substr(i + 1, a - (i + 1)).split(","),
							u = 1;
						switch (o) {
							case "rgba":
								if (4 !== s[$]) return;
								u = r(s.pop());
							case "rgb":
								if (3 !== s[$]) return;
								return [n(s[0]), n(s[1]), n(s[2]), u];
							case "hsla":
								if (4 !== s[$]) return;
								return s[3] = r(s[3]), l(s);
							case "hsl":
								if (3 !== s[$]) return;
								return l(s);
							default:
								return
						}
					}
				} else {
					if (4 === e[$]) {
						var c = parseInt(e.substr(1), 16);
						if (!(c >= 0 && 4095 >= c)) return;
						return [(3840 & c) >> 4 | (3840 & c) >> 8, 240 & c | (240 & c) >> 4, 15 & c | (15 & c) << 4, 1]
					}
					if (7 === e[$]) {
						var c = parseInt(e.substr(1), 16);
						if (!(c >= 0 && 16777215 >= c)) return;
						return [(16711680 & c) >> 16, (65280 & c) >> 8, 255 & c, 1]
					}
				}
			}
		}

		function l(e) {
			var i = (parseFloat(e[0]) % 360 + 360) % 360 / 360,
				n = r(e[1]),
				o = r(e[2]),
				s = .5 >= o ? o * (n + 1) : o + n - o * n,
				l = 2 * o - s,
				u = [t(255 * a(l, s, i + 1 / 3)), t(255 * a(l, s, i)), t(255 * a(l, s, i - 1 / 3))];
			return 4 === e[$] && (u[3] = e[3]), u
		}

		function u(t) {
			if (t) {
				var e, i, n = t[0] / 255,
					r = t[1] / 255,
					a = t[2] / 255,
					o = Math.min(n, r, a),
					s = Math.max(n, r, a),
					l = s - o,
					u = (s + o) / 2;
				if (0 === l) e = 0, i = 0;
				else {
					i = .5 > u ? l / (s + o) : l / (2 - s - o);
					var c = ((s - n) / 6 + l / 2) / l,
						h = ((s - r) / 6 + l / 2) / l,
						d = ((s - a) / 6 + l / 2) / l;
					n === s ? e = d - h : r === s ? e = 1 / 3 + c - d : a === s && (e = 2 / 3 + h - c), 0 > e && (e += 1), e > 1 && (e -= 1)
				}
				var f = [360 * e, i, u];
				return null != t[3] && f.push(t[3]), f
			}
		}

		function c(t, e) {
			var i = s(t);
			if (i) {
				for (var n = 0; 3 > n; n++) i[n] = 0 > e ? i[n] * (1 - e) | 0 : (255 - i[n]) * e + i[n] | 0;
				return g(i, 4 === i[$] ? "rgba" : "rgb")
			}
		}

		function h(t) {
			var e = s(t);
			return e ? ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1) : void 0
		}

		function d(e, i, n) {
			if (i && i[$] && e >= 0 && 1 >= e) {
				n = n || [0, 0, 0, 0];
				var r = e * (i[$] - 1),
					a = Math.floor(r),
					s = Math.ceil(r),
					l = i[a],
					u = i[s],
					c = r - a;
				return n[0] = t(o(l[0], u[0], c)), n[1] = t(o(l[1], u[1], c)), n[2] = t(o(l[2], u[2], c)), n[3] = t(o(l[3], u[3], c)), n
			}
		}

		function f(e, n, r) {
			if (n && n[$] && e >= 0 && 1 >= e) {
				var a = e * (n[$] - 1),
					l = Math.floor(a),
					u = Math.ceil(a),
					c = s(n[l]),
					h = s(n[u]),
					d = a - l,
					f = g([t(o(c[0], h[0], d)), t(o(c[1], h[1], d)), t(o(c[2], h[2], d)), i(o(c[3], h[3], d))], "rgba");
				return r ? {
					color: f,
					leftIndex: l,
					rightIndex: u,
					value: a
				} : f
			}
		}

		function p(t, e) {
			if (!(2 !== t[$] || t[1] < t[0])) {
				for (var i = f(t[0], e, !0), n = f(t[1], e, !0), r = [{
						color: i.color,
						offset: 0
					}], a = n.value - i.value, o = Math.max(i.value, i.rightIndex), s = Math.min(n.value, n.leftIndex), l = o; a > 0 && s >= l; l++) r.push({
					color: e[l],
					offset: (l - i.value) / a
				});
				return r.push({
					color: n.color,
					offset: 1
				}), r
			}
		}

		function m(t, i, n, a) {
			return t = s(t), t ? (t = u(t), null != i && (t[0] = e(i)), null != n && (t[1] = r(n)), null != a && (t[2] = r(a)), g(l(t), "rgba")) : void 0
		}

		function v(t, e) {
			return t = s(t), t && null != e ? (t[3] = i(e), g(t, "rgba")) : void 0
		}

		function g(t, e) {
			return ("rgb" === e || "hsv" === e || "hsl" === e) && (t = t.slice(0, 3)), e + "(" + t.join(",") + ")"
		}
		var y = {
			transparent: [0, 0, 0, 0],
			aliceblue: [240, 248, 255, 1],
			antiquewhite: [250, 235, 215, 1],
			aqua: [0, 255, 255, 1],
			aquamarine: [127, 255, 212, 1],
			azure: [240, 255, 255, 1],
			beige: [245, 245, 220, 1],
			bisque: [255, 228, 196, 1],
			black: [0, 0, 0, 1],
			blanchedalmond: [255, 235, 205, 1],
			blue: [0, 0, 255, 1],
			blueviolet: [138, 43, 226, 1],
			brown: [165, 42, 42, 1],
			burlywood: [222, 184, 135, 1],
			cadetblue: [95, 158, 160, 1],
			chartreuse: [127, 255, 0, 1],
			chocolate: [210, 105, 30, 1],
			coral: [255, 127, 80, 1],
			cornflowerblue: [100, 149, 237, 1],
			cornsilk: [255, 248, 220, 1],
			crimson: [220, 20, 60, 1],
			cyan: [0, 255, 255, 1],
			darkblue: [0, 0, 139, 1],
			darkcyan: [0, 139, 139, 1],
			darkgoldenrod: [184, 134, 11, 1],
			darkgray: [169, 169, 169, 1],
			darkgreen: [0, 100, 0, 1],
			darkgrey: [169, 169, 169, 1],
			darkkhaki: [189, 183, 107, 1],
			darkmagenta: [139, 0, 139, 1],
			darkolivegreen: [85, 107, 47, 1],
			darkorange: [255, 140, 0, 1],
			darkorchid: [153, 50, 204, 1],
			darkred: [139, 0, 0, 1],
			darksalmon: [233, 150, 122, 1],
			darkseagreen: [143, 188, 143, 1],
			darkslateblue: [72, 61, 139, 1],
			darkslategray: [47, 79, 79, 1],
			darkslategrey: [47, 79, 79, 1],
			darkturquoise: [0, 206, 209, 1],
			darkviolet: [148, 0, 211, 1],
			deeppink: [255, 20, 147, 1],
			deepskyblue: [0, 191, 255, 1],
			dimgray: [105, 105, 105, 1],
			dimgrey: [105, 105, 105, 1],
			dodgerblue: [30, 144, 255, 1],
			firebrick: [178, 34, 34, 1],
			floralwhite: [255, 250, 240, 1],
			forestgreen: [34, 139, 34, 1],
			fuchsia: [255, 0, 255, 1],
			gainsboro: [220, 220, 220, 1],
			ghostwhite: [248, 248, 255, 1],
			gold: [255, 215, 0, 1],
			goldenrod: [218, 165, 32, 1],
			gray: [128, 128, 128, 1],
			green: [0, 128, 0, 1],
			greenyellow: [173, 255, 47, 1],
			grey: [128, 128, 128, 1],
			honeydew: [240, 255, 240, 1],
			hotpink: [255, 105, 180, 1],
			indianred: [205, 92, 92, 1],
			indigo: [75, 0, 130, 1],
			ivory: [255, 255, 240, 1],
			khaki: [240, 230, 140, 1],
			lavender: [230, 230, 250, 1],
			lavenderblush: [255, 240, 245, 1],
			lawngreen: [124, 252, 0, 1],
			lemonchiffon: [255, 250, 205, 1],
			lightblue: [173, 216, 230, 1],
			lightcoral: [240, 128, 128, 1],
			lightcyan: [224, 255, 255, 1],
			lightgoldenrodyellow: [250, 250, 210, 1],
			lightgray: [211, 211, 211, 1],
			lightgreen: [144, 238, 144, 1],
			lightgrey: [211, 211, 211, 1],
			lightpink: [255, 182, 193, 1],
			lightsalmon: [255, 160, 122, 1],
			lightseagreen: [32, 178, 170, 1],
			lightskyblue: [135, 206, 250, 1],
			lightslategray: [119, 136, 153, 1],
			lightslategrey: [119, 136, 153, 1],
			lightsteelblue: [176, 196, 222, 1],
			lightyellow: [255, 255, 224, 1],
			lime: [0, 255, 0, 1],
			limegreen: [50, 205, 50, 1],
			linen: [250, 240, 230, 1],
			magenta: [255, 0, 255, 1],
			maroon: [128, 0, 0, 1],
			mediumaquamarine: [102, 205, 170, 1],
			mediumblue: [0, 0, 205, 1],
			mediumorchid: [186, 85, 211, 1],
			mediumpurple: [147, 112, 219, 1],
			mediumseagreen: [60, 179, 113, 1],
			mediumslateblue: [123, 104, 238, 1],
			mediumspringgreen: [0, 250, 154, 1],
			mediumturquoise: [72, 209, 204, 1],
			mediumvioletred: [199, 21, 133, 1],
			midnightblue: [25, 25, 112, 1],
			mintcream: [245, 255, 250, 1],
			mistyrose: [255, 228, 225, 1],
			moccasin: [255, 228, 181, 1],
			navajowhite: [255, 222, 173, 1],
			navy: [0, 0, 128, 1],
			oldlace: [253, 245, 230, 1],
			olive: [128, 128, 0, 1],
			olivedrab: [107, 142, 35, 1],
			orange: [255, 165, 0, 1],
			orangered: [255, 69, 0, 1],
			orchid: [218, 112, 214, 1],
			palegoldenrod: [238, 232, 170, 1],
			palegreen: [152, 251, 152, 1],
			paleturquoise: [175, 238, 238, 1],
			palevioletred: [219, 112, 147, 1],
			papayawhip: [255, 239, 213, 1],
			peachpuff: [255, 218, 185, 1],
			peru: [205, 133, 63, 1],
			pink: [255, 192, 203, 1],
			plum: [221, 160, 221, 1],
			powderblue: [176, 224, 230, 1],
			purple: [128, 0, 128, 1],
			red: [255, 0, 0, 1],
			rosybrown: [188, 143, 143, 1],
			royalblue: [65, 105, 225, 1],
			saddlebrown: [139, 69, 19, 1],
			salmon: [250, 128, 114, 1],
			sandybrown: [244, 164, 96, 1],
			seagreen: [46, 139, 87, 1],
			seashell: [255, 245, 238, 1],
			sienna: [160, 82, 45, 1],
			silver: [192, 192, 192, 1],
			skyblue: [135, 206, 235, 1],
			slateblue: [106, 90, 205, 1],
			slategray: [112, 128, 144, 1],
			slategrey: [112, 128, 144, 1],
			snow: [255, 250, 250, 1],
			springgreen: [0, 255, 127, 1],
			steelblue: [70, 130, 180, 1],
			tan: [210, 180, 140, 1],
			teal: [0, 128, 128, 1],
			thistle: [216, 191, 216, 1],
			tomato: [255, 99, 71, 1],
			turquoise: [64, 224, 208, 1],
			violet: [238, 130, 238, 1],
			wheat: [245, 222, 179, 1],
			white: [255, 255, 255, 1],
			whitesmoke: [245, 245, 245, 1],
			yellow: [255, 255, 0, 1],
			yellowgreen: [154, 205, 50, 1]
		};
		return {
			parse: s,
			lift: c,
			toHex: h,
			fastMapToColor: d,
			mapToColor: f,
			mapIntervalToColor: p,
			modifyHSL: m,
			modifyAlpha: v,
			stringify: g
		}
	}), e("zrender/core/env", [], function() {
		function t(t) {
			var e = {},
				i = {},
				n = t.match(/Web[kK]it[\/]{0,1}([\d.]+)/),
				r = t.match(/(Android);?[\s\/]+([\d.]+)?/),
				a = t.match(/(iPad).*OS\s([\d_]+)/),
				o = t.match(/(iPod)(.*OS\s([\d_]+))?/),
				s = !a && t.match(/(iPhone\sOS)\s([\d_]+)/),
				l = t.match(/(webOS|hpwOS)[\s\/]([\d.]+)/),
				u = l && t.match(/TouchPad/),
				c = t.match(/Kindle\/([\d.]+)/),
				h = t.match(/Silk\/([\d._]+)/),
				d = t.match(/(BlackBerry).*Version\/([\d.]+)/),
				f = t.match(/(BB10).*Version\/([\d.]+)/),
				p = t.match(/(RIM\sTablet\sOS)\s([\d.]+)/),
				m = t.match(/PlayBook/),
				v = t.match(/Chrome\/([\d.]+)/) || t.match(/CriOS\/([\d.]+)/),
				g = t.match(/Firefox\/([\d.]+)/),
				y = n && t.match(/Mobile\//) && !v,
				x = t.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !v,
				_ = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/),
				b = t.match(/Edge\/([\d.]+)/);
			return (i.webkit = !!n) && (i.version = n[1]), r && (e.android = !0, e.version = r[2]), s && !o && (e.ios = e.iphone = !0, e.version = s[2][F](/_/g, ".")), a && (e.ios = e.ipad = !0, e.version = a[2][F](/_/g, ".")), o && (e.ios = e.ipod = !0, e.version = o[3] ? o[3][F](/_/g, ".") : null), l && (e.webos = !0, e.version = l[2]), u && (e.touchpad = !0), d && (e.blackberry = !0, e.version = d[2]), f && (e.bb10 = !0, e.version = f[2]), p && (e.rimtabletos = !0, e.version = p[2]), m && (i.playbook = !0), c && (e.kindle = !0, e.version = c[1]), h && (i.silk = !0, i.version = h[1]), !h && e.android && t.match(/Kindle Fire/) && (i.silk = !0), v && (i.chrome = !0, i.version = v[1]), g && (i.firefox = !0, i.version = g[1]), _ && (i.ie = !0, i.version = _[1]), y && (t.match(/Safari/) || e.ios) && (i.safari = !0), x && (i.webview = !0), _ && (i.ie = !0, i.version = _[1]), b && (i.edge = !0, i.version = b[1]), e.tablet = !!(a || m || r && !t.match(/Mobile/) || g && t.match(/Tablet/) || _ && !t.match(/Phone/) && t.match(/Touch/)), e.phone = !(e.tablet || e.ipod || !(r || s || l || d || f || v && t.match(/Android/) || v && t.match(/CriOS\/([\d.]+)/) || g && t.match(/Mobile/) || _ && t.match(/Touch/))), {
				browser: i,
				os: e,
				node: !1,
				canvasSupported: document.createElement("canvas")[M] ? !0 : !1,
				touchEventsSupported: "ontouchstart" in window && !i.ie && !i.edge,
				pointerEventsSupported: "onpointerdown" in window && (i.edge || i.ie && i.version >= 10)
			}
		}
		var e = {};
		return e = typeof navigator === u ? {
			browser: {},
			os: {},
			node: !0,
			canvasSupported: !0
		} : t(navigator.userAgent)
	}), e("zrender/mixin/Eventful", [ve, l], function(t) {
		var e = Array[de].slice,
			i = t(l),
			n = i[N],
			r = function() {
				this._$handlers = {}
			};
		return r[de] = {
			constructor: r,
			one: function(t, e, i) {
				var r = this._$handlers;
				return e && t ? (r[t] || (r[t] = []), n(r[t], t) >= 0 ? this : (r[t].push({
					h: e,
					one: !0,
					ctx: i || this
				}), this)) : this
			},
			on: function(t, e, i) {
				var n = this._$handlers;
				return e && t ? (n[t] || (n[t] = []), n[t].push({
					h: e,
					one: !1,
					ctx: i || this
				}), this) : this
			},
			isSilent: function(t) {
				var e = this._$handlers;
				return e[t] && e[t][$]
			},
			off: function(t, e) {
				var i = this._$handlers;
				if (!t) return this._$handlers = {}, this;
				if (e) {
					if (i[t]) {
						for (var n = [], r = 0, a = i[t][$]; a > r; r++) i[t][r].h != e && n.push(i[t][r]);
						i[t] = n
					}
					i[t] && 0 === i[t][$] && delete i[t]
				} else delete i[t];
				return this
			},
			trigger: function(t) {
				if (this._$handlers[t]) {
					var i = arguments,
						n = i[$];
					n > 3 && (i = e.call(i, 1));
					for (var r = this._$handlers[t], a = r[$], o = 0; a > o;) {
						switch (n) {
							case 1:
								r[o].h.call(r[o].ctx);
								break;
							case 2:
								r[o].h.call(r[o].ctx, i[1]);
								break;
							case 3:
								r[o].h.call(r[o].ctx, i[1], i[2]);
								break;
							default:
								r[o].h.apply(r[o].ctx, i)
						}
						r[o].one ? (r[X](o, 1), a--) : o++
					}
				}
				return this
			},
			triggerWithContext: function(t) {
				if (this._$handlers[t]) {
					var i = arguments,
						n = i[$];
					n > 4 && (i = e.call(i, 1, i[$] - 1));
					for (var r = i[i[$] - 1], a = this._$handlers[t], o = a[$], s = 0; o > s;) {
						switch (n) {
							case 1:
								a[s].h.call(r);
								break;
							case 2:
								a[s].h.call(r, i[1]);
								break;
							case 3:
								a[s].h.call(r, i[1], i[2]);
								break;
							default:
								a[s].h.apply(r, i)
						}
						a[s].one ? (a[X](s, 1), o--) : s++
					}
				}
				return this
			}
		}, r
	}), e("echarts/loading/default", [ve, "../util/graphic", me], function(t) {
		var e = t("../util/graphic"),
			i = t(me),
			n = Math.PI;
		return function(t, r) {
			r = r || {}, i[K](r, {
				text: "loading",
				color: "#c23531",
				textColor: "#000",
				maskColor: "rgba(255, 255, 255, 0.8)",
				zlevel: 0
			});
			var a = new e.Rect({
					style: {
						fill: r.maskColor
					},
					zlevel: r.zlevel,
					z: 1e4
				}),
				o = new e.Arc({
					shape: {
						startAngle: -n / 2,
						endAngle: -n / 2 + .1,
						r: 10
					},
					style: {
						stroke: r.color,
						lineCap: "round",
						lineWidth: 5
					},
					zlevel: r.zlevel,
					z: 10001
				}),
				s = new e.Rect({
					style: {
						fill: "none",
						text: r.text,
						textPosition: "right",
						textDistance: 10,
						textFill: r.textColor
					},
					zlevel: r.zlevel,
					z: 10001
				});
			o.animateShape(!0).when(1e3, {
				endAngle: 3 * n / 2
			}).start("circularInOut"), o.animateShape(!0).when(1e3, {
				startAngle: 3 * n / 2
			}).delay(300).start("circularInOut");
			var l = new e.Group;
			return l.add(o), l.add(s), l.add(a), l.resize = function() {
				var e = t[ue]() / 2,
					i = t[le]() / 2;
				o.setShape({
					cx: e,
					cy: i
				});
				var n = o.shape.r;
				s.setShape({
					x: e - n,
					y: i - n,
					width: 2 * n,
					height: 2 * n
				}), a.setShape({
					x: 0,
					y: 0,
					width: t[ue](),
					height: t[le]()
				})
			}, l.resize(), l
		}
	}), e("echarts/visual/seriesColor", [ve, "zrender/graphic/Gradient"], function(t) {
		var e = t("zrender/graphic/Gradient");
		return function(t, i, n) {
			function r(t) {
				var r = [i, d, "color"],
					a = n.get("color"),
					o = t[U](),
					s = t.get(r) || a[t[q] % a[$]];
				o.setVisual("color", s), n.isSeriesFiltered(t) || (typeof s !== Z || s instanceof e || o.each(function(e) {
					o.setItemVisual(e, "color", s(t.getDataParams(e)))
				}), o.each(function(t) {
					var e = o[b](t),
						i = e.get(r, !0);
					null != i && o.setItemVisual(t, "color", i)
				}))
			}
			t ? n.eachSeriesByType(t, r) : n[Y](r)
		}
	}), e("echarts/preprocessor/backwardCompat", [ve, me, "./helper/compatStyle"], function(t) {
		function e(t, e) {
			e = e.split(",");
			for (var i = t, n = 0; n < e[$] && (i = i && i[e[n]], null != i); n++);
			return i
		}

		function i(t, e, i, n) {
			e = e.split(",");
			for (var r, a = t, o = 0; o < e[$] - 1; o++) r = e[o], null == a[r] && (a[r] = {}), a = a[r];
			(n || null == a[e[o]]) && (a[e[o]] = i)
		}

		function n(t) {
			u(o, function(e) {
				e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]])
			})
		}
		var r = t(me),
			a = t("./helper/compatStyle"),
			o = [
				["x", "left"],
				["y", "top"],
				["x2", "right"],
				["y2", oe]
			],
			s = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"],
			l = ["bar", "boxplot", "candlestick", "chord", "effectScatter", "funnel", "gauge", "lines", "graph", "heatmap", "line", "map", "parallel", "pie", "radar", "sankey", "scatter", "treemap"],
			u = r.each;
		return function(t) {
			u(t[j], function(t) {
				if (r[ie](t)) {
					var o = t.type;
					if (a(t), ("pie" === o || "gauge" === o) && null != t.clockWise && (t.clockwise = t.clockWise), "gauge" === o) {
						var s = e(t, "pointer.color");
						null != s && i(t, "itemStyle.normal.color", s)
					}
					for (var u = 0; u < l[$]; u++)
						if (l[u] === t.type) {
							n(t);
							break
						}
				}
			}), t.dataRange && (t.visualMap = t.dataRange), u(s, function(e) {
				var i = t[e];
				i && (r[G](i) || (i = [i]), u(i, function(t) {
					n(t)
				}))
			})
		}
	}), e("echarts/util/number", [ve], function() {
		function t(t) {
			return t[F](/^\s+/, "")[F](/\s+$/, "")
		}
		var e = {},
			i = 1e-4;
		return e.linearMap = function(t, e, i, n) {
			var r = e[1] - e[0];
			if (0 === r) return (i[0] + i[1]) / 2;
			var a = (t - e[0]) / r;
			return n && (a = Math.min(Math.max(a, 0), 1)), a * (i[1] - i[0]) + i[0]
		}, e.parsePercent = function(e, i) {
			switch (e) {
				case k:
				case z:
					e = "50%";
					break;
				case "left":
				case "top":
					e = "0%";
					break;
				case "right":
				case oe:
					e = "100%"
			}
			return typeof e === he ? t(e).match(/%$/) ? parseFloat(e) / 100 * i : parseFloat(e) : null == e ? 0 / 0 : +e
		}, e.round = function(t) {
			return +(+t).toFixed(12)
		}, e.asc = function(t) {
			return t.sort(function(t, e) {
				return t - e
			}), t
		}, e.getPrecision = function(t) {
			if (isNaN(t)) return 0;
			for (var e = 1, i = 0; Math.round(t * e) / e !== t;) e *= 10, i++;
			return i
		}, e.getPixelPrecision = function(t, e) {
			var i = Math.log,
				n = Math.LN10,
				r = Math.floor(i(t[1] - t[0]) / n),
				a = Math.round(i(Math.abs(e[1] - e[0])) / n);
			return Math.max(-r + a, 0)
		}, e.MAX_SAFE_INTEGER = 9007199254740991, e.remRadian = function(t) {
			var e = 2 * Math.PI;
			return (t % e + e) % e
		}, e.isRadianAroundZero = function(t) {
			return t > -i && i > t
		}, e.parseDate = function(t) {
			return t instanceof Date ? t : new Date(typeof t === he ? t[F](/-/g, "/") : Math.round(t))
		}, e.nice = function(t, e) {
			var i, n = Math.floor(Math.log(t) / Math.LN10),
				r = Math.pow(10, n),
				a = t / r;
			return i = e ? 1.5 > a ? 1 : 2.5 > a ? 2 : 4 > a ? 3 : 7 > a ? 5 : 10 : 1 > a ? 1 : 2 > a ? 2 : 3 > a ? 3 : 5 > a ? 5 : 10, i * r
		}, e
	}), e("echarts/util/format", [ve, me, "./number"], function(t) {
		function e(t) {
			return isNaN(t) ? "-" : (t = (t + "").split("."), t[0][F](/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t[$] > 1 ? "." + t[1] : ""))
		}

		function i(t) {
			return t[fe]()[F](/-(.)/g, function(t, e) {
				return e.toUpperCase()
			})
		}

		function n(t) {
			var e = t[$];
			return typeof t === V ? [t, t, t, t] : 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t
		}

		function r(t) {
			return String(t)[F](/&/g, "&amp;")[F](/</g, "&lt;")[F](/>/g, "&gt;")[F](/"/g, "&quot;")[F](/'/g, "&#39;")
		}

		function a(t, e) {
			return "{" + t + (null == e ? "" : e) + "}"
		}

		function o(t, e) {
			u[G](e) || (e = [e]);
			var i = e[$];
			if (!i) return "";
			for (var n = e[0].$vars, r = 0; r < n[$]; r++) {
				var o = h[r];
				t = t[F](a(o), a(o, 0))
			}
			for (var s = 0; i > s; s++)
				for (var l = 0; l < n[$]; l++) t = t[F](a(h[l], s), e[s][n[l]]);
			return t
		}

		function s(t, e) {
			("week" === t || "month" === t || "quarter" === t || "half-year" === t || "year" === t) && (t = "MM-dd\nyyyy");
			var i = c.parseDate(e),
				n = i.getFullYear(),
				r = i.getMonth() + 1,
				a = i.getDate(),
				o = i.getHours(),
				s = i.getMinutes(),
				u = i.getSeconds();
			return t = t[F]("MM", l(r))[fe]()[F]("yyyy", n)[F]("yy", n % 100)[F]("dd", l(a))[F]("d", a)[F]("hh", l(o))[F]("h", o)[F]("mm", l(s))[F]("m", s)[F]("ss", l(u))[F]("s", u)
		}

		function l(t) {
			return 10 > t ? "0" + t : t
		}
		var u = t(me),
			c = t("./number"),
			h = ["a", "b", "c", "d", "e", "f", "g"];
		return {
			normalizeCssArray: n,
			addCommas: e,
			toCamelCase: i,
			encodeHTML: r,
			formatTpl: o,
			formatTime: s
		}
	}), e("zrender/core/vector", [], function() {
		var t = typeof Float32Array === u ? Array : Float32Array,
			e = {
				create: function(e, i) {
					var n = new t(2);
					return n[0] = e || 0, n[1] = i || 0, n
				},
				copy: function(t, e) {
					return t[0] = e[0], t[1] = e[1], t
				},
				clone: function(e) {
					var i = new t(2);
					return i[0] = e[0], i[1] = e[1], i
				},
				set: function(t, e, i) {
					return t[0] = e, t[1] = i, t
				},
				add: function(t, e, i) {
					return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
				},
				scaleAndAdd: function(t, e, i, n) {
					return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t
				},
				sub: function(t, e, i) {
					return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
				},
				len: function(t) {
					return Math.sqrt(this.lenSquare(t))
				},
				lenSquare: function(t) {
					return t[0] * t[0] + t[1] * t[1]
				},
				mul: function(t, e, i) {
					return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
				},
				div: function(t, e, i) {
					return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
				},
				dot: function(t, e) {
					return t[0] * e[0] + t[1] * e[1]
				},
				scale: function(t, e, i) {
					return t[0] = e[0] * i, t[1] = e[1] * i, t
				},
				normalize: function(t, i) {
					var n = e.len(i);
					return 0 === n ? (t[0] = 0, t[1] = 0) : (t[0] = i[0] / n, t[1] = i[1] / n), t
				},
				distance: function(t, e) {
					return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))
				},
				distanceSquare: function(t, e) {
					return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])
				},
				negate: function(t, e) {
					return t[0] = -e[0], t[1] = -e[1], t
				},
				lerp: function(t, e, i, n) {
					return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t
				},
				applyTransform: function(t, e, i) {
					var n = e[0],
						r = e[1];
					return t[0] = i[0] * n + i[2] * r + i[4], t[1] = i[1] * n + i[3] * r + i[5], t
				},
				min: function(t, e, i) {
					return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t
				},
				max: function(t, e, i) {
					return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t
				}
			};
		return e[$] = e.len, e.lengthSquare = e.lenSquare, e.dist = e.distance, e.distSquare = e.distanceSquare, e
	}), e("echarts/chart/pie/PieSeries", [ve, "../../data/List", me, "../../util/model", "../../data/helper/completeDimensions", "../helper/dataSelectableMixin", s], function(t) {
		var e = t("../../data/List"),
			i = t(me),
			n = t("../../util/model"),
			r = t("../../data/helper/completeDimensions"),
			a = t("../helper/dataSelectableMixin"),
			o = t(s).extendSeriesModel({
				type: "series.pie",
				init: function(t) {
					o.superApply(this, "init", arguments), this.legendDataProvider = function() {
						return this._dataBeforeProcessed
					}, this.updateSelectedMap(), this._defaultLabelLine(t)
				},
				mergeOption: function(t) {
					o.superCall(this, x, t), this.updateSelectedMap()
				},
				getInitialData: function(t) {
					var i = r(["value"], t.data),
						n = new e(i, this);
					return n.initData(t.data), n
				},
				getDataParams: function(t) {
					var e = this._data,
						i = o.superCall(this, "getDataParams", t),
						n = e.getSum("value");
					return i.percent = n ? +(e.get("value", t) / n * 100).toFixed(2) : 0, i.$vars.push("percent"), i
				},
				_defaultLabelLine: function(t) {
					n.defaultEmphasis(t.labelLine, ["show"]);
					var e = t.labelLine[d],
						i = t.labelLine[f];
					e.show = e.show && t.label[d].show, i.show = i.show && t.label[f].show
				},
				defaultOption: {
					zlevel: 0,
					z: 2,
					legendHoverLink: !0,
					hoverAnimation: !0,
					center: ["50%", "50%"],
					radius: [0, "75%"],
					clockwise: !0,
					startAngle: 90,
					minAngle: 0,
					selectedOffset: 10,
					avoidLabelOverlap: !0,
					label: {
						normal: {
							rotate: !1,
							show: !0,
							position: "outer"
						},
						emphasis: {}
					},
					labelLine: {
						normal: {
							show: !0,
							length: 15,
							length2: 15,
							smooth: !1,
							lineStyle: {
								width: 1,
								type: "solid"
							}
						}
					},
					itemStyle: {
						normal: {
							borderColor: "rgba(0,0,0,0)",
							borderWidth: 1
						},
						emphasis: {
							borderColor: "rgba(0,0,0,0)",
							borderWidth: 1
						}
					},
					animationEasing: "cubicOut",
					data: []
				}
			});
		return i.mixin(o, a), o
	}), e("zrender/core/matrix", [], function() {
		var t = typeof Float32Array === u ? Array : Float32Array,
			e = {
				create: function() {
					var i = new t(6);
					return e.identity(i), i
				},
				identity: function(t) {
					return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
				},
				copy: function(t, e) {
					return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
				},
				mul: function(t, e, i) {
					var n = e[0] * i[0] + e[2] * i[1],
						r = e[1] * i[0] + e[3] * i[1],
						a = e[0] * i[2] + e[2] * i[3],
						o = e[1] * i[2] + e[3] * i[3],
						s = e[0] * i[4] + e[2] * i[5] + e[4],
						l = e[1] * i[4] + e[3] * i[5] + e[5];
					return t[0] = n, t[1] = r, t[2] = a, t[3] = o, t[4] = s, t[5] = l, t
				},
				translate: function(t, e, i) {
					return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], t
				},
				rotate: function(t, e, i) {
					var n = e[0],
						r = e[2],
						a = e[4],
						o = e[1],
						s = e[3],
						l = e[5],
						u = Math.sin(i),
						c = Math.cos(i);
					return t[0] = n * c + o * u, t[1] = -n * u + o * c, t[2] = r * c + s * u, t[3] = -r * u + c * s, t[4] = c * a + u * l, t[5] = c * l - u * a, t
				},
				scale: function(t, e, i) {
					var n = i[0],
						r = i[1];
					return t[0] = e[0] * n, t[1] = e[1] * r, t[2] = e[2] * n, t[3] = e[3] * r, t[4] = e[4] * n, t[5] = e[5] * r, t
				},
				invert: function(t, e) {
					var i = e[0],
						n = e[2],
						r = e[4],
						a = e[1],
						o = e[3],
						s = e[5],
						l = i * o - a * n;
					return l ? (l = 1 / l, t[0] = o * l, t[1] = -a * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - o * r) * l, t[5] = (a * r - i * s) * l, t) : null
				}
			};
		return e
	}), e("echarts/chart/pie/PieView", [ve, "../../util/graphic", me, "../../view/Chart"], function(t) {
		function e(t, e, n, r) {
			var a = e[U](),
				o = this.dataIndex,
				s = a[g](o),
				l = e.get("selectedOffset");
			r[J]({
				type: "pieToggleSelect",
				from: t,
				name: s,
				seriesId: e.id
			}), a.each(function(t) {
				i(a.getItemGraphicEl(t), a.getItemLayout(t), e.isSelected(a[g](t)), l, n)
			})
		}

		function i(t, e, i, n, r) {
			var a = (e.startAngle + e.endAngle) / 2,
				o = Math.cos(a),
				s = Math.sin(a),
				l = i ? n : 0,
				u = [o * l, s * l];
			r ? t.animate().when(200, {
				position: u
			}).start("bounceOut") : t.attr(L, u)
		}

		function n(t, e) {
			function i() {
				o[se] = o.hoverIgnore, s[se] = s.hoverIgnore
			}

			function n() {
				o[se] = o.normalIgnore, s[se] = s.normalIgnore
			}
			a.Group.call(this);
			var r = new a.Sector({
					z2: 2
				}),
				o = new a.Polyline,
				s = new a.Text;
			this.add(r), this.add(o), this.add(s), this.updateData(t, e, !0), this.on(f, i).on(d, n).on(H, i).on(W, n)
		}

		function r(t, e, i, n, r) {
			var a = n[ce](O),
				o = "inside" === r || "inner" === r;
			return {
				fill: a[T]() || (o ? "#fff" : t[v](e, "color")),
				textFont: a[D](),
				text: s.retrieve(t.hostModel.getFormattedLabel(e, i), t[g](e))
			}
		}
		var a = t("../../util/graphic"),
			s = t(me),
			l = n[de];
		l.updateData = function(t, e, n) {
			function r() {
				l.stopAnimation(!0), l.animateTo({
					shape: {
						r: h.r + 10
					}
				}, 300, "elasticOut")
			}

			function o() {
				l.stopAnimation(!0), l.animateTo({
					shape: {
						r: h.r
					}
				}, 300, "elasticOut")
			}
			var l = this.childAt(0),
				u = t.hostModel,
				c = t[b](e),
				h = t.getItemLayout(e),
				p = s[te]({}, h);
			p.label = null, n ? (l.setShape(p), l.shape.endAngle = h.startAngle, a.updateProps(l, {
				shape: {
					endAngle: h.endAngle
				}
			}, u)) : a.updateProps(l, {
				shape: p
			}, u);
			var m = c[ce]("itemStyle"),
				g = t[v](e, "color");
			l.setStyle(s[K]({
				fill: g
			}, m[ce](d).getItemStyle())), l.hoverStyle = m[ce](f).getItemStyle(), i(this, t.getItemLayout(e), c.get("selected"), u.get("selectedOffset"), u.get("animation")), l.off(H).off(W).off(f).off(d), c.get("hoverAnimation") && l.on(H, r).on(W, o).on(f, r).on(d, o), this._updateLabel(t, e), a.setHoverStyle(this)
		}, l._updateLabel = function(t, e) {
			var i = this.childAt(1),
				n = this.childAt(2),
				s = t.hostModel,
				l = t[b](e),
				u = t.getItemLayout(e),
				c = u.label,
				h = t[v](e, "color");
			a.updateProps(i, {
				shape: {
					points: c.linePoints || [
						[c.x, c.y],
						[c.x, c.y],
						[c.x, c.y]
					]
				}
			}, s), a.updateProps(n, {
				style: {
					x: c.x,
					y: c.y
				}
			}, s), n.attr({
				style: {
					textVerticalAlign: c.verticalAlign,
					textAlign: c[I],
					textFont: c.font
				},
				rotation: c[o],
				origin: [c.x, c.y],
				z2: 10
			});
			var p = l[ce]("label.normal"),
				m = l[ce]("label.emphasis"),
				g = l[ce]("labelLine.normal"),
				y = l[ce]("labelLine.emphasis"),
				x = p.get(L) || m.get(L);
			n.setStyle(r(t, e, d, p, x)), n[se] = n.normalIgnore = !p.get("show"), n.hoverIgnore = !m.get("show"), i[se] = i.normalIgnore = !g.get("show"), i.hoverIgnore = !y.get("show"), i.setStyle({
				stroke: h
			}), i.setStyle(g[ce]("lineStyle").getLineStyle()), n.hoverStyle = r(t, e, f, m, x), i.hoverStyle = y[ce]("lineStyle").getLineStyle();
			var _ = g.get("smooth");
			_ && _ === !0 && (_ = .4), i.setShape({
				smooth: _
			})
		}, s[B](n, a.Group);
		var u = t("../../view/Chart")[te]({
			type: "pie",
			init: function() {
				var t = new a.Group;
				this._sectorGroup = t
			},
			render: function(t, i, r, a) {
				if (!a || a.from !== this.uid) {
					var o = t[U](),
						l = this._data,
						u = this.group,
						c = i.get("animation"),
						h = !l,
						d = s.curry(e, this.uid, t, c, r),
						f = t.get("selectedMode");
					if (o.diff(l).add(function(t) {
							var e = new n(o, t);
							h && e.eachChild(function(t) {
								t.stopAnimation(!0)
							}), f && e.on("click", d), o.setItemGraphicEl(t, e), u.add(e)
						})[ne](function(t, e) {
							var i = l.getItemGraphicEl(e);
							i.updateData(o, t), i.off("click"), f && i.on("click", d), u.add(i), o.setItemGraphicEl(t, i)
						})[ee](function(t) {
							var e = l.getItemGraphicEl(t);
							u[ee](e)
						}).execute(), c && h && o.count() > 0) {
						var p = o.getItemLayout(0),
							m = Math.max(r[ue](), r[le]()) / 2,
							v = s.bind(u.removeClipPath, u);
						u.setClipPath(this._createClipPath(p.cx, p.cy, m, p.startAngle, p.clockwise, v, t))
					}
					this._data = o
				}
			},
			_createClipPath: function(t, e, i, n, r, o, s) {
				var l = new a.Sector({
					shape: {
						cx: t,
						cy: e,
						r0: 0,
						r: i,
						startAngle: n,
						endAngle: n,
						clockwise: r
					}
				});
				return a.initProps(l, {
					shape: {
						endAngle: n + (r ? 1 : -1) * Math.PI * 2
					}
				}, s, o), l
			}
		});
		return u
	}), e("echarts/action/createDataSelectAction", [ve, "../echarts", me], function(t) {
		var e = t("../echarts"),
			i = t(me);
		return function(t, n) {
			i.each(n, function(i) {
				i[ne] = "updateView", e.registerAction(i, function(e, n) {
					var r = {};
					return n.eachComponent({
						mainType: "series",
						subType: t,
						query: e
					}, function(t) {
						t[i.method] && t[i.method](e.name);
						var n = t[U]();
						n.each(function(e) {
							var i = n[g](e);
							r[i] = t.isSelected(i) || !1
						})
					}), {
						name: e.name,
						selected: r
					}
				})
			})
		}
	}), e("echarts/processor/dataFilter", [], function() {
		return function(t, e) {
			var i = e.findComponents({
				mainType: "legend"
			});
			i && i[$] && e.eachSeriesByType(t, function(t) {
				var e = t[U]();
				e.filterSelf(function(t) {
					for (var n = e[g](t), r = 0; r < i[$]; r++)
						if (!i[r].isSelected(n)) return !1;
					return !0
				}, this)
			}, this)
		}
	}), e("echarts/visual/dataColor", [ve], function() {
		return function(t, e) {
			var i = e.get("color"),
				n = 0;
			e.eachRawSeriesByType(t, function(t) {
				var r = t.get("color", !0),
					a = t.getRawData();
				if (!e.isSeriesFiltered(t)) {
					var o = t[U]();
					o.each(function(t) {
						var e = o[b](t),
							s = o.getRawIndex(t),
							l = o[v](t, "color", !0);
						if (l) a.setItemVisual(s, "color", l);
						else {
							var u = r ? r[s % r[$]] : i[(s + n) % i[$]],
								c = e.get("itemStyle.normal.color") || u;
							a.setItemVisual(s, "color", c), o.setItemVisual(t, "color", c)
						}
					})
				}
				n += a.count()
			})
		}
	}), e("echarts/chart/line/LineView", [ve, me, "../helper/SymbolDraw", "../helper/Symbol", "./lineAnimationDiff", "../../util/graphic", "./poly", "../../view/Chart"], function(t) {
		function e(t, e) {
			if (t[$] === e[$]) {
				for (var i = 0; i < t[$]; i++) {
					var n = t[i],
						r = e[i];
					if (n[0] !== r[0] || n[1] !== r[1]) return
				}
				return !0
			}
		}

		function i(t) {
			return typeof t === V ? t : t ? .3 : 0
		}

		function n(t) {
			var e = t.getGlobalExtent();
			if (t.onBand) {
				var i = t.getBandWidth() / 2 - 1,
					n = e[1] > e[0] ? 1 : -1;
				e[0] += n * i, e[1] -= n * i
			}
			return e
		}

		function o(t) {
			return t >= 0 ? 1 : -1
		}

		function s(t, e) {
			var i = t.getBaseAxis(),
				n = t.getOtherAxis(i),
				r = i.onZero ? 0 : n.scale[A]()[0],
				a = n.dim,
				s = "x" === a || "radius" === a ? 1 : 0;
			return e.mapArray([a], function(n, l) {
				for (var u, c = e.stackedOn; c && o(c.get(a, l)) === o(n);) {
					u = c;
					break
				}
				var h = [];
				return h[s] = e.get(i.dim, l), h[1 - s] = u ? u.get(a, l, !0) : r, t.dataToPoint(h)
			}, !0)
		}

		function l(t, e) {
			return null != e.dataIndex ? e.dataIndex : null != e.name ? t.indexOfName(e.name) : void 0
		}

		function u(t, e, i) {
			var r = n(t[a]("x")),
				o = n(t[a]("y")),
				s = t.getBaseAxis().isHorizontal(),
				l = r[0],
				u = o[0],
				c = r[1] - l,
				h = o[1] - u;
			i.get("clipOverflow") || (s ? (u -= h, h *= 3) : (l -= c, c *= 3));
			var d = new v.Rect({
				shape: {
					x: l,
					y: u,
					width: c,
					height: h
				}
			});
			return e && (d.shape[s ? "width" : ae] = 0, v.initProps(d, {
				shape: {
					width: c,
					height: h
				}
			}, i)), d
		}

		function c(t, e, i) {
			var n = t.getAngleAxis(),
				r = t.getRadiusAxis(),
				a = r[A](),
				o = n[A](),
				s = Math.PI / 180,
				l = new v.Sector({
					shape: {
						cx: t.cx,
						cy: t.cy,
						r0: a[0],
						r: a[1],
						startAngle: -o[0] * s,
						endAngle: -o[1] * s,
						clockwise: n.inverse
					}
				});
			return e && (l.shape.endAngle = -o[0] * s, v.initProps(l, {
				shape: {
					endAngle: -o[1] * s
				}
			}, i)), l
		}

		function h(t, e, i) {
			return "polar" === t.type ? c(t, e, i) : u(t, e, i)
		}
		var d = t(me),
			f = t("../helper/SymbolDraw"),
			p = t("../helper/Symbol"),
			m = t("./lineAnimationDiff"),
			v = t("../../util/graphic"),
			g = t("./poly"),
			y = t("../../view/Chart");
		return y[te]({
			type: "line",
			init: function() {
				var t = new v.Group,
					e = new f;
				this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t
			},
			render: function(t, n, r) {
				var a = t[R],
					o = this.group,
					l = t[U](),
					u = t[ce]("lineStyle.normal"),
					c = t[ce]("areaStyle.normal"),
					f = l.mapArray(l.getItemLayout, !0),
					p = "polar" === a.type,
					m = this._coordSys,
					v = this._symbolDraw,
					g = this._polyline,
					y = this._polygon,
					x = this._lineGroup,
					_ = t.get("animation"),
					b = !c.isEmpty(),
					w = s(a, l),
					M = t.get("showSymbol"),
					S = M && !p && !t.get("showAllSymbol") && this._getSymbolIgnoreFunc(l, a),
					A = this._data;
				A && A.eachItemGraphicEl(function(t, e) {
					t.__temp && (o[ee](t), A.setItemGraphicEl(e, null))
				}), M || v[ee](), o.add(x), g && m.type === a.type ? (b && !y ? y = this._newPolygon(f, w, a, _) : y && !b && (x[ee](y), y = this._polygon = null), x.setClipPath(h(a, !1, t)), M && v.updateData(l, S), l.eachItemGraphicEl(function(t) {
					t.stopAnimation(!0)
				}), e(this._stackedOnPoints, w) && e(this._points, f) || (_ ? this._updateAnimation(l, w, a, r) : (g.setShape({
					points: f
				}), y && y.setShape({
					points: f,
					stackedOnPoints: w
				})))) : (M && v.updateData(l, S), g = this._newPolyline(f, a, _), b && (y = this._newPolygon(f, w, a, _)), x.setClipPath(h(a, !0, t))), g.setStyle(d[K](u.getLineStyle(), {
					stroke: l.getVisual("color"),
					lineJoin: "bevel"
				}));
				var L = t.get("smooth");
				if (L = i(t.get("smooth")), g.setShape({
						smooth: L,
						smoothMonotone: t.get("smoothMonotone")
					}), y) {
					var k = l.stackedOn,
						z = 0;
					if (y.style[C] = .7, y.setStyle(d[K](c.getAreaStyle(), {
							fill: l.getVisual("color"),
							lineJoin: "bevel"
						})), k) {
						var P = k.hostModel;
						z = i(P.get("smooth"))
					}
					y.setShape({
						smooth: L,
						stackedOnSmooth: z,
						smoothMonotone: t.get("smoothMonotone")
					})
				}
				this._data = l, this._coordSys = a, this._stackedOnPoints = w, this._points = f
			},
			highlight: function(t, e, i, n) {
				var r = t[U](),
					a = l(r, n);
				if (null != a && a >= 0) {
					var o = r.getItemGraphicEl(a);
					if (!o) {
						var s = r.getItemLayout(a);
						o = new p(r, a, i), o[L] = s, o.setZ(t.get("zlevel"), t.get("z")), o[se] = isNaN(s[0]) || isNaN(s[1]), o.__temp = !0, r.setItemGraphicEl(a, o), o.stopSymbolAnimation(!0), this.group.add(o)
					}
					o.highlight()
				} else y[de].highlight.call(this, t, e, i, n)
			},
			downplay: function(t, e, i, n) {
				var r = t[U](),
					a = l(r, n);
				if (null != a && a >= 0) {
					var o = r.getItemGraphicEl(a);
					o && (o.__temp ? (r.setItemGraphicEl(a, null), this.group[ee](o)) : o.downplay())
				} else y[de].downplay.call(this, t, e, i, n)
			},
			_newPolyline: function(t) {
				var e = this._polyline;
				return e && this._lineGroup[ee](e), e = new g.Polyline({
					shape: {
						points: t
					},
					silent: !0,
					z2: 10
				}), this._lineGroup.add(e), this._polyline = e, e
			},
			_newPolygon: function(t, e) {
				var i = this._polygon;
				return i && this._lineGroup[ee](i), i = new g.Polygon({
					shape: {
						points: t,
						stackedOnPoints: e
					},
					silent: !0
				}), this._lineGroup.add(i), this._polygon = i, i
			},
			_getSymbolIgnoreFunc: function(t, e) {
				var i = e.getAxesByScale(r)[0];
				return i && i.isLabelIgnored ? d.bind(i.isLabelIgnored, i) : void 0
			},
			_updateAnimation: function(t, e, i) {
				var n = this._polyline,
					r = this._polygon,
					a = t.hostModel,
					o = m(this._data, t, this._stackedOnPoints, e, this._coordSys, i);
				n.shape.points = o.current, v.updateProps(n, {
					shape: {
						points: o.next
					}
				}, a), r && (r.setShape({
					points: o.current,
					stackedOnPoints: o.stackedOnCurrent
				}), v.updateProps(r, {
					shape: {
						points: o.next,
						stackedOnPoints: o.stackedOnNext
					}
				}, a));
				for (var s = [], l = o.status, u = 0; u < l[$]; u++) {
					var c = l[u].cmd;
					if ("=" === c) {
						var h = t.getItemGraphicEl(l[u].idx1);
						h && s.push({
							el: h,
							ptIdx: u
						})
					}
				}
				n.animators && n.animators[$] && n.animators[0].during(function() {
					for (var t = 0; t < s[$]; t++) {
						var e = s[t].el;
						e.attr(L, n.shape.points[s[t].ptIdx])
					}
				})
			},
			remove: function() {
				var t = this.group,
					e = this._data;
				this._lineGroup[E](), this._symbolDraw[ee](!0), e && e.eachItemGraphicEl(function(i, n) {
					i.__temp && (t[ee](i), e.setItemGraphicEl(n, null))
				}), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null
			}
		})
	}), e("echarts/chart/pie/pieLayout", [ve, n, "./labelLayout", me], function(t) {
		var e = t(n),
			i = e.parsePercent,
			r = t("./labelLayout"),
			a = t(me),
			o = 2 * Math.PI,
			s = Math.PI / 180;
		return function(t, n, l) {
			n.eachSeriesByType(t, function(t) {
				var n = t.get(k),
					u = t.get("radius");
				a[G](u) || (u = [0, u]), a[G](n) || (n = [n, n]);
				var c = l[ue](),
					h = l[le](),
					d = Math.min(c, h),
					f = i(n[0], c),
					p = i(n[1], h),
					m = i(u[0], d / 2),
					v = i(u[1], d / 2),
					g = t[U](),
					y = -t.get("startAngle") * s,
					x = t.get("minAngle") * s,
					_ = g.getSum("value"),
					b = Math.PI / (_ || g.count()) * 2,
					w = t.get("clockwise"),
					M = t.get("roseType"),
					S = g.getDataExtent("value");
				S[0] = 0;
				var A = o,
					C = 0,
					L = y,
					z = w ? 1 : -1;
				if (g.each("value", function(t, i) {
						var n;
						n = "area" !== M ? 0 === _ ? b : t * b : o / (g.count() || 1), x > n ? (n = x, A -= x) : C += t;
						var r = L + z * n;
						g.setItemLayout(i, {
							angle: n,
							startAngle: L,
							endAngle: r,
							clockwise: w,
							cx: f,
							cy: p,
							r0: m,
							r: M ? e.linearMap(t, S, [m, v]) : v
						}), L = r
					}, !0), o > A)
					if (.001 >= A) {
						var P = o / g.count();
						g.each(function(t) {
							var e = g.getItemLayout(t);
							e.startAngle = y + z * t * P, e.endAngle = y + z * (t + 1) * P
						})
					} else b = A / C, L = y, g.each("value", function(t, e) {
						var i = g.getItemLayout(e),
							n = i.angle === x ? x : t * b;
						i.startAngle = L, i.endAngle = L + z * n, L += n
					});
				r(t, v, c, h)
			})
		}
	}), e("echarts/component/legend/LegendModel", [ve, me, "../../model/Model", s], function(t) {
		var e = t(me),
			i = t("../../model/Model"),
			n = t(s).extendComponentModel({
				type: "legend",
				dependencies: [j],
				layoutMode: {
					type: "box",
					ignoreSize: !0
				},
				init: function(t, e, i) {
					this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}, this._updateData(i);
					var n = this._data,
						r = this[_].selected;
					if (n[0] && "single" === this.get("selectedMode")) {
						var a = !1;
						for (var o in r) r[o] && (this.select(o), a = !0);
						!a && this.select(n[0].get("name"))
					}
				},
				mergeOption: function(t) {
					n.superCall(this, x, t), this._updateData(this[m])
				},
				_updateData: function(t) {
					var n = e.map(this.get("data") || [], function(t) {
						return typeof t === he && (t = {
							name: t
						}), new i(t, this, this[m])
					}, this);
					this._data = n;
					var r = e.map(t.getSeries(), function(t) {
						return t.name
					});
					t[Y](function(t) {
						if (t.legendDataProvider) {
							var e = t.legendDataProvider();
							r = r.concat(e.mapArray(e[g]))
						}
					}), this._availableNames = r
				},
				getData: function() {
					return this._data
				},
				select: function(t) {
					var i = this[_].selected,
						n = this.get("selectedMode");
					if ("single" === n) {
						var r = this._data;
						e.each(r, function(t) {
							i[t.get("name")] = !1
						})
					}
					i[t] = !0
				},
				unSelect: function(t) {
					"single" !== this.get("selectedMode") && (this[_].selected[t] = !1)
				},
				toggleSelected: function(t) {
					var e = this[_].selected;
					t in e || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t)
				},
				isSelected: function(t) {
					var i = this[_].selected;
					return !(t in i && !i[t]) && e[N](this._availableNames, t) >= 0
				},
				defaultOption: {
					zlevel: 0,
					z: 4,
					show: !0,
					orient: "horizontal",
					left: "center",
					top: "top",
					align: "auto",
					backgroundColor: "rgba(0,0,0,0)",
					borderColor: "#ccc",
					borderWidth: 0,
					padding: 5,
					itemGap: 10,
					itemWidth: 25,
					itemHeight: 14,
					textStyle: {
						color: "#333"
					},
					selectedMode: !0
				}
			});
		return n
	}), e("echarts/component/legend/legendAction", [ve, s, me], function(t) {
		function e(t, e, i) {
			var r, a = {},
				o = "toggleSelected" === t;
			return i.eachComponent("legend", function(i) {
				o && null != r ? i[r ? "select" : "unSelect"](e.name) : (i[t](e.name), r = i.isSelected(e.name));
				var s = i[U]();
				n.each(s, function(t) {
					var e = t.get("name");
					if ("\n" !== e && "" !== e) {
						var n = i.isSelected(e);
						a[e] = e in a ? a[e] && n : n
					}
				})
			}), {
				name: e.name,
				selected: a
			}
		}
		var i = t(s),
			n = t(me);
		i.registerAction("legendToggleSelect", "legendselectchanged", n.curry(e, "toggleSelected")), i.registerAction("legendSelect", "legendselected", n.curry(e, "select")), i.registerAction("legendUnSelect", "legendunselected", n.curry(e, "unSelect"))
	}), e("echarts/component/legend/LegendView", [ve, me, "../../util/symbol", "../../util/graphic", "../helper/listComponent", s], function(t) {
		function e(t, e) {
			e[J]({
				type: "legendToggleSelect",
				name: t
			})
		}

		function i(t, e, i) {
			t.get("legendHoverLink") && i[J]({
				type: "highlight",
				seriesName: t.name,
				name: e
			})
		}

		function n(t, e, i) {
			t.get("legendHoverLink") && i[J]({
				type: "downplay",
				seriesName: t.name,
				name: e
			})
		}
		var r = t(me),
			a = t("../../util/symbol"),
			o = t("../../util/graphic"),
			l = t("../helper/listComponent"),
			u = r.curry,
			c = "#ccc";
		return t(s).extendComponentView({
			type: "legend",
			init: function() {
				this._symbolTypeStore = {}
			},
			render: function(t, a, s) {
				var c = this.group;
				if (c[E](), t.get("show")) {
					var h = t.get("selectedMode"),
						d = t.get("align");
					"auto" === d && (d = "right" === t.get("left") && "vertical" === t.get("orient") ? "right" : "left");
					var f = {},
						p = {};
					r.each(t[U](), function(r) {
						var l = r.get("name");
						("" === l || "\n" === l) && c.add(new o.Group({
							newline: !0
						}));
						var m = a.getSeriesByName(l)[0];
						if (f[l] = r, m && !p[l]) {
							var v = m[U](),
								g = v.getVisual("color");
							typeof g === Z && (g = g(m.getDataParams(0)));
							var y = v.getVisual("legendSymbol") || "roundRect",
								x = v.getVisual("symbol"),
								_ = this._createItem(l, r, t, y, x, d, g, h);
							_.on("click", u(e, l, s)).on(H, u(i, m, "", s)).on(W, u(n, m, "", s)), p[l] = !0
						}
					}, this), a.eachRawSeries(function(r) {
						if (r.legendDataProvider) {
							var a = r.legendDataProvider();
							a.each(function(o) {
								var l = a[g](o);
								if (f[l] && !p[l]) {
									var c = a[v](o, "color"),
										m = "roundRect",
										y = this._createItem(l, f[l], t, m, null, d, c, h);
									y.on("click", u(e, l, s)).on(H, u(i, r, l, s)).on(W, u(n, r, l, s)), p[l] = !0
								}
							}, !1, this)
						}
					}, this), l.layout(c, t, s), l.addBackground(c, t)
				}
			},
			_createItem: function(t, e, i, n, r, s, l, u) {
				var h = i.get("itemWidth"),
					d = i.get("itemHeight"),
					f = i.isSelected(t),
					p = new o.Group,
					m = e[ce](O),
					v = e.get("icon");
				if (n = v || n, p.add(a.createSymbol(n, 0, 0, h, d, f ? l : c)), !v && r && (r !== n || "none" == r)) {
					var g = .8 * d;
					"none" === r && (r = "circle"), p.add(a.createSymbol(r, (h - g) / 2, (d - g) / 2, g, g, f ? l : c))
				}
				var y = "left" === s ? h + 5 : -5,
					x = s,
					_ = i.get("formatter");
				typeof _ === he && _ ? t = _[F]("{name}", t) : typeof _ === Z && (t = _(t));
				var b = new o.Text({
					style: {
						text: t,
						x: y,
						y: d / 2,
						fill: f ? m[T]() : c,
						textFont: m[D](),
						textAlign: x,
						textVerticalAlign: "middle"
					}
				});
				return p.add(b), p.add(new o.Rect({
					shape: p[P](),
					invisible: !0
				})), p.eachChild(function(t) {
					t.silent = !u
				}), this.group.add(p), o.setHoverStyle(p), p
			}
		})
	}), e("echarts/component/legend/legendFilter", [], function() {
		return function(t) {
			var e = t.findComponents({
				mainType: "legend"
			});
			e && e[$] && t.filterSeries(function(t) {
				for (var i = 0; i < e[$]; i++)
					if (!e[i].isSelected(t.name)) return !1;
				return !0
			})
		}
	}), e("echarts/coord/cartesian/Grid", [ve, "exports", "../../util/layout", "../../coord/axisHelper", me, "./Cartesian2D", "./Axis2D", "./GridModel", "../../CoordinateSystem"], function(t) {
		function e(t, e, i) {
			return i[y]("grid", t.get("gridIndex")) === e
		}

		function n(t) {
			var e, i = t.model,
				n = i.getFormattedLabels(),
				r = 1,
				a = n[$];
			a > 40 && (r = Math.ceil(a / 40));
			for (var o = 0; a > o; o += r)
				if (!t.isLabelIgnored(o)) {
					var s = i.getTextRect(n[o]);
					e ? e.union(s) : e = s
				}
			return e
		}

		function o(t, e, i) {
			this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, i), this._model = t
		}

		function s(t, e) {
			var i = t[A](),
				n = i[0] + i[1];
			t.toGlobalCoord = "x" === t.dim ? function(t) {
				return t + e
			} : function(t) {
				return n - t + e
			}, t.toLocalCoord = "x" === t.dim ? function(t) {
				return t - e
			} : function(t) {
				return n - t + e
			}
		}
		var l = t("../../util/layout"),
			u = t("../../coord/axisHelper"),
			c = t(me),
			h = t("./Cartesian2D"),
			d = t("./Axis2D"),
			f = c.each,
			p = u.ifAxisCrossZero,
			m = u.niceScaleExtent;
		t("./GridModel");
		var v = o[de];
		return v.type = "grid", v.getRect = function() {
			return this._rect
		}, v[ne] = function(t, e) {
			function n(t) {
				var e = r[t];
				for (var n in e) {
					var a = e[n];
					if (a && (a.type === i || !p(a))) return !0
				}
				return !1
			}
			var r = this._axesMap;
			this._updateScale(t, this._model), f(r.x, function(t) {
				m(t, t.model)
			}), f(r.y, function(t) {
				m(t, t.model)
			}), f(r.x, function(t) {
				n("y") && (t.onZero = !1)
			}), f(r.y, function(t) {
				n("x") && (t.onZero = !1)
			}), this.resize(this._model, e)
		}, v.resize = function(t, e) {
			function i() {
				f(a, function(t) {
					var e = t.isHorizontal(),
						i = e ? [0, r.width] : [0, r[ae]],
						n = t.inverse ? 1 : 0;
					t.setExtent(i[n], i[1 - n]), s(t, e ? r.x : r.y)
				})
			}
			var r = l.getLayoutRect(t.getBoxLayoutParams(), {
				width: e[ue](),
				height: e[le]()
			});
			this._rect = r;
			var a = this._axesList;
			i(), t.get("containLabel") && (f(a, function(t) {
				if (!t.model.get("axisLabel.inside")) {
					var e = n(t);
					if (e) {
						var i = t.isHorizontal() ? ae : "width",
							a = t.model.get("axisLabel.margin");
						r[i] -= e[i] + a, "top" === t[L] ? r.y += e[ae] + a : "left" === t[L] && (r.x += e.width + a)
					}
				}
			}), i())
		}, v[a] = function(t, e) {
			var i = this._axesMap[t];
			if (null != i) {
				if (null == e)
					for (var n in i) return i[n];
				return i[e]
			}
		}, v.getCartesian = function(t, e) {
			var i = "x" + t + "y" + e;
			return this._coordsMap[i]
		}, v._initCartesian = function(t, n) {
			function r(r) {
				return function(l, c) {
					if (e(l, t, n)) {
						var h = l.get(L);
						"x" === r ? ("top" !== h && h !== oe && (h = oe), a[h] && (h = "top" === h ? oe : "top")) : ("left" !== h && "right" !== h && (h = "left"), a[h] && (h = "left" === h ? "right" : "left")), a[h] = !0;
						var f = new d(r, u.createScaleByModel(l), [0, 0], l.get("type"), h),
							p = f.type === i;
						f.onBand = p && l.get("boundaryGap"), f.inverse = l.get("inverse"), f.onZero = l.get("axisLine.onZero"), l.axis = f, f.model = l, f.index = c, this._axesList.push(f), o[r][c] = f, s[r]++
					}
				}
			}
			var a = {
					left: !1,
					right: !1,
					top: !1,
					bottom: !1
				},
				o = {
					x: {},
					y: {}
				},
				s = {
					x: 0,
					y: 0
				};
			return n.eachComponent("xAxis", r("x"), this), n.eachComponent("yAxis", r("y"), this), s.x && s.y ? (this._axesMap = o, void f(o.x, function(t, e) {
				f(o.y, function(i, n) {
					var r = "x" + e + "y" + n,
						a = new h(r);
					a.grid = this, this._coordsMap[r] = a, this._coordsList.push(a), a.addAxis(t), a.addAxis(i)
				}, this)
			}, this)) : (this._axesMap = {}, void(this._axesList = []))
		}, v._updateScale = function(t, i) {
			function n(t, e, i) {
				f(i.coordDimToDataDim(e.dim), function(i) {
					e.scale.unionExtent(t.getDataExtent(i, e.scale.type !== r))
				})
			}
			c.each(this._axesList, function(t) {
				t.scale.setExtent(1 / 0, -1 / 0)
			}), t[Y](function(r) {
				if ("cartesian2d" === r.get(R)) {
					var o = r.get("xAxisIndex"),
						s = r.get("yAxisIndex"),
						l = t[y]("xAxis", o),
						u = t[y]("yAxis", s);
					if (!e(l, i, t) || !e(u, i, t)) return;
					var c = this.getCartesian(o, s),
						h = r[U](),
						d = c[a]("x"),
						f = c[a]("y");
					"list" === h.type && (n(h, d, r), n(h, f, r))
				}
			}, this)
		}, o[re] = function(t, e) {
			var i = [];
			return t.eachComponent("grid", function(n, r) {
				var a = new o(n, t, e);
				a.name = "grid_" + r, a.resize(n, e), n[R] = a, i.push(a)
			}), t[Y](function(e) {
				if ("cartesian2d" === e.get(R)) {
					var n = e.get("xAxisIndex"),
						r = t[y]("xAxis", n),
						a = i[r.get("gridIndex")];
					e[R] = a.getCartesian(n, e.get("yAxisIndex"))
				}
			}), i
		}, o[w] = h[de][w], t("../../CoordinateSystem").register("cartesian2d", o), o
	}), e("echarts/component/axis", [ve, "../coord/cartesian/AxisModel", "./axis/AxisView"], function(t) {
		t("../coord/cartesian/AxisModel"), t("./axis/AxisView")
	}), e("echarts/component/marker/MarkPointModel", [ve, "../../util/model", s], function(t) {
		var e = t("../../util/model"),
			i = t(s).extendComponentModel({
				type: "markPoint",
				dependencies: [j, "grid", "polar"],
				init: function(t, e, i, n) {
					this.mergeDefaultAndTheme(t, i), this[x](t, i, n.createdBySelf, !0)
				},
				mergeOption: function(t, n, r, a) {
					r || n[Y](function(t) {
						var r = t.get("markPoint"),
							o = t.markPointModel;
						if (!r || !r.data) return void(t.markPointModel = null);
						if (o) o[x](r, n, !0);
						else {
							a && e.defaultEmphasis(r.label, [L, "show", O, "distance", "formatter"]);
							var s = {
								seriesIndex: t[q],
								name: t.name,
								createdBySelf: !0
							};
							o = new i(r, this, n, s)
						}
						t.markPointModel = o
					}, this)
				},
				defaultOption: {
					zlevel: 0,
					z: 5,
					symbol: "pin",
					symbolSize: 50,
					tooltip: {
						trigger: "item"
					},
					label: {
						normal: {
							show: !0,
							position: "inside"
						},
						emphasis: {
							show: !0
						}
					},
					itemStyle: {
						normal: {
							borderWidth: 2
						},
						emphasis: {}
					}
				}
			});
		return i
	}), e("echarts/component/marker/MarkPointView", [ve, "../../chart/helper/SymbolDraw", me, "../../util/format", "../../util/model", n, "../../data/List", "./markerHelper", s], function(t) {
		function e(t, e, i) {
			var n = e[R];
			t.each(function(r) {
				var a, o = t[b](r),
					s = o[h]("x"),
					l = o[h]("y");
				if (null != s && null != l) a = [u.parsePercent(s, i[ue]()), u.parsePercent(l, i[le]())];
				else if (e.getMarkerPosition) a = e.getMarkerPosition(t.getValues(t[w], r));
				else if (n) {
					var c = t.get(n[w][0], r),
						d = t.get(n[w][1], r);
					a = n.dataToPoint([c, d])
				}
				t.setItemLayout(r, a)
			})
		}

		function i(t, e, i) {
			var n;
			n = t ? a.map(t && t[w], function(t) {
				var i = e[U]().getDimensionInfo(e.coordDimToDataDim(t)[0]) || {};
				return i.name = t, i
			}) : [{
				name: "value",
				type: "float"
			}];
			var r = new f(n, i),
				o = a.map(i.get("data"), a.curry(p.dataTransform, e));
			return t && (o = a[pe](o, a.curry(p.dataFilter, t))), r.initData(o, null, t ? p.dimValueGetter : function(t) {
				return t.value
			}), r
		}
		var r = t("../../chart/helper/SymbolDraw"),
			a = t(me),
			o = t("../../util/format"),
			l = t("../../util/model"),
			u = t(n),
			c = o.addCommas,
			d = o.encodeHTML,
			f = t("../../data/List"),
			p = t("./markerHelper"),
			m = {
				getRawDataArray: function() {
					return this[_].data
				},
				formatTooltip: function(t) {
					var e = this[U](),
						i = this.getRawValue(t),
						n = a[G](i) ? a.map(i, c).join(", ") : c(i),
						r = e[g](t);
					return this.name + "<br />" + ((r ? d(r) + " : " : "") + n)
				},
				getData: function() {
					return this._data
				},
				setData: function(t) {
					this._data = t
				}
			};
		a[K](m, l.dataFormatMixin), t(s).extendComponentView({
			type: "markPoint",
			init: function() {
				this._symbolDrawMap = {}
			},
			render: function(t, e, i) {
				var n = this._symbolDrawMap;
				for (var r in n) n[r].__keep = !1;
				e[Y](function(t) {
					var e = t.markPointModel;
					e && this._renderSeriesMP(t, e, i)
				}, this);
				for (var r in n) n[r].__keep || (n[r][ee](), this.group[ee](n[r].group))
			},
			updateLayout: function(t, i, n) {
				i[Y](function(t) {
					var i = t.markPointModel;
					i && (e(i[U](), t, n), this._symbolDrawMap[t.name].updateLayout(i))
				}, this)
			},
			_renderSeriesMP: function(t, n, o) {
				var s = t[R],
					l = t.name,
					u = t[U](),
					c = this._symbolDrawMap,
					d = c[l];
				d || (d = c[l] = new r);
				var f = i(s, t, n);
				a.mixin(n, m), n.setData(f), e(n[U](), t, o), f.each(function(t) {
					var e = f[b](t),
						i = e[h]("symbolSize");
					typeof i === Z && (i = i(n.getRawValue(t), n.getDataParams(t))), f.setItemVisual(t, {
						symbolSize: i,
						color: e.get("itemStyle.normal.color") || u.getVisual("color"),
						symbol: e[h]("symbol")
					})
				}), d.updateData(f), this.group.add(d.group), f.eachItemGraphicEl(function(t) {
					t.traverse(function(t) {
						t.dataModel = n
					})
				}), d.__keep = !0
			}
		})
	}), e("echarts/util/layout", [ve, me, "zrender/core/BoundingRect", "./number", "./format"], function(t) {
		function e(t, e, i, n, r) {
			var a = 0,
				o = 0;
			null == n && (n = 1 / 0), null == r && (r = 1 / 0);
			var s = 0;
			e.eachChild(function(l, u) {
				var c, h, d = l[L],
					f = l[P](),
					p = e.childAt(u + 1),
					m = p && p[P]();
				if ("horizontal" === t) {
					var v = f.width + (m ? -m.x + f.x : 0);
					c = a + v, c > n || l.newline ? (a = 0, c = v, o += s + i, s = f[ae]) : s = Math.max(s, f[ae])
				} else {
					var g = f[ae] + (m ? -m.y + f.y : 0);
					h = o + g, h > r || l.newline ? (a += s + i, o = 0, h = g, s = f.width) : s = Math.max(s, f.width)
				}
				l.newline || (d[0] = a, d[1] = o, "horizontal" === t ? a = c + i : o = h + i)
			})
		}
		var i = t(me),
			n = t("zrender/core/BoundingRect"),
			r = t("./number"),
			a = t("./format"),
			o = r.parsePercent,
			s = i.each,
			l = {},
			u = ["left", "right", "top", oe, "width", ae];
		return l.box = e, l.vbox = i.curry(e, "vertical"), l.hbox = i.curry(e, "horizontal"), l.getAvailableSize = function(t, e, i) {
			var n = e.width,
				r = e[ae],
				s = o(t.x, n),
				l = o(t.y, r),
				u = o(t.x2, n),
				c = o(t.y2, r);
			return (isNaN(s) || isNaN(parseFloat(t.x))) && (s = 0), (isNaN(u) || isNaN(parseFloat(t.x2))) && (u = n), (isNaN(l) || isNaN(parseFloat(t.y))) && (l = 0), (isNaN(c) || isNaN(parseFloat(t.y2))) && (c = r), i = a.normalizeCssArray(i || 0), {
				width: Math.max(u - s - i[1] - i[3], 0),
				height: Math.max(c - l - i[0] - i[2], 0)
			}
		}, l.getLayoutRect = function(t, e, i) {
			i = a.normalizeCssArray(i || 0);
			var r = e.width,
				s = e[ae],
				l = o(t.left, r),
				u = o(t.top, s),
				c = o(t.right, r),
				h = o(t[oe], s),
				d = o(t.width, r),
				f = o(t[ae], s),
				p = i[2] + i[0],
				m = i[1] + i[3],
				v = t.aspect;
			switch (isNaN(d) && (d = r - c - m - l), isNaN(f) && (f = s - h - p - u), isNaN(d) && isNaN(f) && (v > r / s ? d = .8 * r : f = .8 * s), null != v && (isNaN(d) && (d = v * f), isNaN(f) && (f = d / v)), isNaN(l) && (l = r - c - d - m), isNaN(u) && (u = s - h - f - p), t.left || t.right) {
				case k:
					l = r / 2 - d / 2 - i[3];
					break;
				case "right":
					l = r - d - m
			}
			switch (t.top || t[oe]) {
				case z:
				case k:
					u = s / 2 - f / 2 - i[0];
					break;
				case oe:
					u = s - f - p
			}
			l = l || 0, u = u || 0, isNaN(d) && (d = r - l - (c || 0)), isNaN(f) && (f = s - u - (h || 0));
			var g = new n(l + i[3], u + i[0], d, f);
			return g.margin = i, g
		}, l.positionGroup = function(t, e, n, r) {
			var a = t[P]();
			e = i[te](i.clone(e), {
				width: a.width,
				height: a[ae]
			}), e = l.getLayoutRect(e, n, r), t[L] = [e.x - a.x, e.y - a.y]
		}, l.mergeLayoutParam = function(t, e, n) {
			function r(i) {
				var r = {},
					l = 0,
					u = {},
					c = 0,
					h = n.ignoreSize ? 1 : 2;
				if (s(i, function(e) {
						u[e] = t[e]
					}), s(i, function(t) {
						a(e, t) && (r[t] = u[t] = e[t]), o(r, t) && l++, o(u, t) && c++
					}), c !== h && l) {
					if (l >= h) return r;
					for (var d = 0; d < i[$]; d++) {
						var f = i[d];
						if (!a(r, f) && a(t, f)) {
							r[f] = t[f];
							break
						}
					}
					return r
				}
				return u
			}

			function a(t, e) {
				return t.hasOwnProperty(e)
			}

			function o(t, e) {
				return null != t[e] && "auto" !== t[e]
			}

			function l(t, e, i) {
				s(t, function(t) {
					e[t] = i[t]
				})
			}!i[ie](n) && (n = {});
			var u = ["width", "left", "right"],
				c = [ae, "top", oe],
				h = r(u),
				d = r(c);
			l(u, t, h), l(c, t, d)
		}, l.getLayoutParams = function(t) {
			return l.copyLayoutParams({}, t)
		}, l.copyLayoutParams = function(t, e) {
			return e && t && s(u, function(i) {
				e.hasOwnProperty(i) && (t[i] = e[i])
			}), t
		}, l
	}), e("echarts/component/marker/MarkLineModel", [ve, "../../util/model", s], function(t) {
		var e = t("../../util/model"),
			i = t(s).extendComponentModel({
				type: "markLine",
				dependencies: [j, "grid", "polar"],
				init: function(t, e, i, n) {
					this.mergeDefaultAndTheme(t, i), this[x](t, i, n.createdBySelf, !0)
				},
				mergeOption: function(t, n, r, a) {
					r || n[Y](function(t) {
						var r = t.get("markLine"),
							o = t.markLineModel;
						if (!r || !r.data) return void(t.markLineModel = null);
						if (o) o[x](r, n, !0);
						else {
							a && e.defaultEmphasis(r.label, [L, "show", O, "distance", "formatter"]);
							var s = {
								seriesIndex: t[q],
								name: t.name,
								createdBySelf: !0
							};
							o = new i(r, this, n, s)
						}
						t.markLineModel = o
					}, this)
				},
				defaultOption: {
					zlevel: 0,
					z: 5,
					symbol: ["circle", "arrow"],
					symbolSize: [8, 16],
					precision: 2,
					tooltip: {
						trigger: "item"
					},
					label: {
						normal: {
							show: !0,
							position: "end"
						},
						emphasis: {
							show: !0
						}
					},
					lineStyle: {
						normal: {
							type: "dashed"
						},
						emphasis: {
							width: 3
						}
					},
					animationEasing: "linear"
				}
			});
		return i
	}), e("echarts/component/marker/MarkLineView", [ve, me, "../../data/List", "../../util/format", "../../util/model", n, "./markerHelper", "../../chart/helper/LineDraw", s], function(t) {
		function e(t, e) {
			return m.dataFilter(t, e[0]) && m.dataFilter(t, e[1])
		}

		function i(t, e, i, n, o, s, l) {
			var u, c = s[R],
				h = t[b](e),
				f = h.get("x"),
				p = h.get("y");
			if (null != f && null != p) u = [d.parsePercent(f, l[ue]()), d.parsePercent(p, l[le]())];
			else {
				if (s.getMarkerPosition) u = s.getMarkerPosition(t.getValues(t[w], e));
				else {
					var m = c[w],
						v = t.get(m[0], e),
						g = t.get(m[1], e);
					u = c.dataToPoint([v, g])
				}
				if (n && "cartesian2d" === c.type) {
					var y = null != o ? c[a](1 === o ? "x" : "y") : c.getAxesByScale(r)[0];
					y && y.onBand && (u["x" === y.dim ? 0 : 1] = y.toGlobalCoord(y[A]()[i ? 0 : 1]))
				}
			}
			t.setItemLayout(e, u)
		}

		function o(t, i, n) {
			var r;
			r = t ? l.map(t && t[w], function(t) {
				var e = i[U]().getDimensionInfo(i.coordDimToDataDim(t)[0]) || {};
				return e.name = t, e
			}) : [{
				name: "value",
				type: "float"
			}];
			var a = new u(r, n),
				o = new u(r, n),
				s = new u([], n),
				c = l.map(n.get("data"), l.curry(x, i, t, n));
			t && (c = l[pe](c, l.curry(e, t)));
			var h = t ? m.dimValueGetter : function(t) {
				return t.value
			};
			return a.initData(l.map(c, function(t) {
				return t[0]
			}), null, h), o.initData(l.map(c, function(t) {
				return t[1]
			}), null, h), s.initData(l.map(c, function(t) {
				return t[2]
			})), {
				from: a,
				to: o,
				line: s
			}
		}
		var l = t(me),
			u = t("../../data/List"),
			c = t("../../util/format"),
			h = t("../../util/model"),
			d = t(n),
			f = c.addCommas,
			p = c.encodeHTML,
			m = t("./markerHelper"),
			y = t("../../chart/helper/LineDraw"),
			x = function(t, e, i, n) {
				var r = t[U](),
					a = n.type;
				if (!l[G](n) && ("min" === a || "max" === a || "average" === a)) {
					var o = m.getAxisInfo(n, r, e, t),
						s = o.baseAxis.dim + "Axis",
						u = o.valueAxis.dim + "Axis",
						c = o.baseAxis.scale[A](),
						h = l.clone(n),
						d = {};
					h.type = null, h[s] = c[0], d[s] = c[1];
					var f = m.numCalculate(r, o.valueDataDim, a);
					f = o.valueAxis.coordToData(o.valueAxis.dataToCoord(f));
					var p = i.get("precision");
					p >= 0 && (f = +f.toFixed(p)), h[u] = d[u] = f, n = [h, d, {
						type: a,
						valueIndex: n.valueIndex,
						value: f
					}]
				}
				return n = [m.dataTransform(t, n[0]), m.dataTransform(t, n[1]), l[te]({}, n[2])], n[2].type = n[2].type || "", l.merge(n[2], n[0]), l.merge(n[2], n[1]), n
			},
			M = {
				formatTooltip: function(t) {
					var e = this._data,
						i = this.getRawValue(t),
						n = l[G](i) ? l.map(i, f).join(", ") : f(i),
						r = e[g](t);
					return this.name + "<br />" + ((r ? p(r) + " : " : "") + n)
				},
				getRawDataArray: function() {
					return this[_].data
				},
				getData: function() {
					return this._data
				},
				setData: function(t) {
					this._data = t
				}
			};
		l[K](M, h.dataFormatMixin), t(s).extendComponentView({
			type: "markLine",
			init: function() {
				this._markLineMap = {}
			},
			render: function(t, e, i) {
				var n = this._markLineMap;
				for (var r in n) n[r].__keep = !1;
				e[Y](function(t) {
					var n = t.markLineModel;
					n && this._renderSeriesML(t, n, e, i)
				}, this);
				for (var r in n) n[r].__keep || this.group[ee](n[r].group)
			},
			updateLayout: function(t, e, n) {
				e[Y](function(t) {
					var e = t.markLineModel;
					if (e) {
						var r = e[U](),
							a = e.__from,
							o = e.__to;
						a.each(function(e) {
							var s = r[b](e),
								l = s.get("type"),
								u = s.get("valueIndex");
							i(a, e, !0, l, u, t, n), i(o, e, !1, l, u, t, n)
						}), r.each(function(t) {
							r.setItemLayout(t, [a.getItemLayout(t), o.getItemLayout(t)])
						}), this._markLineMap[t.name].updateLayout()
					}
				}, this)
			},
			_renderSeriesML: function(t, e, n, r) {
				function a(e, n, a, o, s) {
					var l = e[b](n);
					i(e, n, a, o, s, t, r), e.setItemVisual(n, {
						symbolSize: l.get("symbolSize") || _[a ? 0 : 1],
						symbol: l.get("symbol", !0) || x[a ? 0 : 1],
						color: l.get("itemStyle.normal.color") || c.getVisual("color")
					})
				}
				var s = t[R],
					u = t.name,
					c = t[U](),
					h = this._markLineMap,
					d = h[u];
				d || (d = h[u] = new y), this.group.add(d.group);
				var f = o(s, t, e),
					p = f.from,
					m = f.to,
					g = f.line;
				e.__from = p, e.__to = m, l[te](e, M), e.setData(g);
				var x = e.get("symbol"),
					_ = e.get("symbolSize");
				l[G](x) || (x = [x, x]), typeof _ === V && (_ = [_, _]), f.from.each(function(t) {
					var e = g[b](t),
						i = e.get("type"),
						n = e.get("valueIndex");
					a(p, t, !0, i, n), a(m, t, !1, i, n)
				}), g.each(function(t) {
					var e = g[b](t).get("lineStyle.normal.color");
					g.setItemVisual(t, {
						color: e || p[v](t, "color")
					}), g.setItemLayout(t, [p.getItemLayout(t), m.getItemLayout(t)])
				}), d.updateData(g, p, m), f.line.eachItemGraphicEl(function(t) {
					t.traverse(function(t) {
						t.dataModel = e
					})
				}), d.__keep = !0
			}
		})
	}), e("echarts/component/dataZoom/typeDefaulter", [ve, "../../model/Component"], function(t) {
		t("../../model/Component").registerSubTypeDefaulter("dataZoom", function() {
			return "slider"
		})
	}), e("echarts/component/dataZoom/DataZoomModel", [ve, me, "zrender/core/env", s, "../../util/model", "./AxisProxy"], function(t) {
		function e(t) {
			var e = {};
			return c(["start", "end", "startValue", "endValue"], function(i) {
				e[i] = t[i]
			}), e
		}

		function n(t, e, i, n) {
			null != i[e] && null == i[t] && (n[t] = null)
		}
		var r = t(me),
			a = t("zrender/core/env"),
			o = t(s),
			l = t("../../util/model"),
			u = t("./AxisProxy"),
			c = r.each,
			h = l.eachAxisDim,
			d = o.extendComponentModel({
				type: "dataZoom",
				dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", j],
				defaultOption: {
					zlevel: 0,
					z: 4,
					orient: null,
					xAxisIndex: null,
					yAxisIndex: null,
					angleAxisIndex: null,
					radiusAxisIndex: null,
					filterMode: "filter",
					throttle: 100,
					start: 0,
					end: 100,
					startValue: null,
					endValue: null
				},
				init: function(t, i, n) {
					this._dataIntervalByAxis = {}, this._dataInfo = {}, this._axisProxies = {}, this.textStyleModel;
					var r = e(t);
					this.mergeDefaultAndTheme(t, n), this.doInit(r)
				},
				mergeOption: function(t) {
					var i = e(t);
					r.merge(this[_], t, !0), this.doInit(i)
				},
				doInit: function(t) {
					var e = this[_];
					a.canvasSupported || (e.realtime = !1), n("start", "startValue", t, e), n("end", "endValue", t, e), this.textStyleModel = this[ce](O), this._resetTarget(), this._giveAxisProxies()
				},
				_giveAxisProxies: function() {
					var t = this._axisProxies;
					this.eachTargetAxis(function(e, i, n, r) {
						var a = this.dependentModels[e.axis][i],
							o = a.__dzAxisProxy || (a.__dzAxisProxy = new u(e.name, i, this, r));
						t[e.name + "_" + i] = o
					}, this)
				},
				_resetTarget: function() {
					var t = this[_],
						e = this._judgeAutoMode();
					h(function(e) {
						var i = e.axisIndex;
						t[i] = l.normalizeToArray(t[i])
					}, this), "axisIndex" === e ? this._autoSetAxisIndex() : "orient" === e && this._autoSetOrient()
				},
				_judgeAutoMode: function() {
					var t = this[_],
						e = !1;
					h(function(i) {
						null != t[i.axisIndex] && (e = !0)
					}, this);
					var i = t.orient;
					return null == i && e ? "orient" : e ? void 0 : (null == i && (t.orient = "horizontal"), "axisIndex")
				},
				_autoSetAxisIndex: function() {
					var t = !0,
						e = this.get("orient", !0),
						n = this[_];
					if (t) {
						var a = "vertical" === e ? {
							dim: "y",
							axisIndex: "yAxisIndex",
							axis: "yAxis"
						} : {
							dim: "x",
							axisIndex: "xAxisIndex",
							axis: "xAxis"
						};
						this.dependentModels[a.axis][$] && (n[a.axisIndex] = [0], t = !1)
					}
					t && h(function(e) {
						if (t) {
							var r = [],
								a = this.dependentModels[e.axis];
							if (a[$] && !r[$])
								for (var o = 0, s = a[$]; s > o; o++) a[o].get("type") === i && r.push(o);
							n[e.axisIndex] = r, r[$] && (t = !1)
						}
					}, this), t && this[m][Y](function(t) {
						this._isSeriesHasAllAxesTypeOf(t, "value") && h(function(e) {
							var i = n[e.axisIndex],
								a = t.get(e.axisIndex);
							r[N](i, a) < 0 && i.push(a)
						})
					}, this)
				},
				_autoSetOrient: function() {
					var t;
					this.eachTargetAxis(function(e) {
						!t && (t = e.name)
					}, this), this[_].orient = "y" === t ? "vertical" : "horizontal"
				},
				_isSeriesHasAllAxesTypeOf: function(t, e) {
					var i = !0;
					return h(function(n) {
						var r = t.get(n.axisIndex),
							a = this.dependentModels[n.axis][r];
						a && a.get("type") === e || (i = !1)
					}, this), i
				},
				getFirstTargetAxisModel: function() {
					var t;
					return h(function(e) {
						if (null == t) {
							var i = this.get(e.axisIndex);
							i[$] && (t = this.dependentModels[e.axis][i[0]])
						}
					}, this), t
				},
				eachTargetAxis: function(t, e) {
					var i = this[m];
					h(function(n) {
						c(this.get(n.axisIndex), function(r) {
							t.call(e, n, r, this, i)
						}, this)
					}, this)
				},
				getAxisProxy: function(t, e) {
					return this._axisProxies[t + "_" + e]
				},
				setRawRange: function(t) {
					c(["start", "end", "startValue", "endValue"], function(e) {
						this[_][e] = t[e]
					}, this)
				},
				getPercentRange: function() {
					var t = this.findRepresentativeAxisProxy();
					return t ? t.getDataPercentWindow() : void 0
				},
				getValueRange: function(t, e) {
					if (null != t || null != e) return this.getAxisProxy(t, e).getDataValueWindow();
					var i = this.findRepresentativeAxisProxy();
					return i ? i.getDataValueWindow() : void 0
				},
				findRepresentativeAxisProxy: function() {
					var t = this._axisProxies;
					for (var e in t)
						if (t.hasOwnProperty(e) && t[e].hostedBy(this)) return t[e];
					for (var e in t)
						if (t.hasOwnProperty(e) && !t[e].hostedBy(this)) return t[e]
				}
			});
		return d
	}), e("echarts/component/dataZoom/DataZoomView", [ve, "../../view/Component"], function(t) {
		var e = t("../../view/Component");
		return e[te]({
			type: "dataZoom",
			render: function(t, e, i) {
				this.dataZoomModel = t, this[m] = e, this.api = i
			},
			getTargetInfo: function() {
				function t(t, e, i, n) {
					for (var r, a = 0; a < i[$]; a++)
						if (i[a].model === t) {
							r = i[a];
							break
						}
					r || i.push(r = {
						model: t,
						axisModels: [],
						coordIndex: n
					}), r.axisModels.push(e)
				}
				var e = this.dataZoomModel,
					i = this[m],
					n = [],
					r = [],
					a = [];
				return e.eachTargetAxis(function(e, o) {
					var s = i[y](e.axis, o);
					if (s) {
						a.push(s);
						var l = s.get("gridIndex"),
							u = s.get("polarIndex");
						if (null != l) {
							var c = i[y]("grid", l);
							t(c, s, n, l)
						} else if (null != u) {
							var c = i[y]("polar", u);
							t(c, s, r, u)
						}
					}
				}, this), {
					cartesians: n,
					polars: r,
					axisModels: a
				}
			}
		})
	}), e("echarts/component/dataZoom/SliderZoomModel", [ve, "./DataZoomModel", "../../util/layout", me], function(t) {
		var e = t("./DataZoomModel"),
			i = (t("../../util/layout"), t(me), e[te]({
				type: "dataZoom.slider",
				layoutMode: "box",
				defaultOption: {
					show: !0,
					right: "ph",
					top: "ph",
					width: "ph",
					height: "ph",
					left: null,
					bottom: null,
					backgroundColor: "rgba(47,69,84,0)",
					dataBackgroundColor: "#ddd",
					fillerColor: "rgba(47,69,84,0.15)",
					handleColor: "rgba(148,164,165,0.95)",
					handleSize: 10,
					labelPrecision: null,
					labelFormatter: null,
					showDetail: !0,
					showDataShadow: "auto",
					realtime: !0,
					zoomLock: !1,
					textStyle: {
						color: "#333"
					}
				},
				mergeOption: function() {
					i.superApply(this, x, arguments)
				}
			}));
		return i
	}), e("echarts/component/dataZoom/SliderZoomView", [ve, me, "../../util/graphic", "../../util/throttle", "./DataZoomView", n, "../../util/layout", "../helper/sliderMove"], function(t) {
		function e(t) {
			return "x" === t ? "y" : "x"
		}
		var r = t(me),
			a = t("../../util/graphic"),
			o = t("../../util/throttle"),
			s = t("./DataZoomView"),
			l = a.Rect,
			u = t(n),
			c = u.linearMap,
			h = t("../../util/layout"),
			d = t("../helper/sliderMove"),
			f = u.asc,
			v = r.bind,
			g = Math.round,
			x = Math.max,
			b = r.each,
			w = 7,
			M = 1,
			S = 30,
			A = "horizontal",
			C = "vertical",
			I = 5,
			O = ["line", "bar", "candlestick", "scatter"],
			B = s[te]({
				type: "dataZoom.slider",
				init: function(t, e) {
					this._displayables = {}, this._orient, this._range, this._handleEnds, this._size, this._halfHandleSize, this._location, this._dragging, this._dataShadowInfo, this.api = e
				},
				render: function(t, e, i, n) {
					return B.superApply(this, "render", arguments), o.createOrUpdate(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate"), this._orient = t.get("orient"), this._halfHandleSize = g(t.get("handleSize") / 2), this.dataZoomModel.get("show") === !1 ? void this.group[E]() : (n && "dataZoom" === n.type && n.from === this.uid || this._buildView(), void this._updateView())
				},
				remove: function() {
					B.superApply(this, ee, arguments), o.clear(this, "_dispatchZoomAction")
				},
				dispose: function() {
					B.superApply(this, "dispose", arguments), o.clear(this, "_dispatchZoomAction")
				},
				_buildView: function() {
					var t = this.group;
					t[E](), this._resetLocation(), this._resetInterval();
					var e = this._displayables.barGroup = new a.Group;
					this._renderBackground(), this._renderDataShadow(), this._renderHandle(), t.add(e), this._positionGroup()
				},
				_resetLocation: function() {
					var t = this.dataZoomModel,
						e = this.api,
						i = this._findCoordRect(),
						n = {
							width: e[ue](),
							height: e[le]()
						},
						a = this._orient === A ? {
							right: n.width - i.x - i.width,
							top: n[ae] - S - w,
							width: i.width,
							height: S
						} : {
							right: w,
							top: i.y,
							width: S,
							height: i[ae]
						},
						o = h.getLayoutParams(t[_]);
					r.each(["right", "top", "width", ae], function(t) {
						"ph" === o[t] && (o[t] = a[t])
					});
					var s = h.getLayoutRect(o, n, t.padding);
					this._location = {
						x: s.x,
						y: s.y
					}, this._size = [s.width, s[ae]], this._orient === C && this._size.reverse()
				},
				_positionGroup: function() {
					var t = this.group,
						e = this._location,
						i = this._orient,
						n = this.dataZoomModel.getFirstTargetAxisModel(),
						r = n && n.get("inverse"),
						a = this._displayables.barGroup,
						o = (this._dataShadowInfo || {}).otherAxisInverse;
					a.attr(i !== A || r ? i === A && r ? {
						scale: o ? [-1, 1] : [-1, -1]
					} : i !== C || r ? {
						scale: o ? [-1, -1] : [-1, 1],
						rotation: Math.PI / 2
					} : {
						scale: o ? [1, -1] : [1, 1],
						rotation: Math.PI / 2
					} : {
						scale: o ? [1, 1] : [1, -1]
					});
					var s = t[P]([a]);
					t[L][0] = e.x - s.x, t[L][1] = e.y - s.y
				},
				_getViewExtent: function() {
					var t = this._halfHandleSize,
						e = x(this._size[0], 4 * t),
						i = [t, e - t];
					return i
				},
				_renderBackground: function() {
					var t = this.dataZoomModel,
						e = this._size;
					this._displayables.barGroup.add(new l({
						silent: !0,
						shape: {
							x: 0,
							y: 0,
							width: e[0],
							height: e[1]
						},
						style: {
							fill: t.get("backgroundColor")
						}
					}))
				},
				_renderDataShadow: function() {
					var t = this._dataShadowInfo = this._prepareDataShadowInfo();
					if (t) {
						var e = this._size,
							i = t[j],
							n = i.getRawData(),
							r = i.getShadowDim ? i.getShadowDim() : t.otherDim,
							o = n.getDataExtent(r),
							s = .3 * (o[1] - o[0]);
						o = [o[0] - s, o[1] + s];
						var l = [0, e[1]],
							u = [0, e[0]],
							h = [
								[e[0], 0],
								[0, 0]
							],
							d = u[1] / (n.count() - 1),
							f = 0,
							p = Math.round(n.count() / e[0]);
						n.each([r], function(t, e) {
							if (p > 0 && e % p) return void(f += d);
							var i = null == t || isNaN(t) || "" === t ? null : c(t, o, l, !0);
							null != i && h.push([f, i]), f += d
						}), this._displayables.barGroup.add(new a.Polyline({
							shape: {
								points: h
							},
							style: {
								fill: this.dataZoomModel.get("dataBackgroundColor"),
								lineWidth: 0
							},
							silent: !0,
							z2: -20
						}))
					}
				},
				_prepareDataShadowInfo: function() {
					var t = this.dataZoomModel,
						i = t.get("showDataShadow");
					if (i !== !1) {
						var n, a = this[m];
						return t.eachTargetAxis(function(o, s) {
							var l = t.getAxisProxy(o.name, s).getTargetSeriesModels();
							r.each(l, function(t) {
								if (!(n || i !== !0 && r[N](O, t.get("type")) < 0)) {
									var l = e(o.name),
										u = a[y](o.axis, s).axis;
									n = {
										thisAxis: u,
										series: t,
										thisDim: o.name,
										otherDim: l,
										otherAxisInverse: t[R].getOtherAxis(u).inverse
									}
								}
							}, this)
						}, this), n
					}
				},
				_renderHandle: function() {
					var t = this._displayables,
						e = t.handles = [],
						i = t.handleLabels = [],
						n = this._displayables.barGroup,
						r = this._size;
					n.add(t.filler = new l({
						draggable: !0,
						cursor: "move",
						drift: v(this._onDragMove, this, "all"),
						ondragend: v(this._onDragEnd, this),
						onmouseover: v(this._showDataInfo, this, !0),
						onmouseout: v(this._showDataInfo, this, !1),
						style: {
							fill: this.dataZoomModel.get("fillerColor"),
							textPosition: "inside"
						}
					})), n.add(new l(a.subPixelOptimizeRect({
						silent: !0,
						shape: {
							x: 0,
							y: 0,
							width: r[0],
							height: r[1]
						},
						style: {
							stroke: this.dataZoomModel.get("dataBackgroundColor"),
							lineWidth: M,
							fill: "rgba(0,0,0,0)"
						}
					}))), b([0, 1], function(t) {
						n.add(e[t] = new l({
							style: {
								fill: this.dataZoomModel.get("handleColor")
							},
							cursor: "move",
							draggable: !0,
							drift: v(this._onDragMove, this, t),
							ondragend: v(this._onDragEnd, this),
							onmouseover: v(this._showDataInfo, this, !0),
							onmouseout: v(this._showDataInfo, this, !1)
						}));
						var r = this.dataZoomModel.textStyleModel;
						this.group.add(i[t] = new a.Text({
							silent: !0,
							invisible: !0,
							style: {
								x: 0,
								y: 0,
								text: "",
								textVerticalAlign: "middle",
								textAlign: "center",
								fill: r[T](),
								textFont: r[D]()
							}
						}))
					}, this)
				},
				_resetInterval: function() {
					var t = this._range = this.dataZoomModel.getPercentRange(),
						e = this._getViewExtent();
					this._handleEnds = [c(t[0], [0, 100], e, !0), c(t[1], [0, 100], e, !0)]
				},
				_updateInterval: function(t, e) {
					var i = this._handleEnds,
						n = this._getViewExtent();
					d(e, i, n, "all" === t || this.dataZoomModel.get("zoomLock") ? "rigid" : "cross", t), this._range = f([c(i[0], n, [0, 100], !0), c(i[1], n, [0, 100], !0)])
				},
				_updateView: function() {
					var t = this._displayables,
						e = this._handleEnds,
						i = f(e.slice()),
						n = this._size,
						r = this._halfHandleSize;
					b([0, 1], function(i) {
						var a = t.handles[i];
						a.setShape({
							x: e[i] - r,
							y: -1,
							width: 2 * r,
							height: n[1] + 2,
							r: 1
						})
					}, this), t.filler.setShape({
						x: i[0],
						y: 0,
						width: i[1] - i[0],
						height: this._size[1]
					}), this._updateDataInfo()
				},
				_updateDataInfo: function() {
					function t(t) {
						var e = a.getTransform(i.handles[t], this.group),
							s = a.transformDirection(0 === t ? "right" : "left", e),
							l = this._halfHandleSize + I,
							c = a[p]([u[t] + (0 === t ? -l : l), this._size[1] / 2], e);
						n[t].setStyle({
							x: c[0],
							y: c[1],
							textVerticalAlign: r === A ? z : s,
							textAlign: r === A ? s : k,
							text: o[t]
						})
					}
					var e = this.dataZoomModel,
						i = this._displayables,
						n = i.handleLabels,
						r = this._orient,
						o = ["", ""];
					if (e.get("showDetail")) {
						var s, l;
						e.eachTargetAxis(function(t, i) {
							s || (s = e.getAxisProxy(t.name, i).getDataValueWindow(), l = this[m][y](t.axis, i).axis)
						}, this), s && (o = [this._formatLabel(s[0], l), this._formatLabel(s[1], l)])
					}
					var u = f(this._handleEnds.slice());
					t.call(this, 0), t.call(this, 1)
				},
				_formatLabel: function(t, e) {
					var n = this.dataZoomModel,
						a = n.get("labelFormatter");
					if (r.isFunction(a)) return a(t);
					var o = n.get("labelPrecision");
					return (null == o || "auto" === o) && (o = e.getPixelPrecision()), t = null == t && isNaN(t) ? "" : e.type === i || "time" === e.type ? e.scale.getLabel(Math.round(t)) : t.toFixed(Math.min(o, 20)), r.isString(a) && (t = a[F]("{value}", t)), t
				},
				_showDataInfo: function(t) {
					t = this._dragging || t;
					var e = this._displayables.handleLabels;
					e[0].attr("invisible", !t), e[1].attr("invisible", !t)
				},
				_onDragMove: function(t, e, i) {
					this._dragging = !0;
					var n = this._applyBarTransform([e, i], !0);
					this._updateInterval(t, n[0]), this._updateView(), this.dataZoomModel.get("realtime") && this._dispatchZoomAction()
				},
				_onDragEnd: function() {
					this._dragging = !1, this._showDataInfo(!1), this._dispatchZoomAction()
				},
				_dispatchZoomAction: function() {
					var t = this._range;
					this.api[J]({
						type: "dataZoom",
						from: this.uid,
						dataZoomId: this.dataZoomModel.id,
						start: t[0],
						end: t[1]
					})
				},
				_applyBarTransform: function(t, e) {
					var i = this._displayables.barGroup.getLocalTransform();
					return a[p](t, i, e)
				},
				_findCoordRect: function() {
					var t, e = this.getTargetInfo();
					if (e.cartesians[$]) t = e.cartesians[0].model[R].getRect();
					else {
						var i = this.api[ue](),
							n = this.api[le]();
						t = {
							x: .2 * i,
							y: .2 * n,
							width: .6 * i,
							height: .6 * n
						}
					}
					return t
				}
			});
		return B
	}), e("echarts/component/dataZoom/InsideZoomModel", [ve, "./DataZoomModel"], function(t) {
		return t("./DataZoomModel")[te]({
			type: "dataZoom.inside",
			defaultOption: {
				zoomLock: !1
			}
		})
	}), e("echarts/component/dataZoom/InsideZoomView", [ve, "./DataZoomView", me, "../helper/sliderMove", "./roams"], function(t) {
		function e(t, e, i, r) {
			e = e.slice();
			var a = r.axisModels[0];
			if (a) {
				var o = n(t, a, i),
					l = o.signal * (e[1] - e[0]) * o.pixel / o.pixelLength;
				return s(l, e, [0, 100], "rigid"), e
			}
		}

		function i(t, e, i, a, o) {
			i = i.slice();
			var s = o.axisModels[0];
			if (s) {
				var l = n(e, s, a),
					u = l.pixel - l.pixelStart,
					c = u / l.pixelLength * (i[1] - i[0]) + i[0];
				return t = Math.max(t, 0), i[0] = (i[0] - c) * t + c, i[1] = (i[1] - c) * t + c, r(i)
			}
		}

		function n(t, e, i) {
			var n = e.axis,
				r = i.rect,
				a = {};
			return "x" === n.dim ? (a.pixel = t[0], a.pixelLength = r.width, a.pixelStart = r.x, a.signal = n.inverse ? 1 : -1) : (a.pixel = t[1], a.pixelLength = r[ae], a.pixelStart = r.y, a.signal = n.inverse ? -1 : 1), a
		}

		function r(t) {
			var e = [0, 100];
			return !(t[0] <= e[1]) && (t[0] = e[1]), !(t[1] <= e[1]) && (t[1] = e[1]), !(t[0] >= e[0]) && (t[0] = e[0]), !(t[1] >= e[0]) && (t[1] = e[0]), t
		}
		var a = t("./DataZoomView"),
			o = t(me),
			s = t("../helper/sliderMove"),
			l = t("./roams"),
			u = o.bind,
			c = a[te]({
				type: "dataZoom.inside",
				init: function() {
					this._range
				},
				render: function(t, e, i, n) {
					c.superApply(this, "render", arguments), l.shouldRecordRange(n, t.id) && (this._range = t.getPercentRange());
					var r = this.getTargetInfo().cartesians,
						a = o.map(r, function(t) {
							return l.generateCoordId(t.model)
						});
					o.each(r, function(e) {
						var n = e.model;
						l.register(i, {
							coordId: l.generateCoordId(n),
							allCoordIds: a,
							coordinateSystem: n[R],
							dataZoomId: t.id,
							throttleRage: t.get("throttle", !0),
							panGetRange: u(this._onPan, this, e),
							zoomGetRange: u(this._onZoom, this, e)
						})
					}, this)
				},
				remove: function() {
					l.unregister(this.api, this.dataZoomModel.id), c.superApply(this, ee, arguments), this._range = null
				},
				dispose: function() {
					l.unregister(this.api, this.dataZoomModel.id), c.superApply(this, "dispose", arguments), this._range = null
				},
				_onPan: function(t, i, n, r) {
					return this._range = e([n, r], this._range, i, t)
				},
				_onZoom: function(t, e, n, r, a) {
					var o = this.dataZoomModel;
					return o[_].zoomLock ? this._range : this._range = i(1 / n, [r, a], this._range, e, t, o)
				}
			});
		return c
	}), e("echarts/component/dataZoom/dataZoomProcessor", [ve, s], function(t) {
		function e(t, e, i) {
			i.getAxisProxy(t.name, e).reset(i)
		}

		function i(t, e, i) {
			i.getAxisProxy(t.name, e).filterData(i)
		}
		var n = t(s);
		n.registerProcessor(pe, function(t) {
			t.eachComponent("dataZoom", function(t) {
				t.eachTargetAxis(e), t.eachTargetAxis(i)
			}), t.eachComponent("dataZoom", function(t) {
				var e = t.findRepresentativeAxisProxy(),
					i = e.getDataPercentWindow(),
					n = e.getDataValueWindow();
				t.setRawRange({
					start: i[0],
					end: i[1],
					startValue: n[0],
					endValue: n[1]
				})
			})
		})
	}), e("echarts/component/dataZoom/dataZoomAction", [ve, me, "../../util/model", s], function(t) {
		var e = t(me),
			i = t("../../util/model"),
			n = t(s);
		n.registerAction("dataZoom", function(t, n) {
			var r = i.createLinkedNodesFinder(e.bind(n.eachComponent, n, "dataZoom"), i.eachAxisDim, function(t, e) {
					return t.get(e.axisIndex)
				}),
				a = [];
			n.eachComponent({
				mainType: "dataZoom",
				query: t
			}, function(t) {
				a.push.apply(a, r(t).nodes)
			}), e.each(a, function(e) {
				e.setRawRange({
					start: t.start,
					end: t.end,
					startValue: t.startValue,
					endValue: t.endValue
				})
			})
		})
	}), e("echarts/scale/Scale", [ve, "../util/clazz"], function(t) {
		function e() {
			this._extent = [1 / 0, -1 / 0], this._interval = 0, this.init && this.init.apply(this, arguments)
		}
		var i = t("../util/clazz"),
			n = e[de];
		return n.parse = function(t) {
			return t
		}, n[S] = function(t) {
			var e = this._extent;
			return t >= e[0] && t <= e[1]
		}, n.normalize = function(t) {
			var e = this._extent;
			return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0])
		}, n.scale = function(t) {
			var e = this._extent;
			return t * (e[1] - e[0]) + e[0]
		}, n.unionExtent = function(t) {
			var e = this._extent;
			t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1])
		}, n[A] = function() {
			return this._extent.slice()
		}, n.setExtent = function(t, e) {
			var i = this._extent;
			isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e)
		}, n.getTicksLabels = function() {
			for (var t = [], e = this.getTicks(), i = 0; i < e[$]; i++) t.push(this.getLabel(e[i]));
			return t
		}, i.enableClassExtend(e), i.enableClassManagement(e, {
			registerWhenExtend: !0
		}), e
	}), e("echarts/scale/Interval", [ve, "../util/number", "../util/format", "./Scale"], function(t) {
		var e = t("../util/number"),
			i = t("../util/format"),
			n = t("./Scale"),
			r = Math.floor,
			a = Math.ceil,
			o = n[te]({
				type: "interval",
				_interval: 0,
				setExtent: function(t, e) {
					var i = this._extent;
					isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e))
				},
				unionExtent: function(t) {
					var e = this._extent;
					t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), o[de].setExtent.call(this, e[0], e[1])
				},
				getInterval: function() {
					return this._interval || this.niceTicks(), this._interval
				},
				setInterval: function(t) {
					this._interval = t, this._niceExtent = this._extent.slice()
				},
				getTicks: function() {
					this._interval || this.niceTicks();
					var t = this._interval,
						i = this._extent,
						n = [],
						r = 1e4;
					if (t) {
						var a = this._niceExtent;
						i[0] < a[0] && n.push(i[0]);
						for (var o = a[0]; o <= a[1];)
							if (n.push(o), o = e.round(o + t), n[$] > r) return [];
						i[1] > a[1] && n.push(i[1])
					}
					return n
				},
				getTicksLabels: function() {
					for (var t = [], e = this.getTicks(), i = 0; i < e[$]; i++) t.push(this.getLabel(e[i]));
					return t
				},
				getLabel: function(t) {
					return i.addCommas(t)
				},
				niceTicks: function(t) {
					t = t || 5;
					var i = this._extent,
						n = i[1] - i[0];
					if (isFinite(n)) {
						0 > n && (n = -n, i.reverse());
						var o = e.nice(n / t, !0),
							s = [e.round(a(i[0] / o) * o), e.round(r(i[1] / o) * o)];
						this._interval = o, this._niceExtent = s
					}
				},
				niceExtent: function(t, i, n) {
					var o = this._extent;
					if (o[0] === o[1])
						if (0 !== o[0]) {
							var s = o[0] / 2;
							o[0] -= s, o[1] += s
						} else o[1] = 1;
					var l = o[1] - o[0];
					isFinite(l) || (o[0] = 0, o[1] = 1), this.niceTicks(t);
					var u = this._interval;
					i || (o[0] = e.round(r(o[0] / u) * u)), n || (o[1] = e.round(a(o[1] / u) * u))
				}
			});
		return o[re] = function() {
			return new o
		}, o
	}), e("zrender/graphic/Gradient", [ve], function() {
		var t = function(t) {
			this.colorStops = t || []
		};
		return t[de] = {
			constructor: t,
			addColorStop: function(t, e) {
				this.colorStops.push({
					offset: t,
					color: e
				})
			}
		}, t
	}), e("echarts/util/model", [ve, "./format", "./number", me, "../model/Model"], function(t) {
		var e = t("./format"),
			i = t("./number"),
			n = t(me),
			a = t("../model/Model"),
			o = ["x", "y", "z", "radius", "angle"],
			s = {};
		return s.createNameEach = function(t, e) {
			t = t.slice();
			var i = n.map(t, s.capitalFirst);
			e = (e || []).slice();
			var r = n.map(e, s.capitalFirst);
			return function(a, o) {
				n.each(t, function(t, n) {
					for (var s = {
							name: t,
							capital: i[n]
						}, l = 0; l < e[$]; l++) s[e[l]] = t + r[l];
					a.call(o, s)
				})
			}
		}, s.capitalFirst = function(t) {
			return t ? t.charAt(0).toUpperCase() + t.substr(1) : t
		}, s.eachAxisDim = s.createNameEach(o, ["axisIndex", "axis", "index"]), s.normalizeToArray = function(t) {
			return n[G](t) ? t : null == t ? [] : [t]
		}, s.createLinkedNodesFinder = function(t, e, i) {
			function r(t, e) {
				return n[N](e.nodes, t) >= 0
			}

			function a(t, r) {
				var a = !1;
				return e(function(e) {
					n.each(i(t, e) || [], function(t) {
						r.records[e.name][t] && (a = !0)
					})
				}), a
			}

			function o(t, r) {
				r.nodes.push(t), e(function(e) {
					n.each(i(t, e) || [], function(t) {
						r.records[e.name][t] = !0
					})
				})
			}
			return function(i) {
				function n(t) {
					!r(t, s) && a(t, s) && (o(t, s), l = !0)
				}
				var s = {
					nodes: [],
					records: {}
				};
				if (e(function(t) {
						s.records[t.name] = {}
					}), !i) return s;
				o(i, s);
				var l;
				do l = !1, t(n); while (l);
				return s
			}
		}, s.defaultEmphasis = function(t, e) {
			if (t) {
				var i = t[f] = t[f] || {},
					r = t[d] = t[d] || {};
				n.each(e, function(t) {
					var e = n.retrieve(i[t], r[t]);
					null != e && (i[t] = e)
				})
			}
		}, s.createDataFormatModel = function(t, e, i) {
			var r = new a;
			return n.mixin(r, s.dataFormatMixin), r[q] = t[q], r.name = t.name || "", r[U] = function() {
				return e
			}, r.getRawDataArray = function() {
				return i
			}, r
		}, s.getDataItemValue = function(t) {
			return t && (null == t.value ? t : t.value)
		}, s.converDataValue = function(t, e) {
			var n = e && e.type;
			return n === r ? t : ("time" !== n || isFinite(t) || null == t || "-" === t || (t = +i.parseDate(t)), null == t || "" === t ? 0 / 0 : +t)
		}, s.dataFormatMixin = {
			getDataParams: function(t) {
				var e = this[U](),
					i = this[q],
					n = this.name,
					r = this.getRawValue(t),
					a = e.getRawIndex(t),
					o = e[g](t, !0),
					s = this.getRawDataArray(),
					l = s && s[a];
				return {
					seriesIndex: i,
					seriesName: n,
					name: o,
					dataIndex: a,
					data: l,
					value: r,
					color: e[v](t, "color"),
					$vars: ["seriesName", "name", "value"]
				}
			},
			getFormattedLabel: function(t, i, n) {
				i = i || d;
				var r = this[U](),
					a = r[b](t),
					o = this.getDataParams(t);
				return null == n && (n = a.get(["label", i, "formatter"])), typeof n === Z ? (o.status = i, n(o)) : typeof n === he ? e.formatTpl(n, o) : void 0
			},
			getRawValue: function(t) {
				var e = this[U]()[b](t);
				if (e && null != e[_]) {
					var i = e[_];
					return n[ie](i) && !n[G](i) ? i.value : i
				}
			}
		}, s.mappingToExists = function(t, e) {
			e = (e || []).slice();
			var i = n.map(t || [], function(t) {
				return {
					exist: t
				}
			});
			return n.each(e, function(t, r) {
				if (n[ie](t))
					for (var a = 0; a < i[$]; a++) {
						var o = i[a].exist;
						if (!i[a][_] && (null != t.id && o.id === t.id + "" || null != t.name && !s.isIdInner(t) && !s.isIdInner(o) && o.name === t.name + "")) {
							i[a][_] = t, e[r] = null;
							break
						}
					}
			}), n.each(e, function(t) {
				if (n[ie](t)) {
					for (var e = 0; e < i[$]; e++) {
						var r = i[e].exist;
						if (!i[e][_] && !s.isIdInner(r) && null == t.id) {
							i[e][_] = t;
							break
						}
					}
					e >= i[$] && i.push({
						option: t
					})
				}
			}), i
		}, s.isIdInner = function(t) {
			return n[ie](t) && t.id && 0 === (t.id + "")[N]("\x00_ec_\x00")
		}, s
	}), e("echarts/model/Model", [ve, me, "../util/clazz", "./mixin/lineStyle", "./mixin/areaStyle", "./mixin/textStyle", "./mixin/itemStyle"], function(t) {
		function e(t, e, i, n) {
			this.parentModel = e, this[m] = i, this[_] = t, this.init && (arguments[$] <= 4 ? this.init(t, e, i, n) : this.init.apply(this, arguments))
		}
		var i = t(me),
			n = t("../util/clazz");
		e[de] = {
			constructor: e,
			init: null,
			mergeOption: function(t) {
				i.merge(this[_], t, !0)
			},
			get: function(t, e) {
				if (!t) return this[_];
				typeof t === he && (t = t.split("."));
				for (var i = this[_], n = this.parentModel, r = 0; r < t[$] && (i = i && "object" == typeof i ? i[t[r]] : null, null != i); r++);
				return null == i && n && !e && (i = n.get(t)), i
			},
			getShallow: function(t, e) {
				var i = this[_],
					n = i && i[t],
					r = this.parentModel;
				return null == n && r && !e && (n = r[h](t)), n
			},
			getModel: function(t, i) {
				var n = this.get(t, !0),
					r = this.parentModel,
					a = new e(n, i || r && r[ce](t), this[m]);
				return a
			},
			isEmpty: function() {
				return null == this[_]
			},
			restoreData: function() {},
			clone: function() {
				var t = this.constructor;
				return new t(i.clone(this[_]))
			},
			setReadOnly: function(t) {
				n.setReadOnly(this, t)
			}
		}, n.enableClassExtend(e);
		var r = i.mixin;
		return r(e, t("./mixin/lineStyle")), r(e, t("./mixin/areaStyle")), r(e, t("./mixin/textStyle")), r(e, t("./mixin/itemStyle")), e
	}), e("echarts/model/globalDefault", [], function() {
		var t = "";
		return typeof navigator !== u && (t = navigator.platform || ""), {
			color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
			grid: {},
			textStyle: {
				fontFamily: t.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
				fontSize: 12,
				fontStyle: "normal",
				fontWeight: "normal"
			},
			animation: !0,
			animationThreshold: 2e3,
			animationDuration: 1e3,
			animationDurationUpdate: 300,
			animationEasing: "exponentialOut",
			animationEasingUpdate: "cubicOut"
		}
	}), e("zrender/tool/path", [ve, "../graphic/Path", "../core/PathProxy", "./transformPath", "../core/matrix"], function(t) {
		function e(t, e, i, n, r, a, o, s, l, f, p) {
			var g = l * (d / 180),
				y = h(g) * (t - i) / 2 + c(g) * (e - n) / 2,
				x = -1 * c(g) * (t - i) / 2 + h(g) * (e - n) / 2,
				_ = y * y / (o * o) + x * x / (s * s);
			_ > 1 && (o *= u(_), s *= u(_));
			var b = (r === a ? -1 : 1) * u((o * o * s * s - o * o * x * x - s * s * y * y) / (o * o * x * x + s * s * y * y)) || 0,
				w = b * o * x / s,
				M = b * -s * y / o,
				S = (t + i) / 2 + h(g) * w - c(g) * M,
				A = (e + n) / 2 + c(g) * w + h(g) * M,
				C = v([1, 0], [(y - w) / o, (x - M) / s]),
				L = [(y - w) / o, (x - M) / s],
				k = [(-1 * y - w) / o, (-1 * x - M) / s],
				z = v(L, k);
			m(L, k) <= -1 && (z = d), m(L, k) >= 1 && (z = 0), 0 === a && z > 0 && (z -= 2 * d), 1 === a && 0 > z && (z += 2 * d), p.addData(f, S, A, o, s, C, z, g, a)
		}

		function i(t) {
			if (!t) return [];
			var i, n = t[F](/-/g, " -")[F](/  /g, " ")[F](/ /g, ",")[F](/,,/g, ",");
			for (i = 0; i < l[$]; i++) n = n[F](new RegExp(l[i], "g"), "|" + l[i]);
			var r, o = n.split("|"),
				s = 0,
				u = 0,
				c = new a,
				h = a.CMD;
			for (i = 1; i < o[$]; i++) {
				var d, f = o[i],
					p = f.charAt(0),
					m = 0,
					v = f.slice(1)[F](/e,-/g, "e-").split(",");
				v[$] > 0 && "" === v[0] && v.shift();
				for (var g = 0; g < v[$]; g++) v[g] = parseFloat(v[g]);
				for (; m < v[$] && !isNaN(v[m]) && !isNaN(v[0]);) {
					var y, x, _, b, w, M, S, A = s,
						C = u;
					switch (p) {
						case "l":
							s += v[m++], u += v[m++], d = h.L, c.addData(d, s, u);
							break;
						case "L":
							s = v[m++], u = v[m++], d = h.L, c.addData(d, s, u);
							break;
						case "m":
							s += v[m++], u += v[m++], d = h.M, c.addData(d, s, u), p = "l";
							break;
						case "M":
							s = v[m++], u = v[m++], d = h.M, c.addData(d, s, u), p = "L";
							break;
						case "h":
							s += v[m++], d = h.L, c.addData(d, s, u);
							break;
						case "H":
							s = v[m++], d = h.L, c.addData(d, s, u);
							break;
						case "v":
							u += v[m++], d = h.L, c.addData(d, s, u);
							break;
						case "V":
							u = v[m++], d = h.L, c.addData(d, s, u);
							break;
						case "C":
							d = h.C, c.addData(d, v[m++], v[m++], v[m++], v[m++], v[m++], v[m++]), s = v[m - 2], u = v[m - 1];
							break;
						case "c":
							d = h.C, c.addData(d, v[m++] + s, v[m++] + u, v[m++] + s, v[m++] + u, v[m++] + s, v[m++] + u), s += v[m - 2], u += v[m - 1];
							break;
						case "S":
							y = s, x = u;
							var L = c.len(),
								k = c.data;
							r === h.C && (y += s - k[L - 4], x += u - k[L - 3]), d = h.C, A = v[m++], C = v[m++], s = v[m++], u = v[m++], c.addData(d, y, x, A, C, s, u);
							break;
						case "s":
							y = s, x = u;
							var L = c.len(),
								k = c.data;
							r === h.C && (y += s - k[L - 4], x += u - k[L - 3]), d = h.C, A = s + v[m++], C = u + v[m++], s += v[m++], u += v[m++], c.addData(d, y, x, A, C, s, u);
							break;
						case "Q":
							A = v[m++], C = v[m++], s = v[m++], u = v[m++], d = h.Q, c.addData(d, A, C, s, u);
							break;
						case "q":
							A = v[m++] + s, C = v[m++] + u, s += v[m++], u += v[m++], d = h.Q, c.addData(d, A, C, s, u);
							break;
						case "T":
							y = s, x = u;
							var L = c.len(),
								k = c.data;
							r === h.Q && (y += s - k[L - 4], x += u - k[L - 3]), s = v[m++], u = v[m++], d = h.Q, c.addData(d, y, x, s, u);
							break;
						case "t":
							y = s, x = u;
							var L = c.len(),
								k = c.data;
							r === h.Q && (y += s - k[L - 4], x += u - k[L - 3]), s += v[m++], u += v[m++], d = h.Q, c.addData(d, y, x, s, u);
							break;
						case "A":
							_ = v[m++], b = v[m++], w = v[m++], M = v[m++], S = v[m++], A = s, C = u, s = v[m++], u = v[m++], d = h.A, e(A, C, s, u, M, S, _, b, w, d, c);
							break;
						case "a":
							_ = v[m++], b = v[m++], w = v[m++], M = v[m++], S = v[m++], A = s, C = u, s += v[m++], u += v[m++], d = h.A, e(A, C, s, u, M, S, _, b, w, d, c)
					}
				}("z" === p || "Z" === p) && (d = h.Z, c.addData(d)), r = d
			}
			return c.toStatic(), c
		}

		function n(t, e) {
			var n, r = i(t);
			return e = e || {}, e.buildPath = function(t) {
				t.setData(r.data), n && o(t, n);
				var e = t[M]();
				e && t.rebuildPath(e)
			}, e[p] = function(t) {
				n || (n = s[re]()), s.mul(n, t, n)
			}, e
		}
		var r = t("../graphic/Path"),
			a = t("../core/PathProxy"),
			o = t("./transformPath"),
			s = t("../core/matrix"),
			l = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"],
			u = Math.sqrt,
			c = Math.sin,
			h = Math.cos,
			d = Math.PI,
			f = function(t) {
				return Math.sqrt(t[0] * t[0] + t[1] * t[1])
			},
			m = function(t, e) {
				return (t[0] * e[0] + t[1] * e[1]) / (f(t) * f(e))
			},
			v = function(t, e) {
				return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(m(t, e))
			};
		return {
			createFromString: function(t, e) {
				return new r(n(t, e))
			},
			extendFromString: function(t, e) {
				return r[te](n(t, e))
			},
			mergePath: function(t, e) {
				var i, n, a = [],
					o = t[$];
				for (n = 0; o > n; n++) i = t[n], i.__dirty && i.buildPath(i.path, i.shape), a.push(i.path);
				var s = new r(e);
				return s.buildPath = function(t) {
					t.appendPath(a);
					var e = t[M]();
					e && t.rebuildPath(e)
				}, s
			}
		}
	}), e("zrender/graphic/Path", [ve, "./Displayable", l, "../core/PathProxy", "../contain/path", "./Gradient"], function(t) {
		function e(t) {
			var e = t.fill;
			return null != e && "none" !== e
		}

		function i(t) {
			var e = t.stroke;
			return null != e && "none" !== e && t.lineWidth > 0
		}

		function n(t) {
			r.call(this, t), this.path = new o
		}
		var r = t("./Displayable"),
			a = t(l),
			o = t("../core/PathProxy"),
			s = t("../contain/path"),
			u = t("./Gradient"),
			c = Math.abs;
		return n[de] = {
			constructor: n,
			type: "path",
			__dirtyPath: !0,
			strokeContainThreshold: 5,
			brush: function(t) {
				t.save();
				var n = this.style,
					r = this.path,
					a = i(n),
					o = e(n);
				this.__dirtyPath && (o && n.fill instanceof u && n.fill.updateCanvasGradient(this, t), a && n.stroke instanceof u && n.stroke.updateCanvasGradient(this, t)), n.bind(t, this), this.setTransform(t);
				var s = n.lineDash,
					l = n.lineDashOffset,
					c = !!t.setLineDash;
				this.__dirtyPath || s && !c && a ? (r = this.path.beginPath(t), s && !c && (r.setLineDash(s), r.setLineDashOffset(l)), this.buildPath(r, this.shape), this.__dirtyPath = !1) : (t.beginPath(), this.path.rebuildPath(t)), o && r.fill(t), s && c && (t.setLineDash(s), t.lineDashOffset = l), a && r.stroke(t), null != n.text && this.drawRectText(t, this[P]()), t.restore()
			},
			buildPath: function() {},
			getBoundingRect: function() {
				var t = this._rect,
					n = this.style,
					r = !t;
				if (r) {
					var a = this.path;
					this.__dirtyPath && (a.beginPath(), this.buildPath(a, this.shape)), t = a[P]()
				}
				if (this._rect = t, i(n)) {
					var o = this._rectWithStroke;
					if (this.__dirty || r) {
						var o = this._rectWithStroke || (this._rectWithStroke = t.clone());
						o.copy(t);
						var s = n.lineWidth,
							l = n.strokeNoScale ? this.getLineScale() : 1;
						e(n) || (s = Math.max(s, this.strokeContainThreshold)), l > 1e-10 && (o.width += s / l, o[ae] += s / l, o.x -= s / l / 2, o.y -= s / l / 2)
					}
					return o
				}
				return t
			},
			contain: function(t, n) {
				var r = this.transformCoordToLocal(t, n),
					a = this[P](),
					o = this.style;
				if (t = r[0], n = r[1], a[S](t, n)) {
					var l = this.path.data;
					if (i(o)) {
						var u = o.lineWidth,
							c = o.strokeNoScale ? this.getLineScale() : 1;
						if (c > 1e-10 && (e(o) || (u = Math.max(u, this.strokeContainThreshold)), s.containStroke(l, u / c, t, n))) return !0
					}
					if (e(o)) return s[S](l, t, n)
				}
				return !1
			},
			dirty: function(t) {
				0 === arguments[$] && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty()
			},
			animateShape: function(t) {
				return this.animate("shape", t)
			},
			attrKV: function(t, e) {
				"shape" === t ? this.setShape(e) : r[de].attrKV.call(this, t, e)
			},
			setShape: function(t, e) {
				var i = this.shape;
				if (i) {
					if (a[ie](t))
						for (var n in t) i[n] = t[n];
					else i[t] = e;
					this.dirty(!0)
				}
				return this
			},
			getLineScale: function() {
				var t = this.transform;
				return t && c(t[0] - 1) > 1e-10 && c(t[3] - 1) > 1e-10 ? Math.sqrt(c(t[0] * t[3] - t[2] * t[1])) : 1
			}
		}, n[te] = function(t) {
			var e = function(e) {
				n.call(this, e), t.style && this.style.extendFrom(t.style, !1);
				var i = t.shape;
				if (i) {
					this.shape = this.shape || {};
					var r = this.shape;
					for (var a in i) !r.hasOwnProperty(a) && i.hasOwnProperty(a) && (r[a] = i[a])
				}
				t.init && t.init.call(this, e)
			};
			a[B](e, n);
			for (var i in t) "style" !== i && "shape" !== i && (e[de][i] = t[i]);
			return e
		}, a[B](n, r), n
	}), e("zrender/container/Group", [ve, l, "../Element", "../core/BoundingRect"], function(t) {
		var e = t(l),
			i = t("../Element"),
			n = t("../core/BoundingRect"),
			r = function(t) {
				t = t || {}, i.call(this, t);
				for (var e in t) this[e] = t[e];
				this._children = [], this.__storage = null, this.__dirty = !0
			};
		return r[de] = {
			constructor: r,
			type: "group",
			children: function() {
				return this._children.slice()
			},
			childAt: function(t) {
				return this._children[t]
			},
			childOfName: function(t) {
				for (var e = this._children, i = 0; i < e[$]; i++)
					if (e[i].name === t) return e[i]
			},
			childCount: function() {
				return this._children[$]
			},
			add: function(t) {
				return t && t !== this && t[c] !== this && (this._children.push(t), this._doAdd(t)), this
			},
			addBefore: function(t, e) {
				if (t && t !== this && t[c] !== this && e && e[c] === this) {
					var i = this._children,
						n = i[N](e);
					n >= 0 && (i[X](n, 0, t), this._doAdd(t))
				}
				return this
			},
			_doAdd: function(t) {
				t[c] && t[c][ee](t), t[c] = this;
				var e = this.__storage,
					i = this.__zr;
				e && e !== t.__storage && (e.addToMap(t), t instanceof r && t.addChildrenToStorage(e)), i && i.refresh()
			},
			remove: function(t) {
				var i = this.__zr,
					n = this.__storage,
					a = this._children,
					o = e[N](a, t);
				return 0 > o ? this : (a[X](o, 1), t[c] = null, n && (n.delFromMap(t.id), t instanceof r && t.delChildrenFromStorage(n)), i && i.refresh(), this)
			},
			removeAll: function() {
				var t, e, i = this._children,
					n = this.__storage;
				for (e = 0; e < i[$]; e++) t = i[e], n && (n.delFromMap(t.id), t instanceof r && t.delChildrenFromStorage(n)), t[c] = null;
				return i[$] = 0, this
			},
			eachChild: function(t, e) {
				for (var i = this._children, n = 0; n < i[$]; n++) {
					var r = i[n];
					t.call(e, r, n)
				}
				return this
			},
			traverse: function(t, e) {
				for (var i = 0; i < this._children[$]; i++) {
					var n = this._children[i];
					t.call(e, n), "group" === n.type && n.traverse(t, e)
				}
				return this
			},
			addChildrenToStorage: function(t) {
				for (var e = 0; e < this._children[$]; e++) {
					var i = this._children[e];
					t.addToMap(i), i instanceof r && i.addChildrenToStorage(t)
				}
			},
			delChildrenFromStorage: function(t) {
				for (var e = 0; e < this._children[$]; e++) {
					var i = this._children[e];
					t.delFromMap(i.id), i instanceof r && i.delChildrenFromStorage(t)
				}
			},
			dirty: function() {
				return this.__dirty = !0, this.__zr && this.__zr.refresh(), this
			},
			getBoundingRect: function(t) {
				for (var e = null, i = new n(0, 0, 0, 0), r = t || this._children, a = [], o = 0; o < r[$]; o++) {
					var s = r[o];
					if (!s[se] && !s.invisible) {
						var l = s[P](),
							u = s.getLocalTransform(a);
						u ? (i.copy(l), i[p](u), e = e || i.clone(), e.union(i)) : (e = e || l.clone(), e.union(l))
					}
				}
				return e || i
			}
		}, e[B](r, i), r
	}), e("zrender/graphic/Image", [ve, "./Displayable", "../core/BoundingRect", l, "./helper/roundRect", "../core/LRU"], function(t) {
		function e(t) {
			i.call(this, t)
		}
		var i = t("./Displayable"),
			n = t("../core/BoundingRect"),
			r = t(l),
			a = t("./helper/roundRect"),
			o = t("../core/LRU"),
			s = new o(50);
		return e[de] = {
			constructor: e,
			type: "image",
			brush: function(t) {
				var e, i = this.style,
					n = i.image;
				if (e = typeof n === he ? this._image : n, !e && n) {
					var r = s.get(n);
					if (!r) return e = new Image, e.onload = function() {
						e.onload = null;
						for (var t = 0; t < r.pending[$]; t++) r.pending[t].dirty()
					}, r = {
						image: e,
						pending: [this]
					}, e.src = n, s.put(n, r), void(this._image = e);
					if (e = r.image, this._image = e, !e.width || !e[ae]) return void r.pending.push(this)
				}
				if (e) {
					var o = i.width || e.width,
						l = i[ae] || e[ae],
						u = i.x || 0,
						c = i.y || 0;
					if (!e.width || !e[ae]) return;
					if (t.save(), i.bind(t), this.setTransform(t), i.r && (t.beginPath(), a.buildPath(t, i), t.clip()), i.sWidth && i.sHeight) {
						var h = i.sx || 0,
							d = i.sy || 0;
						t.drawImage(e, h, d, i.sWidth, i.sHeight, u, c, o, l)
					} else if (i.sx && i.sy) {
						var h = i.sx,
							d = i.sy,
							f = o - h,
							p = l - d;
						t.drawImage(e, h, d, f, p, u, c, o, l)
					} else t.drawImage(e, u, c, o, l);
					null == i.width && (i.width = o), null == i[ae] && (i[ae] = l), null != i.text && this.drawRectText(t, this[P]()), t.restore()
				}
			},
			getBoundingRect: function() {
				var t = this.style;
				return this._rect || (this._rect = new n(t.x || 0, t.y || 0, t.width || 0, t[ae] || 0)), this._rect
			}
		}, r[B](e, i), e
	}), e("zrender/graphic/Text", [ve, "./Displayable", l, "../contain/text"], function(t) {
		var e = t("./Displayable"),
			i = t(l),
			n = t("../contain/text"),
			r = function(t) {
				e.call(this, t)
			};
		return r[de] = {
			constructor: r,
			type: "text",
			brush: function(t) {
				var e = this.style,
					i = e.x || 0,
					r = e.y || 0,
					a = e.text,
					o = e.fill,
					s = e.stroke;
				if (null != a && (a += ""), a) {
					if (t.save(), this.style.bind(t), this.setTransform(t), o && (t.fillStyle = o), s && (t.strokeStyle = s), t.font = e.textFont || e.font, t[I] = e[I], e.textVerticalAlign) {
						var l = n[P](a, t.font, e[I], "top");
						switch (t.textBaseline = "top", e.textVerticalAlign) {
							case z:
								r -= l[ae] / 2;
								break;
							case oe:
								r -= l[ae]
						}
					} else t.textBaseline = e.textBaseline;
					for (var u = n.measureText("国", t.font).width, c = a.split("\n"), h = 0; h < c[$]; h++) o && t.fillText(c[h], i, r), s && t.strokeText(c[h], i, r), r += u;
					t.restore()
				}
			},
			getBoundingRect: function() {
				if (!this._rect) {
					var t = this.style,
						e = t.textVerticalAlign,
						i = n[P](t.text + "", t.textFont || t.font, t[I], e ? "top" : t.textBaseline);
					switch (e) {
						case z:
							i.y -= i[ae] / 2;
							break;
						case oe:
							i.y -= i[ae]
					}
					i.x += t.x || 0, i.y += t.y || 0, this._rect = i
				}
				return this._rect
			}
		}, i[B](r, e), r
	}), e("zrender/graphic/shape/Circle", [ve, "../Path"], function(t) {
		return t("../Path")[te]({
			type: "circle",
			shape: {
				cx: 0,
				cy: 0,
				r: 0
			},
			buildPath: function(t, e) {
				t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0)
			}
		})
	}), e("zrender/graphic/shape/Sector", [ve, "../Path"], function(t) {
		return t("../Path")[te]({
			type: "sector",
			shape: {
				cx: 0,
				cy: 0,
				r0: 0,
				r: 0,
				startAngle: 0,
				endAngle: 2 * Math.PI,
				clockwise: !0
			},
			buildPath: function(t, e) {
				var i = e.cx,
					n = e.cy,
					r = Math.max(e.r0 || 0, 0),
					a = Math.max(e.r, 0),
					o = e.startAngle,
					s = e.endAngle,
					l = e.clockwise,
					u = Math.cos(o),
					c = Math.sin(o);
				t.moveTo(u * r + i, c * r + n), t.lineTo(u * a + i, c * a + n), t.arc(i, n, a, o, s, !l), t.lineTo(Math.cos(s) * r + i, Math.sin(s) * r + n), 0 !== r && t.arc(i, n, r, s, o, l), t.closePath()
			}
		})
	}), e("zrender/graphic/shape/Ring", [ve, "../Path"], function(t) {
		return t("../Path")[te]({
			type: "ring",
			shape: {
				cx: 0,
				cy: 0,
				r: 0,
				r0: 0
			},
			buildPath: function(t, e) {
				var i = e.cx,
					n = e.cy,
					r = 2 * Math.PI;
				t.moveTo(i + e.r, n), t.arc(i, n, e.r, 0, r, !1), t.moveTo(i + e.r0, n), t.arc(i, n, e.r0, 0, r, !0)
			}
		})
	}), e("zrender/graphic/shape/Polygon", [ve, "../helper/poly", "../Path"], function(t) {
		var e = t("../helper/poly");
		return t("../Path")[te]({
			type: "polygon",
			shape: {
				points: null,
				smooth: !1,
				smoothConstraint: null
			},
			buildPath: function(t, i) {
				e.buildPath(t, i, !0)
			}
		})
	}), e("zrender/graphic/shape/Polyline", [ve, "../helper/poly", "../Path"], function(t) {
		var e = t("../helper/poly");
		return t("../Path")[te]({
			type: "polyline",
			shape: {
				points: null,
				smooth: !1,
				smoothConstraint: null
			},
			style: {
				stroke: "#000",
				fill: null
			},
			buildPath: function(t, i) {
				e.buildPath(t, i, !1)
			}
		})
	}), e("zrender/graphic/shape/Rect", [ve, "../helper/roundRect", "../Path"], function(t) {
		var e = t("../helper/roundRect");
		return t("../Path")[te]({
			type: "rect",
			shape: {
				r: 0,
				x: 0,
				y: 0,
				width: 0,
				height: 0
			},
			buildPath: function(t, i) {
				var n = i.x,
					r = i.y,
					a = i.width,
					o = i[ae];
				i.r ? e.buildPath(t, i) : t.rect(n, r, a, o), t.closePath()
			}
		})
	}), e("zrender/graphic/shape/Line", [ve, "../Path"], function(t) {
		return t("../Path")[te]({
			type: "line",
			shape: {
				x1: 0,
				y1: 0,
				x2: 0,
				y2: 0,
				percent: 1
			},
			style: {
				stroke: "#000",
				fill: null
			},
			buildPath: function(t, e) {
				var i = e.x1,
					n = e.y1,
					r = e.x2,
					a = e.y2,
					o = e.percent;
				0 !== o && (t.moveTo(i, n), 1 > o && (r = i * (1 - o) + r * o, a = n * (1 - o) + a * o), t.lineTo(r, a))
			},
			pointAt: function(t) {
				var e = this.shape;
				return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t]
			}
		})
	}), e("zrender/graphic/shape/BezierCurve", [ve, "../../core/curve", "../Path"], function(t) {
		var e = t("../../core/curve"),
			i = e.quadraticSubdivide,
			n = e.cubicSubdivide,
			r = e.quadraticAt,
			a = e.cubicAt,
			o = [];
		return t("../Path")[te]({
			type: "bezier-curve",
			shape: {
				x1: 0,
				y1: 0,
				x2: 0,
				y2: 0,
				cpx1: 0,
				cpy1: 0,
				percent: 1
			},
			style: {
				stroke: "#000",
				fill: null
			},
			buildPath: function(t, e) {
				var r = e.x1,
					a = e.y1,
					s = e.x2,
					l = e.y2,
					u = e.cpx1,
					c = e.cpy1,
					h = e.cpx2,
					d = e.cpy2,
					f = e.percent;
				0 !== f && (t.moveTo(r, a), null == h || null == d ? (1 > f && (i(r, u, s, f, o), u = o[1], s = o[2], i(a, c, l, f, o), c = o[1], l = o[2]), t.quadraticCurveTo(u, c, s, l)) : (1 > f && (n(r, u, h, s, f, o), u = o[1], h = o[2], s = o[3], n(a, c, d, l, f, o), c = o[1], d = o[2], l = o[3]), t.bezierCurveTo(u, c, h, d, s, l)))
			},
			pointAt: function(t) {
				var e = this.shape,
					i = e.cpx2,
					n = e.cpy2;
				return null === i || null === n ? [r(e.x1, e.cpx1, e.x2, t), r(e.y1, e.cpy1, e.y2, t)] : [a(e.x1, e.cpx1, e.cpx1, e.x2, t), a(e.y1, e.cpy1, e.cpy1, e.y2, t)]
			}
		})
	}), e("zrender/graphic/shape/Arc", [ve, "../Path"], function(t) {
		return t("../Path")[te]({
			type: "arc",
			shape: {
				cx: 0,
				cy: 0,
				r: 0,
				startAngle: 0,
				endAngle: 2 * Math.PI,
				clockwise: !0
			},
			style: {
				stroke: "#000",
				fill: null
			},
			buildPath: function(t, e) {
				var i = e.cx,
					n = e.cy,
					r = Math.max(e.r, 0),
					a = e.startAngle,
					o = e.endAngle,
					s = e.clockwise,
					l = Math.cos(a),
					u = Math.sin(a);
				t.moveTo(l * r + i, u * r + n), t.arc(i, n, r, a, o, !s)
			}
		})
	}), e("zrender/graphic/LinearGradient", [ve, l, "./Gradient"], function(t) {
		var e = t(l),
			i = t("./Gradient"),
			n = function(t, e, n, r, a) {
				this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == n ? 1 : n, this.y2 = null == r ? 0 : r, i.call(this, a)
			};
		return n[de] = {
			constructor: n,
			type: "linear",
			updateCanvasGradient: function(t, e) {
				for (var i = t[P](), n = this.x * i.width + i.x, r = this.x2 * i.width + i.x, a = this.y * i[ae] + i.y, o = this.y2 * i[ae] + i.y, s = e.createLinearGradient(n, a, r, o), l = this.colorStops, u = 0; u < l[$]; u++) s.addColorStop(l[u].offset, l[u].color);
				this.canvasGradient = s
			}
		}, e[B](n, i), n
	}), e("zrender/graphic/RadialGradient", [ve, l, "./Gradient"], function(t) {
		var e = t(l),
			i = t("./Gradient"),
			n = function(t, e, n, r) {
				this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == n ? .5 : n, i.call(this, r)
			};
		return n[de] = {
			constructor: n,
			type: "radial",
			updateCanvasGradient: function(t, e) {
				for (var i = t[P](), n = i.width, r = i[ae], a = Math.min(n, r), o = this.x * n + i.x, s = this.y * r + i.y, l = this.r * a, u = e.createRadialGradient(o, s, 0, o, s, l), c = this.colorStops, h = 0; h < c[$]; h++) u.addColorStop(c[h].offset, c[h].color);
				this.canvasGradient = u
			}
		}, e[B](n, i), n
	}), e("zrender/core/BoundingRect", [ve, "./vector", "./matrix"], function(t) {
		function e(t, e, i, n) {
			this.x = t, this.y = e, this.width = i, this[ae] = n
		}
		var i = t("./vector"),
			n = t("./matrix"),
			r = i[p],
			a = Math.min,
			o = Math.abs,
			s = Math.max;
		return e[de] = {
			constructor: e,
			union: function(t) {
				var e = a(t.x, this.x),
					i = a(t.y, this.y);
				this.width = s(t.x + t.width, this.x + this.width) - e, this[ae] = s(t.y + t[ae], this.y + this[ae]) - i, this.x = e, this.y = i
			},
			applyTransform: function() {
				var t = [],
					e = [];
				return function(i) {
					i && (t[0] = this.x, t[1] = this.y, e[0] = this.x + this.width, e[1] = this.y + this[ae], r(t, t, i), r(e, e, i), this.x = a(t[0], e[0]), this.y = a(t[1], e[1]), this.width = o(e[0] - t[0]), this[ae] = o(e[1] - t[1]))
				}
			}(),
			calculateTransform: function(t) {
				var e = this,
					i = t.width / e.width,
					r = t[ae] / e[ae],
					a = n[re]();
				return n.translate(a, a, [-e.x, -e.y]), n.scale(a, a, [i, r]), n.translate(a, a, [t.x, t.y]), a
			},
			intersect: function(t) {
				var e = this,
					i = e.x,
					n = e.x + e.width,
					r = e.y,
					a = e.y + e[ae],
					o = t.x,
					s = t.x + t.width,
					l = t.y,
					u = t.y + t[ae];
				return !(o > n || i > s || l > a || r > u)
			},
			contain: function(t, e) {
				var i = this;
				return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i[ae]
			},
			clone: function() {
				return new e(this.x, this.y, this.width, this[ae])
			},
			copy: function(t) {
				this.x = t.x, this.y = t.y, this.width = t.width, this[ae] = t[ae]
			}
		}, e
	}), e("echarts/util/component", [ve, me, "./clazz"], function(t) {
		var e = t(me),
			i = t("./clazz"),
			n = i.parseClassType,
			r = 0,
			a = {},
			o = "_";
		return a.getUID = function(t) {
			return [t || "", r++, Math.random()].join(o)
		}, a.enableSubTypeDefaulter = function(t) {
			var e = {};
			return t.registerSubTypeDefaulter = function(t, i) {
				t = n(t), e[t.main] = i
			}, t.determineSubType = function(i, r) {
				var a = r.type;
				if (!a) {
					var o = n(i).main;
					t.hasSubTypes(i) && e[o] && (a = e[o](r))
				}
				return a
			}, t
		}, a.enableTopologicalTravel = function(t, i) {
			function n(t) {
				var n = {},
					o = [];
				return e.each(t, function(s) {
					var l = r(n, s),
						u = l.originalDeps = i(s),
						c = a(u, t);
					l.entryCount = c[$], 0 === l.entryCount && o.push(s), e.each(c, function(t) {
						e[N](l.predecessor, t) < 0 && l.predecessor.push(t);
						var i = r(n, t);
						e[N](i.successor, t) < 0 && i.successor.push(s)
					})
				}), {
					graph: n,
					noEntryList: o
				}
			}

			function r(t, e) {
				return t[e] || (t[e] = {
					predecessor: [],
					successor: []
				}), t[e]
			}

			function a(t, i) {
				var n = [];
				return e.each(t, function(t) {
					e[N](i, t) >= 0 && n.push(t)
				}), n
			}
			t.topologicalTravel = function(t, i, r, a) {
				function o(t) {
					u[t].entryCount--, 0 === u[t].entryCount && c.push(t)
				}

				function s(t) {
					h[t] = !0, o(t)
				}
				if (t[$]) {
					var l = n(i),
						u = l.graph,
						c = l.noEntryList,
						h = {};
					for (e.each(t, function(t) {
							h[t] = !0
						}); c[$];) {
						var d = c.pop(),
							f = u[d],
							p = !!h[d];
						p && (r.call(a, d, f.originalDeps.slice()), delete h[d]), e.each(f.successor, p ? s : o)
					}
					e.each(h, function() {
						throw new Error("Circle dependency may exists")
					})
				}
			}
		}, a
	}), e("echarts/util/clazz", [ve, me], function(t) {
		function e(t, e) {
			var i = n.slice(arguments, 2);
			return this.superClass[de][e].apply(t, i)
		}

		function i(t, e, i) {
			return this.superClass[de][e].apply(t, i)
		}
		var n = t(me),
			r = {},
			a = ".",
			o = "___EC__COMPONENT__CONTAINER___",
			s = r.parseClassType = function(t) {
				var e = {
					main: "",
					sub: ""
				};
				return t && (t = t.split(a), e.main = t[0] || "", e.sub = t[1] || ""), e
			};
		return r.enableClassExtend = function(t, r) {
			t[te] = function(a) {
				var o = function() {
					r && r.apply(this, arguments), t.apply(this, arguments)
				};
				return n[te](o[de], a), o[te] = this[te], o.superCall = e, o.superApply = i, n[B](o, this), o.superClass = this, o
			}
		}, r.enableClassManagement = function(t, e) {
			function i(t) {
				var e = r[t.main];
				return e && e[o] || (e = r[t.main] = {}, e[o] = !0), e
			}
			e = e || {};
			var r = {};
			if (t.registerClass = function(t, e) {
					if (e)
						if (e = s(e), e.sub) {
							if (e.sub !== o) {
								var n = i(e);
								n[e.sub] = t
							}
						} else {
							if (r[e.main]) throw new Error(e.main + "exists.");
							r[e.main] = t
						}
					return t
				}, t.getClass = function(t, e, i) {
					var n = r[t];
					if (n && n[o] && (n = e ? n[e] : null), i && !n) throw new Error("Component " + t + "." + (e || "") + " not exists. Load it first.");
					return n
				}, t.getClassesByMainType = function(t) {
					t = s(t);
					var e = [],
						i = r[t.main];
					return i && i[o] ? n.each(i, function(t, i) {
						i !== o && e.push(t)
					}) : e.push(i), e
				}, t.hasClass = function(t) {
					return t = s(t), !!r[t.main]
				}, t.getAllClassMainTypes = function() {
					var t = [];
					return n.each(r, function(e, i) {
						t.push(i)
					}), t
				}, t.hasSubTypes = function(t) {
					t = s(t);
					var e = r[t.main];
					return e && e[o]
				}, t.parseClassType = s, e.registerWhenExtend) {
				var a = t[te];
				a && (t[te] = function(e) {
					var i = a.call(this, e);
					return t.registerClass(i, e.type)
				})
			}
			return t
		}, r.setReadOnly = function() {}, r
	}), e("echarts/model/mixin/boxLayout", [ve], function() {
		return {
			getBoxLayoutParams: function() {
				return {
					left: this.get("left"),
					top: this.get("top"),
					right: this.get("right"),
					bottom: this.get(oe),
					width: this.get("width"),
					height: this.get(ae)
				}
			}
		}
	}), e("echarts/model/mixin/lineStyle", [ve, "./makeStyleMapper"], function(t) {
		var e = t("./makeStyleMapper")([
			["lineWidth", "width"],
			["stroke", "color"],
			[C],
			["shadowBlur"],
			["shadowOffsetX"],
			["shadowOffsetY"],
			["shadowColor"]
		]);
		return {
			getLineStyle: function(t) {
				var i = e.call(this, t),
					n = this.getLineDash();
				return n && (i.lineDash = n), i
			},
			getLineDash: function() {
				var t = this.get("type");
				return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1]
			}
		}
	}), e("echarts/model/mixin/areaStyle", [ve, "./makeStyleMapper"], function(t) {
		return {
			getAreaStyle: t("./makeStyleMapper")([
				["fill", "color"],
				["shadowBlur"],
				["shadowOffsetX"],
				["shadowOffsetY"],
				[C],
				["shadowColor"]
			])
		}
	}), e("echarts/model/mixin/textStyle", [ve, "zrender/contain/text"], function(t) {
		function e(t, e) {
			return t && t[h](e)
		}
		var i = t("zrender/contain/text");
		return {
			getTextColor: function() {
				var t = this[m];
				return this[h]("color") || t && t.get("textStyle.color")
			},
			getFont: function() {
				var t = this[m],
					i = t && t[ce](O);
				return [this[h]("fontStyle") || e(i, "fontStyle"), this[h]("fontWeight") || e(i, "fontWeight"), (this[h]("fontSize") || e(i, "fontSize") || 12) + "px", this[h]("fontFamily") || e(i, "fontFamily") || "sans-serif"].join(" ")
			},
			getTextRect: function(t) {
				var e = this.get(O) || {};
				return i[P](t, this[D](), e.align, e.baseline)
			},
			ellipsis: function(t, e, n) {
				return i.ellipsis(t, this[D](), e, n)
			}
		}
	}), e("echarts/model/mixin/itemStyle", [ve, "./makeStyleMapper"], function(t) {
		return {
			getItemStyle: t("./makeStyleMapper")([
				["fill", "color"],
				["stroke", "borderColor"],
				["lineWidth", "borderWidth"],
				[C],
				["shadowBlur"],
				["shadowOffsetX"],
				["shadowOffsetY"],
				["shadowColor"]
			])
		}
	}), e("zrender/core/PathProxy", [ve, "./curve", "./vector", "./bbox", "./BoundingRect"], function(t) {
		var e = t("./curve"),
			i = t("./vector"),
			n = t("./bbox"),
			r = t("./BoundingRect"),
			a = {
				M: 1,
				L: 2,
				C: 3,
				Q: 4,
				A: 5,
				Z: 6,
				R: 7
			},
			o = [],
			s = [],
			l = [],
			c = [],
			h = Math.min,
			d = Math.max,
			f = Math.cos,
			p = Math.sin,
			m = Math.sqrt,
			v = typeof Float32Array != u,
			g = function() {
				this.data = [], this._len = 0, this._ctx = null, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0
			};
		return g[de] = {
			constructor: g,
			_lineDash: null,
			_dashOffset: 0,
			_dashIdx: 0,
			_dashSum: 0,
			getContext: function() {
				return this._ctx
			},
			beginPath: function(t) {
				return this._ctx = t, t && t.beginPath(), this._len = 0, this._lineDash && (this._lineDash = null, this._dashOffset = 0), this
			},
			moveTo: function(t, e) {
				return this.addData(a.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this
			},
			lineTo: function(t, e) {
				return this.addData(a.L, t, e), this._ctx && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), this._xi = t, this._yi = e, this
			},
			bezierCurveTo: function(t, e, i, n, r, o) {
				return this.addData(a.C, t, e, i, n, r, o), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, r, o) : this._ctx.bezierCurveTo(t, e, i, n, r, o)), this._xi = r, this._yi = o, this
			},
			quadraticCurveTo: function(t, e, i, n) {
				return this.addData(a.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), this._xi = i, this._yi = n, this
			},
			arc: function(t, e, i, n, r, o) {
				return this.addData(a.A, t, e, i, i, n, r - n, 0, o ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, r, o), this._xi = f(r) * i + t, this._xi = p(r) * i + t, this
			},
			arcTo: function(t, e, i, n, r) {
				return this._ctx && this._ctx.arcTo(t, e, i, n, r), this
			},
			rect: function(t, e, i, n) {
				return this._ctx && this._ctx.rect(t, e, i, n), this.addData(a.R, t, e, i, n), this
			},
			closePath: function() {
				this.addData(a.Z);
				var t = this._ctx,
					e = this._x0,
					i = this._y0;
				return t && (this._needsDash() && this._dashedLineTo(e, i), t.closePath()), this._xi = e, this._yi = i, this
			},
			fill: function(t) {
				t && t.fill(), this.toStatic()
			},
			stroke: function(t) {
				t && t.stroke(), this.toStatic()
			},
			setLineDash: function(t) {
				if (t instanceof Array) {
					this._lineDash = t, this._dashIdx = 0;
					for (var e = 0, i = 0; i < t[$]; i++) e += t[i];
					this._dashSum = e
				}
				return this
			},
			setLineDashOffset: function(t) {
				return this._dashOffset = t, this
			},
			len: function() {
				return this._len
			},
			setData: function(t) {
				var e = t[$];
				this.data && this.data[$] == e || !v || (this.data = new Float32Array(e));
				for (var i = 0; e > i; i++) this.data[i] = t[i];
				this._len = e
			},
			appendPath: function(t) {
				t instanceof Array || (t = [t]);
				for (var e = t[$], i = 0, n = this._len, r = 0; e > r; r++) i += t[r].len();
				v && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));
				for (var r = 0; e > r; r++)
					for (var a = t[r].data, o = 0; o < a[$]; o++) this.data[n++] = a[o];
				this._len = n
			},
			addData: function(t) {
				var e = this.data;
				this._len + arguments[$] > e[$] && (this._expandData(), e = this.data);
				for (var i = 0; i < arguments[$]; i++) e[this._len++] = arguments[i];
				this._prevCmd = t
			},
			_expandData: function() {
				if (!(this.data instanceof Array)) {
					for (var t = [], e = 0; e < this._len; e++) t[e] = this.data[e];
					this.data = t
				}
			},
			_needsDash: function() {
				return this._lineDash
			},
			_dashedLineTo: function(t, e) {
				var i, n, r = this._dashSum,
					a = this._dashOffset,
					o = this._lineDash,
					s = this._ctx,
					l = this._xi,
					u = this._yi,
					c = t - l,
					f = e - u,
					p = m(c * c + f * f),
					v = l,
					g = u,
					y = o[$];
				for (c /= p, f /= p, 0 > a && (a = r + a), a %= r, v -= a * c, g -= a * f; c >= 0 && t >= v || 0 > c && v > t;) n = this._dashIdx, i = o[n], v += c * i, g += f * i, this._dashIdx = (n + 1) % y, c > 0 && l > v || 0 > c && v > l || s[n % 2 ? "moveTo" : "lineTo"](c >= 0 ? h(v, t) : d(v, t), f >= 0 ? h(g, e) : d(g, e));
				c = v - t, f = g - e, this._dashOffset = -m(c * c + f * f)
			},
			_dashedBezierTo: function(t, i, n, r, a, o) {
				var s, l, u, c, h, d = this._dashSum,
					f = this._dashOffset,
					p = this._lineDash,
					v = this._ctx,
					g = this._xi,
					y = this._yi,
					x = e.cubicAt,
					_ = 0,
					b = this._dashIdx,
					w = p[$],
					M = 0;
				for (0 > f && (f = d + f), f %= d, s = 0; 1 > s; s += .1) l = x(g, t, n, a, s + .1) - x(g, t, n, a, s), u = x(y, i, r, o, s + .1) - x(y, i, r, o, s), _ += m(l * l + u * u);
				for (; w > b && (M += p[b], !(M > f)); b++);
				for (s = (M - f) / _; 1 >= s;) c = x(g, t, n, a, s), h = x(y, i, r, o, s), b % 2 ? v.moveTo(c, h) : v.lineTo(c, h), s += p[b] / _, b = (b + 1) % w;
				b % 2 !== 0 && v.lineTo(a, o), l = a - c, u = o - h, this._dashOffset = -m(l * l + u * u)
			},
			_dashedQuadraticTo: function(t, e, i, n) {
				var r = i,
					a = n;
				i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, i, n, r, a)
			},
			toStatic: function() {
				var t = this.data;
				t instanceof Array && (t[$] = this._len, v && (this.data = new Float32Array(t)))
			},
			getBoundingRect: function() {
				o[0] = o[1] = l[0] = l[1] = Number.MAX_VALUE, s[0] = s[1] = c[0] = c[1] = -Number.MAX_VALUE;
				for (var t = this.data, e = 0, u = 0, h = 0, d = 0, m = 0; m < t[$];) {
					var v = t[m++];
					switch (1 == m && (e = t[m], u = t[m + 1], h = e, d = u), v) {
						case a.M:
							h = t[m++], d = t[m++], e = h, u = d, l[0] = h, l[1] = d, c[0] = h, c[1] = d;
							break;
						case a.L:
							n.fromLine(e, u, t[m], t[m + 1], l, c), e = t[m++], u = t[m++];
							break;
						case a.C:
							n.fromCubic(e, u, t[m++], t[m++], t[m++], t[m++], t[m], t[m + 1], l, c), e = t[m++], u = t[m++];
							break;
						case a.Q:
							n.fromQuadratic(e, u, t[m++], t[m++], t[m], t[m + 1], l, c), e = t[m++], u = t[m++];
							break;
						case a.A:
							var g = t[m++],
								y = t[m++],
								x = t[m++],
								_ = t[m++],
								b = t[m++],
								w = t[m++] + b,
								M = (t[m++], 1 - t[m++]);
							1 == m && (h = f(b) * x + g, d = p(b) * _ + y), n.fromArc(g, y, x, _, b, w, M, l, c), e = f(w) * x + g, u = p(w) * _ + y;
							break;
						case a.R:
							h = e = t[m++], d = u = t[m++];
							var S = t[m++],
								A = t[m++];
							n.fromLine(h, d, h + S, d + A, l, c);
							break;
						case a.Z:
							e = h, u = d
					}
					i.min(o, o, l), i.max(s, s, c)
				}
				return 0 === m && (o[0] = o[1] = s[0] = s[1] = 0), new r(o[0], o[1], s[0] - o[0], s[1] - o[1])
			},
			rebuildPath: function(t) {
				for (var e = this.data, i = 0; i < this._len;) {
					var n = e[i++];
					switch (n) {
						case a.M:
							t.moveTo(e[i++], e[i++]);
							break;
						case a.L:
							t.lineTo(e[i++], e[i++]);
							break;
						case a.C:
							t.bezierCurveTo(e[i++], e[i++], e[i++], e[i++], e[i++], e[i++]);
							break;
						case a.Q:
							t.quadraticCurveTo(e[i++], e[i++], e[i++], e[i++]);
							break;
						case a.A:
							var r = e[i++],
								o = e[i++],
								s = e[i++],
								l = e[i++],
								u = e[i++],
								c = e[i++],
								h = e[i++],
								d = e[i++],
								f = s > l ? s : l,
								p = s > l ? 1 : s / l,
								m = s > l ? l / s : 1,
								v = Math.abs(s - l) > .001;
							v ? (t.translate(r, o), t.rotate(h), t.scale(p, m), t.arc(0, 0, f, u, u + c, 1 - d), t.scale(1 / p, 1 / m), t.rotate(-h), t.translate(-r, -o)) : t.arc(r, o, f, u, u + c, 1 - d);
							break;
						case a.R:
							t.rect(e[i++], e[i++], e[i++], e[i++]);
							break;
						case a.Z:
							t.closePath()
					}
				}
			}
		}, g.CMD = a, g
	}), e("zrender/tool/transformPath", [ve, "../core/PathProxy", "../core/vector"], function(t) {
		function e(t, e) {
			var n, l, u, c, h, d, f = t.data,
				p = i.M,
				m = i.C,
				v = i.L,
				g = i.R,
				y = i.A,
				x = i.Q;
			for (u = 0, c = 0; u < f[$];) {
				switch (n = f[u++], c = u, l = 0, n) {
					case p:
						l = 1;
						break;
					case v:
						l = 1;
						break;
					case m:
						l = 3;
						break;
					case x:
						l = 2;
						break;
					case y:
						var _ = e[4],
							b = e[5],
							w = o(e[0] * e[0] + e[1] * e[1]),
							M = o(e[2] * e[2] + e[3] * e[3]),
							S = s(-e[1] / M, e[0] / w);
						f[u++] += _, f[u++] += b, f[u++] *= w, f[u++] *= M, f[u++] += S, f[u++] += S, u += 2, c = u;
						break;
					case g:
						d[0] = f[u++], d[1] = f[u++], r(d, d, e), f[c++] = d[0], f[c++] = d[1], d[0] += f[u++], d[1] += f[u++], r(d, d, e), f[c++] = d[0], f[c++] = d[1]
				}
				for (h = 0; l > h; h++) {
					var d = a[h];
					d[0] = f[u++], d[1] = f[u++], r(d, d, e), f[c++] = d[0], f[c++] = d[1]
				}
			}
		}
		var i = t("../core/PathProxy").CMD,
			n = t("../core/vector"),
			r = n[p],
			a = [
				[],
				[],
				[]
			],
			o = Math.sqrt,
			s = Math.atan2;
		return e
	}), e("zrender/graphic/Displayable", [ve, l, "./Style", "../Element", "./mixin/RectText"], function(t) {
		function e(t) {
			t = t || {}, r.call(this, t);
			for (var e in t) t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
			this.style = new n(t.style), this._rect = null, this.__clipPaths = []
		}
		var i = t(l),
			n = t("./Style"),
			r = t("../Element"),
			a = t("./mixin/RectText");
		return e[de] = {
			constructor: e,
			type: "displayable",
			__dirty: !0,
			invisible: !1,
			z: 0,
			z2: 0,
			zlevel: 0,
			draggable: !1,
			dragging: !1,
			silent: !1,
			culling: !1,
			cursor: "pointer",
			rectHover: !1,
			beforeBrush: function() {},
			afterBrush: function() {},
			brush: function() {},
			getBoundingRect: function() {},
			contain: function(t, e) {
				return this.rectContain(t, e)
			},
			traverse: function(t, e) {
				t.call(e, this)
			},
			rectContain: function(t, e) {
				var i = this.transformCoordToLocal(t, e),
					n = this[P]();
				return n[S](i[0], i[1])
			},
			dirty: function() {
				this.__dirty = !0, this._rect = null, this.__zr && this.__zr.refresh()
			},
			animateStyle: function(t) {
				return this.animate("style", t)
			},
			attrKV: function(t, e) {
				"style" !== t ? r[de].attrKV.call(this, t, e) : this.style.set(e)
			},
			setStyle: function(t, e) {
				return this.style.set(t, e), this.dirty(!1), this
			}
		}, i[B](e, r), i.mixin(e, a), e
	}), e("zrender/contain/path", [ve, "../core/PathProxy", "./line", "./cubic", "./quadratic", "./arc", "./util", "../core/curve", "./windingLine"], function(t) {
		function e(t, e) {
			return Math.abs(t - e) < g
		}

		function i() {
			var t = x[0];
			x[0] = x[1], x[1] = t
		}

		function n(t, e, n, r, a, o, s, l, u, c) {
			if (c > e && c > r && c > o && c > l || e > c && r > c && o > c && l > c) return 0;
			var h = f.cubicRootAt(e, r, o, l, c, y);
			if (0 === h) return 0;
			for (var d, p, m = 0, v = -1, g = 0; h > g; g++) {
				var _ = y[g],
					b = f.cubicAt(t, n, a, s, _);
				u > b || (0 > v && (v = f.cubicExtrema(e, r, o, l, x), x[1] < x[0] && v > 1 && i(), d = f.cubicAt(e, r, o, l, x[0]), v > 1 && (p = f.cubicAt(e, r, o, l, x[1]))), m += 2 == v ? _ < x[0] ? e > d ? 1 : -1 : _ < x[1] ? d > p ? 1 : -1 : p > l ? 1 : -1 : _ < x[0] ? e > d ? 1 : -1 : d > l ? 1 : -1)
			}
			return m
		}

		function r(t, e, i, n, r, a, o, s) {
			if (s > e && s > n && s > a || e > s && n > s && a > s) return 0;
			var l = f.quadraticRootAt(e, n, a, s, y);
			if (0 === l) return 0;
			var u = f.quadraticExtremum(e, n, a);
			if (u >= 0 && 1 >= u) {
				for (var c = 0, h = f.quadraticAt(e, n, a, u), d = 0; l > d; d++) {
					var p = f.quadraticAt(t, i, r, y[d]);
					o > p || (c += y[d] < u ? e > h ? 1 : -1 : h > a ? 1 : -1)
				}
				return c
			}
			var p = f.quadraticAt(t, i, r, y[0]);
			return o > p ? 0 : e > a ? 1 : -1
		}

		function a(t, e, i, n, r, a, o, s) {
			if (s -= e, s > i || -i > s) return 0;
			var l = Math.sqrt(i * i - s * s);
			y[0] = -l, y[1] = l;
			var u = Math.abs(n - r);
			if (1e-4 > u) return 0;
			if (1e-4 > u % v) {
				n = 0, r = v;
				var c = a ? 1 : -1;
				return o >= y[0] + t && o <= y[1] + t ? c : 0
			}
			if (a) {
				var l = n;
				n = d(r), r = d(l)
			} else n = d(n), r = d(r);
			n > r && (r += v);
			for (var h = 0, f = 0; 2 > f; f++) {
				var p = y[f];
				if (p + t > o) {
					var m = Math.atan2(s, p),
						c = a ? 1 : -1;
					0 > m && (m = v + m), (m >= n && r >= m || m + v >= n && r >= m + v) && (m > Math.PI / 2 && m < 1.5 * Math.PI && (c = -c), h += c)
				}
			}
			return h
		}

		function o(t, i, o, l, d) {
			for (var f = 0, v = 0, g = 0, y = 0, x = 0, _ = 0; _ < t[$];) {
				var b = t[_++];
				if (b === s.M && _ > 1 && (o || (f += p(v, g, y, x, l, d)), 0 !== f)) return !0;
				switch (1 == _ && (v = t[_], g = t[_ + 1], y = v, x = g), b) {
					case s.M:
						y = t[_++], x = t[_++], v = y, g = x;
						break;
					case s.L:
						if (o) {
							if (m(v, g, t[_], t[_ + 1], i, l, d)) return !0
						} else f += p(v, g, t[_], t[_ + 1], l, d) || 0;
						v = t[_++], g = t[_++];
						break;
					case s.C:
						if (o) {
							if (u.containStroke(v, g, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], i, l, d)) return !0
						} else f += n(v, g, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], l, d) || 0;
						v = t[_++], g = t[_++];
						break;
					case s.Q:
						if (o) {
							if (c.containStroke(v, g, t[_++], t[_++], t[_], t[_ + 1], i, l, d)) return !0
						} else f += r(v, g, t[_++], t[_++], t[_], t[_ + 1], l, d) || 0;
						v = t[_++], g = t[_++];
						break;
					case s.A:
						var w = t[_++],
							M = t[_++],
							S = t[_++],
							A = t[_++],
							C = t[_++],
							L = t[_++],
							k = (t[_++], 1 - t[_++]),
							z = Math.cos(C) * S + w,
							P = Math.sin(C) * A + M;
						_ > 1 ? f += p(v, g, z, P, l, d) : (y = z, x = P);
						var T = (l - w) * A / S + w;
						if (o) {
							if (h.containStroke(w, M, A, C, C + L, k, i, T, d)) return !0
						} else f += a(w, M, A, C, C + L, k, T, d);
						v = Math.cos(C + L) * S + w, g = Math.sin(C + L) * A + M;
						break;
					case s.R:
						y = v = t[_++], x = g = t[_++];
						var D = t[_++],
							I = t[_++],
							z = y + D,
							P = x + I;
						if (o) {
							if (m(y, x, z, x, i, l, d) || m(z, x, z, P, i, l, d) || m(z, P, y, P, i, l, d) || m(y, P, z, P, i, l, d)) return !0
						} else f += p(z, x, z, P, l, d), f += p(y, P, y, x, l, d);
						break;
					case s.Z:
						if (o) {
							if (m(v, g, y, x, i, l, d)) return !0
						} else if (f += p(v, g, y, x, l, d), 0 !== f) return !0;
						v = y, g = x
				}
			}
			return o || e(g, x) || (f += p(v, g, y, x, l, d) || 0), 0 !== f
		}
		var s = t("../core/PathProxy").CMD,
			l = t("./line"),
			u = t("./cubic"),
			c = t("./quadratic"),
			h = t("./arc"),
			d = t("./util").normalizeRadian,
			f = t("../core/curve"),
			p = t("./windingLine"),
			m = l.containStroke,
			v = 2 * Math.PI,
			g = 1e-4,
			y = [-1, -1, -1],
			x = [-1, -1];
		return {
			contain: function(t, e, i) {
				return o(t, 0, !1, e, i)
			},
			containStroke: function(t, e, i, n) {
				return o(t, e, !0, i, n)
			}
		}
	}), e("echarts/model/mixin/makeStyleMapper", [ve, me], function(t) {
		var e = t(me);
		return function(t) {
			for (var i = 0; i < t[$]; i++) t[i][1] || (t[i][1] = t[i][0]);
			return function(i) {
				for (var n = {}, r = 0; r < t[$]; r++) {
					var a = t[r][1];
					if (!(i && e[N](i, a) >= 0)) {
						var o = this[h](a);
						null != o && (n[t[r][0]] = o)
					}
				}
				return n
			}
		}
	}), e("zrender/graphic/Style", [ve], function() {
		var t = ["lineCap", "lineJoin", "miterLimit", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "shadowColor"],
			e = function(t) {
				this.extendFrom(t)
			};
		e[de] = {
			constructor: e,
			fill: "#000000",
			stroke: null,
			opacity: 1,
			lineDash: null,
			lineDashOffset: 0,
			shadowBlur: 0,
			shadowOffsetX: 0,
			shadowOffsetY: 0,
			lineWidth: 1,
			strokeNoScale: !1,
			text: null,
			textFill: "#000",
			textStroke: null,
			textPosition: "inside",
			textBaseline: null,
			textAlign: null,
			textVerticalAlign: null,
			textDistance: 5,
			textShadowBlur: 0,
			textShadowOffsetX: 0,
			textShadowOffsetY: 0,
			bind: function(e, i) {
				for (var n = this.fill, r = this.stroke, a = 0; a < t[$]; a++) {
					var o = t[a];
					null != this[o] && (e[o] = this[o])
				}
				if (null != r) {
					var s = this.lineWidth;
					e.lineWidth = s / (this.strokeNoScale && i && i.getLineScale ? i.getLineScale() : 1)
				}
				null != n && (e.fillStyle = n.canvasGradient ? n.canvasGradient : n), null != r && (e.strokeStyle = r.canvasGradient ? r.canvasGradient : r), null != this[C] && (e.globalAlpha = this[C])
			},
			extendFrom: function(t, e) {
				if (t) {
					var i = this;
					for (var n in t) !t.hasOwnProperty(n) || !e && i.hasOwnProperty(n) || (i[n] = t[n])
				}
			},
			set: function(t, e) {
				typeof t === he ? this[t] = e : this.extendFrom(t, !0)
			},
			clone: function() {
				var t = new this.constructor;
				return t.extendFrom(this, !0), t
			}
		};
		var i, n, r = e[de];
		for (n = 0; n < t[$]; n++) i = t[n], i in r || (r[i] = null);
		return e
	}), e("zrender/Element", [ve, "./core/guid", "./mixin/Eventful", "./mixin/Transformable", "./mixin/Animatable", "./core/util"], function(t) {
		var e = t("./core/guid"),
			i = t("./mixin/Eventful"),
			n = t("./mixin/Transformable"),
			r = t("./mixin/Animatable"),
			a = t("./core/util"),
			o = function(t) {
				n.call(this, t), i.call(this, t), r.call(this, t), this.id = t.id || e()
			};
		return o[de] = {
			type: "element",
			name: "",
			__zr: null,
			ignore: !1,
			clipPath: null,
			drift: function(t, e) {
				switch (this.draggable) {
					case "horizontal":
						e = 0;
						break;
					case "vertical":
						t = 0
				}
				var i = this.transform;
				i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.dirty()
			},
			beforeUpdate: function() {},
			afterUpdate: function() {},
			update: function() {
				this.updateTransform()
			},
			traverse: function() {},
			attrKV: function(t, e) {
				if (t === L || "scale" === t || "origin" === t) {
					if (e) {
						var i = this[t];
						i || (i = this[t] = []), i[0] = e[0], i[1] = e[1]
					}
				} else this[t] = e
			},
			hide: function() {
				this[se] = !0, this.__zr && this.__zr.refresh()
			},
			show: function() {
				this[se] = !1, this.__zr && this.__zr.refresh()
			},
			attr: function(t, e) {
				if (typeof t === he) this.attrKV(t, e);
				else if (a[ie](t))
					for (var i in t) t.hasOwnProperty(i) && this.attrKV(i, t[i]);
				return this.dirty(), this
			},
			setClipPath: function(t) {
				var e = this.__zr;
				e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty()
			},
			removeClipPath: function() {
				var t = this.clipPath;
				t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty())
			},
			addSelfToZr: function(t) {
				this.__zr = t;
				var e = this.animators;
				if (e)
					for (var i = 0; i < e[$]; i++) t.animation.addAnimator(e[i]);
				this.clipPath && this.clipPath.addSelfToZr(t)
			},
			removeSelfFromZr: function(t) {
				this.__zr = null;
				var e = this.animators;
				if (e)
					for (var i = 0; i < e[$]; i++) t.animation.removeAnimator(e[i]);
				this.clipPath && this.clipPath.removeSelfFromZr(t)
			}
		}, a.mixin(o, r), a.mixin(o, n), a.mixin(o, i), o
	}), e("zrender/graphic/mixin/RectText", [ve, "../../contain/text", "../../core/BoundingRect"], function(t) {
		function e(t, e) {
			return typeof t === he ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t
		}

		function i(t, e) {
			t.transform(e[0], e[1], e[2], e[3], e[4], e[5])
		}
		var n = t("../../contain/text"),
			r = t("../../core/BoundingRect"),
			a = new r,
			o = function() {};
		return o[de] = {
			constructor: o,
			drawRectText: function(t, r, o) {
				var s = this.style,
					l = s.text;
				if (null != l && (l += ""), l) {
					var u, c, h = s.textPosition,
						d = s.textDistance,
						f = s[I],
						m = s.textFont || s.font,
						v = s.textBaseline,
						g = s.textVerticalAlign;
					o = o || n[P](l, m, f, v);
					var y = this.transform,
						x = this.invTransform;
					if (y && (a.copy(r), a[p](y), r = a, i(t, x)), h instanceof Array) u = r.x + e(h[0], r.width), c = r.y + e(h[1], r[ae]), f = f || "left", v = v || "top";
					else {
						var _ = n.adjustTextPositionOnRect(h, r, o, d);
						u = _.x, c = _.y, f = f || _[I], v = v || _.textBaseline
					}
					if (t[I] = f, g) {
						switch (g) {
							case z:
								c -= o[ae] / 2;
								break;
							case oe:
								c -= o[ae]
						}
						t.textBaseline = "top"
					} else t.textBaseline = v;
					var b = s.textFill,
						w = s.textStroke;
					b && (t.fillStyle = b), w && (t.strokeStyle = w), t.font = m, t.shadowColor = s.textShadowColor, t.shadowBlur = s.textShadowBlur, t.shadowOffsetX = s.textShadowOffsetX, t.shadowOffsetY = s.textShadowOffsetY;
					for (var M = l.split("\n"), S = 0; S < M[$]; S++) b && t.fillText(M[S], u, c), w && t.strokeText(M[S], u, c), c += o.lineHeight;
					y && i(t, y)
				}
			}
		}, o
	}), e("zrender/contain/text", [ve, l, "../core/BoundingRect"], function(t) {
		function e(t, e) {
			var i = t + ":" + e;
			if (s[i]) return s[i];
			for (var n = (t + "").split("\n"), r = 0, a = 0, o = n[$]; o > a; a++) r = Math.max(f.measureText(n[a], e).width, r);
			return u > c && (u = 0, s = {}), u++, s[i] = r, r
		}

		function i(t, i, n, r) {
			var a = ((t || "") + "").split("\n")[$],
				o = e(t, i),
				s = e("国", i),
				l = a * s,
				u = new d(0, 0, o, l);
			switch (u.lineHeight = s, r) {
				case oe:
				case "alphabetic":
					u.y -= s;
					break;
				case z:
					u.y -= s / 2
			}
			switch (n) {
				case "end":
				case "right":
					u.x -= u.width;
					break;
				case k:
					u.x -= u.width / 2
			}
			return u
		}

		function n(t, e, i, n) {
			var r = e.x,
				a = e.y,
				o = e[ae],
				s = e.width,
				l = i[ae],
				u = o / 2 - l / 2,
				c = "left";
			switch (t) {
				case "left":
					r -= n, a += u, c = "right";
					break;
				case "right":
					r += n + s, a += u, c = "left";
					break;
				case "top":
					r += s / 2, a -= n + l, c = k;
					break;
				case oe:
					r += s / 2, a += o + n, c = k;
					break;
				case "inside":
					r += s / 2, a += u, c = k;
					break;
				case "insideLeft":
					r += n, a += u, c = "left";
					break;
				case "insideRight":
					r += s - n, a += u, c = "right";
					break;
				case "insideTop":
					r += s / 2, a += n, c = k;
					break;
				case "insideBottom":
					r += s / 2, a += o - l - n, c = k;
					break;
				case "insideTopLeft":
					r += n, a += n, c = "left";
					break;
				case "insideTopRight":
					r += s - n, a += n, c = "right";
					break;
				case "insideBottomLeft":
					r += n, a += o - l - n;
					break;
				case "insideBottomRight":
					r += s - n, a += o - l - n, c = "right"
			}
			return {
				x: r,
				y: a,
				textAlign: c,
				textBaseline: "top"
			}
		}

		function r(t, i, n, r) {
			if (!n) return "";
			r = h[K]({
				ellipsis: "...",
				minCharacters: 3,
				maxIterations: 3,
				cnCharWidth: e("国", i),
				ascCharWidth: e("a", i)
			}, r, !0), n -= e(r.ellipsis);
			for (var o = (t + "").split("\n"), s = 0, l = o[$]; l > s; s++) o[s] = a(o[s], i, n, r);
			return o.join("\n")
		}

		function a(t, i, n, r) {
			for (var a = 0;; a++) {
				var s = e(t, i);
				if (n > s || a >= r.maxIterations) {
					t += r.ellipsis;
					break
				}
				var l = 0 === a ? o(t, n, r) : Math.floor(t[$] * n / s);
				if (l < r.minCharacters) {
					t = "";
					break
				}
				t = t.substr(0, l)
			}
			return t
		}

		function o(t, e, i) {
			for (var n = 0, r = 0, a = t[$]; a > r && e > n; r++) {
				var o = t.charCodeAt(r);
				n += o >= 0 && 127 >= o ? i.ascCharWidth : i.cnCharWidth
			}
			return r
		}
		var s = {},
			u = 0,
			c = 5e3,
			h = t(l),
			d = t("../core/BoundingRect"),
			f = {
				getWidth: e,
				getBoundingRect: i,
				adjustTextPositionOnRect: n,
				ellipsis: r,
				measureText: function(t, e) {
					var i = h[M]();
					return i.font = e, i.measureText(t)
				}
			};
		return f
	}), e("zrender/core/guid", [], function() {
		var t = 2311;
		return function() {
			return "zr_" + t++
		}
	}), e("zrender/mixin/Transformable", [ve, "../core/matrix", "../core/vector"], function(t) {
		function e(t) {
			return t > a || -a > t
		}
		var i = t("../core/matrix"),
			n = t("../core/vector"),
			r = i.identity,
			a = 5e-5,
			s = function(t) {
				t = t || {}, t[L] || (this[L] = [0, 0]), null == t[o] && (this[o] = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null
			},
			l = s[de];
		l.transform = null, l.needLocalTransform = function() {
			return e(this[o]) || e(this[L][0]) || e(this[L][1]) || e(this.scale[0] - 1) || e(this.scale[1] - 1)
		}, l.updateTransform = function() {
			var t = this[c],
				e = t && t.transform,
				n = this.needLocalTransform(),
				a = this.transform;
			return n || e ? (a = a || i[re](), n ? this.getLocalTransform(a) : r(a), e && (n ? i.mul(a, t.transform, a) : i.copy(a, t.transform)), this.transform = a, this.invTransform = this.invTransform || i[re](), void i.invert(this.invTransform, a)) : void(a && r(a))
		}, l.getLocalTransform = function(t) {
			t = t || [], r(t);
			var e = this.origin,
				n = this.scale,
				a = this[o],
				s = this[L];
			return e && (t[4] -= e[0], t[5] -= e[1]), i.scale(t, t, n), a && i.rotate(t, t, a), e && (t[4] += e[0], t[5] += e[1]), t[4] += s[0], t[5] += s[1], t
		}, l.setTransform = function(t) {
			var e = this.transform;
			e && t.transform(e[0], e[1], e[2], e[3], e[4], e[5])
		};
		var u = [];
		return l.decomposeTransform = function() {
			if (this.transform) {
				var t = this[c],
					n = this.transform;
				t && t.transform && (i.mul(u, t.invTransform, n), n = u);
				var r = n[0] * n[0] + n[1] * n[1],
					a = n[2] * n[2] + n[3] * n[3],
					s = this[L],
					l = this.scale;
				e(r - 1) && (r = Math.sqrt(r)), e(a - 1) && (a = Math.sqrt(a)), n[0] < 0 && (r = -r), n[3] < 0 && (a = -a), s[0] = n[4], s[1] = n[5], l[0] = r, l[1] = a, this[o] = Math.atan2(-n[1] / a, n[0] / r)
			}
		}, l.transformCoordToLocal = function(t, e) {
			var i = [t, e],
				r = this.invTransform;
			return r && n[p](i, i, r), i
		}, l.transformCoordToGlobal = function(t, e) {
			var i = [t, e],
				r = this.transform;
			return r && n[p](i, i, r), i
		}, s
	}), e("zrender/mixin/Animatable", [ve, "../animation/Animator", l, "../core/log"], function(t) {
		var e = t("../animation/Animator"),
			i = t(l),
			n = i.isString,
			r = i.isFunction,
			a = i[ie],
			o = t("../core/log"),
			s = function() {
				this.animators = []
			};
		return s[de] = {
			constructor: s,
			animate: function(t, n) {
				var r, a = !1,
					s = this,
					l = this.__zr;
				if (t) {
					var u = t.split("."),
						c = s;
					a = "shape" === u[0];
					for (var h = 0, d = u[$]; d > h; h++) c && (c = c[u[h]]);
					c && (r = c)
				} else r = s;
				if (!r) return void o('Property "' + t + '" is not existed in element ' + s.id);
				var f = s.animators,
					p = new e(r, n);
				return p.during(function() {
					s.dirty(a)
				}).done(function() {
					f[X](i[N](f, p), 1)
				}), f.push(p), l && l.animation.addAnimator(p), p
			},
			stopAnimation: function(t) {
				for (var e = this.animators, i = e[$], n = 0; i > n; n++) e[n].stop(t);
				return e[$] = 0, this
			},
			animateTo: function(t, e, i, a, o) {
				function s() {
					u--, u || o && o()
				}
				n(i) ? (o = a, a = i, i = 0) : r(a) ? (o = a, a = "linear", i = 0) : r(i) ? (o = i, i = 0) : r(e) ? (o = e, e = 500) : e || (e = 500), this.stopAnimation(), this._animateToShallow("", this, t, e, i, a, o);
				var l = this.animators.slice(),
					u = l[$];
				u || o && o();
				for (var c = 0; c < l[$]; c++) l[c].done(s).start(a)
			},
			_animateToShallow: function(t, e, n, r, o) {
				var s = {},
					l = 0;
				for (var u in n)
					if (null != e[u]) a(n[u]) && !i.isArrayLike(n[u]) ? this._animateToShallow(t ? t + "." + u : u, e[u], n[u], r, o) : (s[u] = n[u], l++);
					else if (null != n[u])
					if (t) {
						var c = {};
						c[t] = {}, c[t][u] = n[u], this.attr(c)
					} else this.attr(u, n[u]);
				return l > 0 && this.animate(t, !1).when(null == r ? 500 : r, s).delay(o || 0), this
			}
		}, s
	}), e("echarts/component/dataZoom/AxisProxy", [ve, me, n], function(t) {
		function e(t, e) {
			var i = [1 / 0, -1 / 0];
			return u(e, function(e) {
				var n = e[U]();
				n && u(e.coordDimToDataDim(t), function(t) {
					var e = n.getDataExtent(t);
					e[0] < i[0] && (i[0] = e[0]), e[1] > i[1] && (i[1] = e[1])
				})
			}, this), i
		}

		function r(t, e, i) {
			var n = i.getAxisModel(),
				r = n.axis.scale,
				o = [0, 100],
				s = [t.start, t.end],
				h = [];
			return e = e.slice(), a(e, n, r), u(["startValue", "endValue"], function(e) {
				h.push(null != t[e] ? r.parse(t[e]) : null)
			}), u([0, 1], function(t) {
				var i = h[t],
					n = s[t];
				null != n || null == i ? (null == n && (n = o[t]), i = r.parse(l.linearMap(n, o, e, !0))) : n = l.linearMap(i, e, o, !0), h[t] = l.round(i), s[t] = l.round(n)
			}), {
				valueWindow: c(h),
				percentWindow: c(s)
			}
		}

		function a(t, e, i) {
			return u(["min", "max"], function(n, r) {
				var a = e.get(n, !0);
				null != a && (a + "")[fe]() !== "data" + n && (t[r] = i.parse(a))
			}), e.get("scale", !0) || (t[0] > 0 && (t[0] = 0), t[1] < 0 && (t[1] = 0)), t
		}

		function o(t, e) {
			var i = t.getAxisModel(),
				n = t._percentWindow,
				r = t._valueWindow;
			if (n) {
				var a = e || 0 === n[0] && 100 === n[1],
					o = !e && l.getPixelPrecision(r, [0, 500]),
					s = !(e || 20 > o && o >= 0),
					u = e || a || s;
				i.setRange && i.setRange(u ? null : +r[0].toFixed(o), u ? null : +r[1].toFixed(o))
			}
		}
		var s = t(me),
			l = t(n),
			u = s.each,
			c = l.asc,
			h = function(t, e, i, n) {
				this._dimName = t, this._axisIndex = e, this._valueWindow, this._percentWindow, this._dataExtent, this[m] = n, this._dataZoomModel = i
			};
		return h[de] = {
			constructor: h,
			hostedBy: function(t) {
				return this._dataZoomModel === t
			},
			getDataExtent: function() {
				return this._dataExtent.slice()
			},
			getDataValueWindow: function() {
				return this._valueWindow.slice()
			},
			getDataPercentWindow: function() {
				return this._percentWindow.slice()
			},
			getTargetSeriesModels: function() {
				var t = [];
				return this[m][Y](function(e) {
					this._axisIndex === e.get(this._dimName + "AxisIndex") && t.push(e)
				}, this), t
			},
			getAxisModel: function() {
				return this[m][y](this._dimName + "Axis", this._axisIndex)
			},
			getOtherAxisModel: function() {
				var t, e, i = this._dimName,
					n = this[m],
					r = this.getAxisModel(),
					a = "x" === i || "y" === i;
				a ? (e = "gridIndex", t = "x" === i ? "y" : "x") : (e = "polarIndex", t = "angle" === i ? "radius" : "angle");
				var o;
				return n.eachComponent(t + "Axis", function(t) {
					(t.get(e) || 0) === (r.get(e) || 0) && (o = t)
				}), o
			},
			reset: function(t) {
				if (t === this._dataZoomModel) {
					var i = this._dataExtent = e(this._dimName, this.getTargetSeriesModels()),
						n = r(t[_], i, this);
					this._valueWindow = n.valueWindow, this._percentWindow = n.percentWindow, o(this)
				}
			},
			restore: function(t) {
				t === this._dataZoomModel && (this._valueWindow = this._percentWindow = null, o(this, !0))
			},
			filterData: function(t) {
				function e(t) {
					return t >= o[0] && t <= o[1]
				}
				if (t === this._dataZoomModel) {
					var n = this._dimName,
						r = this.getTargetSeriesModels(),
						a = t.get("filterMode"),
						o = this._valueWindow,
						s = this.getOtherAxisModel();
					t.get("$fromToolbox") && s && s.get("type") === i && (a = "empty"), u(r, function(t) {
						var i = t[U]();
						i && u(t.coordDimToDataDim(n), function(n) {
							"empty" === a ? t.setData(i.map(n, function(t) {
								return e(t) ? t : 0 / 0
							})) : i.filterSelf(n, e)
						})
					})
				}
			}
		}, h
	}), e("zrender/animation/Animator", [ve, "./Clip", "../tool/color", l], function(t) {
		function e(t, e) {
			return t[e]
		}

		function i(t, e, i) {
			t[e] = i
		}

		function n(t, e, i) {
			return (e - t) * i + t
		}

		function r(t, e, i) {
			return i > .5 ? e : t
		}

		function a(t, e, i, r, a) {
			var o = t[$];
			if (1 == a)
				for (var s = 0; o > s; s++) r[s] = n(t[s], e[s], i);
			else
				for (var l = t[0][$], s = 0; o > s; s++)
					for (var u = 0; l > u; u++) r[s][u] = n(t[s][u], e[s][u], i)
		}

		function o(t, e, i) {
			var n = t[$],
				r = e[$];
			if (n !== r) {
				var a = n > r;
				if (a) t[$] = r;
				else
					for (var o = n; r > o; o++) t.push(1 === i ? e[o] : y.call(e[o]))
			}
		}

		function s(t, e, i) {
			if (t === e) return !0;
			var n = t[$];
			if (n !== e[$]) return !1;
			if (1 === i) {
				for (var r = 0; n > r; r++)
					if (t[r] !== e[r]) return !1
			} else
				for (var a = t[0][$], r = 0; n > r; r++)
					for (var o = 0; a > o; o++)
						if (t[r][o] !== e[r][o]) return !1; return !0
		}

		function u(t, e, i, n, r, a, o, s, l) {
			var u = t[$];
			if (1 == l)
				for (var h = 0; u > h; h++) s[h] = c(t[h], e[h], i[h], n[h], r, a, o);
			else
				for (var d = t[0][$], h = 0; u > h; h++)
					for (var f = 0; d > f; f++) s[h][f] = c(t[h][f], e[h][f], i[h][f], n[h][f], r, a, o)
		}

		function c(t, e, i, n, r, a, o) {
			var s = .5 * (i - t),
				l = .5 * (n - e);
			return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
		}

		function h(t) {
			if (g(t)) {
				var e = t[$];
				if (g(t[0])) {
					for (var i = [], n = 0; e > n; n++) i.push(y.call(t[n]));
					return i
				}
				return y.call(t)
			}
			return t
		}

		function d(t) {
			return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), "rgba(" + t.join(",") + ")"
		}

		function f(t, e, i, l, h) {
			var f = t._getter,
				v = t._setter,
				y = "spline" === e,
				x = l[$];
			if (x) {
				var _, b = l[0].value,
					w = g(b),
					M = !1,
					S = !1,
					A = w && g(b[0]) ? 2 : 1;
				l.sort(function(t, e) {
					return t.time - e.time
				}), _ = l[x - 1].time;
				for (var C = [], L = [], k = l[0].value, z = !0, P = 0; x > P; P++) {
					C.push(l[P].time / _);
					var T = l[P].value;
					if (w && s(T, k, A) || !w && T === k || (z = !1), k = T, typeof T == he) {
						var D = m.parse(T);
						D ? (T = D, M = !0) : S = !0
					}
					L.push(T)
				}
				if (!z) {
					if (w) {
						for (var I = L[x - 1], P = 0; x - 1 > P; P++) o(L[P], I, A);
						o(f(t._target, h), I, A)
					}
					var O, R, E, B, V, Z, N = 0,
						G = 0;
					if (M) var F = [0, 0, 0, 0];
					var q = function(t, e) {
							var i;
							if (G > e) {
								for (O = Math.min(N + 1, x - 1), i = O; i >= 0 && !(C[i] <= e); i--);
								i = Math.min(i, x - 2)
							} else {
								for (i = N; x > i && !(C[i] > e); i++);
								i = Math.min(i - 1, x - 2)
							}
							N = i, G = e;
							var o = C[i + 1] - C[i];
							if (0 !== o)
								if (R = (e - C[i]) / o, y)
									if (B = L[i], E = L[0 === i ? i : i - 1], V = L[i > x - 2 ? x - 1 : i + 1], Z = L[i > x - 3 ? x - 1 : i + 2], w) u(E, B, V, Z, R, R * R, R * R * R, f(t, h), A);
									else {
										var s;
										if (M) s = u(E, B, V, Z, R, R * R, R * R * R, F, 1), s = d(F);
										else {
											if (S) return r(B, V, R);
											s = c(E, B, V, Z, R, R * R, R * R * R)
										}
										v(t, h, s)
									}
							else if (w) a(L[i], L[i + 1], R, f(t, h), A);
							else {
								var s;
								if (M) a(L[i], L[i + 1], R, F, 1), s = d(F);
								else {
									if (S) return r(L[i], L[i + 1], R);
									s = n(L[i], L[i + 1], R)
								}
								v(t, h, s)
							}
						},
						W = new p({
							target: t._target,
							life: _,
							loop: t._loop,
							delay: t._delay,
							onframe: q,
							ondestroy: i
						});
					return e && "spline" !== e && (W.easing = e), W
				}
			}
		}
		var p = t("./Clip"),
			m = t("../tool/color"),
			v = t(l),
			g = v.isArrayLike,
			y = Array[de].slice,
			x = function(t, n, r, a) {
				this._tracks = {}, this._target = t, this._loop = n || !1, this._getter = r || e, this._setter = a || i, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = []
			};
		return x[de] = {
			when: function(t, e) {
				var i = this._tracks;
				for (var n in e) {
					if (!i[n]) {
						i[n] = [];
						var r = this._getter(this._target, n);
						if (null == r) continue;
						0 !== t && i[n].push({
							time: 0,
							value: h(r)
						})
					}
					i[n].push({
						time: t,
						value: e[n]
					})
				}
				return this
			},
			during: function(t) {
				return this._onframeList.push(t), this
			},
			_doneCallback: function() {
				this._tracks = {}, this._clipList[$] = 0;
				for (var t = this._doneList, e = t[$], i = 0; e > i; i++) t[i].call(this)
			},
			start: function(t) {
				var e, i = this,
					n = 0,
					r = function() {
						n--, n || i._doneCallback()
					};
				for (var a in this._tracks) {
					var o = f(this, t, r, this._tracks[a], a);
					o && (this._clipList.push(o), n++, this.animation && this.animation.addClip(o), e = o)
				}
				if (e) {
					var s = e.onframe;
					e.onframe = function(t, e) {
						s(t, e);
						for (var n = 0; n < i._onframeList[$]; n++) i._onframeList[n](t, e)
					}
				}
				return n || this._doneCallback(), this
			},
			stop: function(t) {
				for (var e = this._clipList, i = this.animation, n = 0; n < e[$]; n++) {
					var r = e[n];
					t && r.onframe(this._target, 1), i && i.removeClip(r)
				}
				e[$] = 0
			},
			delay: function(t) {
				return this._delay = t, this
			},
			done: function(t) {
				return t && this._doneList.push(t), this
			},
			getClips: function() {
				return this._clipList
			}
		}, x
	}), e("zrender/core/log", [ve, "../config"], function(t) {
		var e = t("../config");
		return function() {
			if (0 !== e.debugMode)
				if (1 == e.debugMode)
					for (var t in arguments) throw new Error(arguments[t]);
				else if (e.debugMode > 1)
				for (var t in arguments) console.log(arguments[t])
		}
	}), e("zrender/animation/Clip", [ve, "./easing"], function(t) {
		function e(t) {
			this._target = t.target, this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null == t.loop ? !1 : t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart
		}
		var i = t("./easing");
		return e[de] = {
			constructor: e,
			step: function(t) {
				this._initialized || (this._startTime = (new Date).getTime() + this._delay, this._initialized = !0);
				var e = (t - this._startTime) / this._life;
				if (!(0 > e)) {
					e = Math.min(e, 1);
					var n = this.easing,
						r = typeof n == he ? i[n] : n,
						a = typeof r === Z ? r(e) : e;
					return this.fire("frame", a), 1 == e ? this.loop ? (this.restart(), "restart") : (this._needsRemove = !0, "destroy") : null
				}
			},
			restart: function() {
				var t = (new Date).getTime(),
					e = (t - this._startTime) % this._life;
				this._startTime = (new Date).getTime() - e + this.gap, this._needsRemove = !1
			},
			fire: function(t, e) {
				t = "on" + t, this[t] && this[t](this._target, e)
			}
		}, e
	}), e("zrender/animation/easing", [], function() {
		var t = {
			linear: function(t) {
				return t
			},
			quadraticIn: function(t) {
				return t * t
			},
			quadraticOut: function(t) {
				return t * (2 - t)
			},
			quadraticInOut: function(t) {
				return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
			},
			cubicIn: function(t) {
				return t * t * t
			},
			cubicOut: function(t) {
				return --t * t * t + 1
			},
			cubicInOut: function(t) {
				return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
			},
			quarticIn: function(t) {
				return t * t * t * t
			},
			quarticOut: function(t) {
				return 1 - --t * t * t * t
			},
			quarticInOut: function(t) {
				return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
			},
			quinticIn: function(t) {
				return t * t * t * t * t
			},
			quinticOut: function(t) {
				return --t * t * t * t * t + 1
			},
			quinticInOut: function(t) {
				return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
			},
			sinusoidalIn: function(t) {
				return 1 - Math.cos(t * Math.PI / 2)
			},
			sinusoidalOut: function(t) {
				return Math.sin(t * Math.PI / 2)
			},
			sinusoidalInOut: function(t) {
				return .5 * (1 - Math.cos(Math.PI * t))
			},
			exponentialIn: function(t) {
				return 0 === t ? 0 : Math.pow(1024, t - 1)
			},
			exponentialOut: function(t) {
				return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
			},
			exponentialInOut: function(t) {
				return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2)
			},
			circularIn: function(t) {
				return 1 - Math.sqrt(1 - t * t)
			},
			circularOut: function(t) {
				return Math.sqrt(1 - --t * t)
			},
			circularInOut: function(t) {
				return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
			},
			elasticIn: function(t) {
				var e, i = .1,
					n = .4;
				return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n)))
			},
			elasticOut: function(t) {
				var e, i = .1,
					n = .4;
				return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / n) + 1)
			},
			elasticInOut: function(t) {
				var e, i = .1,
					n = .4;
				return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) * .5 + 1)
			},
			backIn: function(t) {
				var e = 1.70158;
				return t * t * ((e + 1) * t - e)
			},
			backOut: function(t) {
				var e = 1.70158;
				return --t * t * ((e + 1) * t + e) + 1
			},
			backInOut: function(t) {
				var e = 2.5949095;
				return (t *= 2) < 1 ? .5 * t * t * ((e + 1) * t - e) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
			},
			bounceIn: function(e) {
				return 1 - t.bounceOut(1 - e)
			},
			bounceOut: function(t) {
				return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
			},
			bounceInOut: function(e) {
				return .5 > e ? .5 * t.bounceIn(2 * e) : .5 * t.bounceOut(2 * e - 1) + .5
			}
		};
		return t
	}), e("zrender/config", [], function() {
		var t = 1;
		typeof window !== u && (t = Math.max(window.devicePixelRatio || 1, 1));
		var e = {
			debugMode: 0,
			devicePixelRatio: t
		};
		return e
	}), e("zrender/core/curve", [ve, "./vector"], function(t) {
		function e(t) {
			return t > -_ && _ > t
		}

		function i(t) {
			return t > _ || -_ > t
		}

		function n(t, e, i, n, r) {
			var a = 1 - r;
			return a * a * (a * t + 3 * r * e) + r * r * (r * n + 3 * a * i)
		}

		function r(t, e, i, n, r) {
			var a = 1 - r;
			return 3 * (((e - t) * a + 2 * (i - e) * r) * a + (n - i) * r * r)
		}

		function a(t, i, n, r, a, o) {
			var s = r + 3 * (i - n) - t,
				l = 3 * (n - 2 * i + t),
				u = 3 * (i - t),
				c = t - a,
				h = l * l - 3 * s * u,
				d = l * u - 9 * s * c,
				f = u * u - 3 * l * c,
				p = 0;
			if (e(h) && e(d))
				if (e(l)) o[0] = 0;
				else {
					var m = -u / l;
					m >= 0 && 1 >= m && (o[p++] = m)
				}
			else {
				var v = d * d - 4 * h * f;
				if (e(v)) {
					var g = d / h,
						m = -l / s + g,
						_ = -g / 2;
					m >= 0 && 1 >= m && (o[p++] = m), _ >= 0 && 1 >= _ && (o[p++] = _)
				} else if (v > 0) {
					var b = x(v),
						S = h * l + 1.5 * s * (-d + b),
						A = h * l + 1.5 * s * (-d - b);
					S = 0 > S ? -y(-S, M) : y(S, M), A = 0 > A ? -y(-A, M) : y(A, M);
					var m = (-l - (S + A)) / (3 * s);
					m >= 0 && 1 >= m && (o[p++] = m)
				} else {
					var C = (2 * h * l - 3 * s * d) / (2 * x(h * h * h)),
						L = Math.acos(C) / 3,
						k = x(h),
						z = Math.cos(L),
						m = (-l - 2 * k * z) / (3 * s),
						_ = (-l + k * (z + w * Math.sin(L))) / (3 * s),
						P = (-l + k * (z - w * Math.sin(L))) / (3 * s);
					m >= 0 && 1 >= m && (o[p++] = m), _ >= 0 && 1 >= _ && (o[p++] = _), P >= 0 && 1 >= P && (o[p++] = P)
				}
			}
			return p
		}

		function o(t, n, r, a, o) {
			var s = 6 * r - 12 * n + 6 * t,
				l = 9 * n + 3 * a - 3 * t - 9 * r,
				u = 3 * n - 3 * t,
				c = 0;
			if (e(l)) {
				if (i(s)) {
					var h = -u / s;
					h >= 0 && 1 >= h && (o[c++] = h)
				}
			} else {
				var d = s * s - 4 * l * u;
				if (e(d)) o[0] = -s / (2 * l);
				else if (d > 0) {
					var f = x(d),
						h = (-s + f) / (2 * l),
						p = (-s - f) / (2 * l);
					h >= 0 && 1 >= h && (o[c++] = h), p >= 0 && 1 >= p && (o[c++] = p)
				}
			}
			return c
		}

		function s(t, e, i, n, r, a) {
			var o = (e - t) * r + t,
				s = (i - e) * r + e,
				l = (n - i) * r + i,
				u = (s - o) * r + o,
				c = (l - s) * r + s,
				h = (c - u) * r + u;
			a[0] = t, a[1] = o, a[2] = u, a[3] = h, a[4] = h, a[5] = c, a[6] = l, a[7] = n
		}

		function l(t, e, i, r, a, o, s, l, u, c, h) {
			var d, f, p, m, v, y = .005,
				_ = 1 / 0;
			S[0] = u, S[1] = c;
			for (var w = 0; 1 > w; w += .05) A[0] = n(t, i, a, s, w), A[1] = n(e, r, o, l, w), m = g(S, A), _ > m && (d = w, _ = m);
			_ = 1 / 0;
			for (var M = 0; 32 > M && !(b > y); M++) f = d - y, p = d + y, A[0] = n(t, i, a, s, f), A[1] = n(e, r, o, l, f), m = g(A, S), f >= 0 && _ > m ? (d = f, _ = m) : (C[0] = n(t, i, a, s, p), C[1] = n(e, r, o, l, p), v = g(C, S), 1 >= p && _ > v ? (d = p, _ = v) : y *= .5);
			return h && (h[0] = n(t, i, a, s, d), h[1] = n(e, r, o, l, d)), x(_)
		}

		function u(t, e, i, n) {
			var r = 1 - n;
			return r * (r * t + 2 * n * e) + n * n * i
		}

		function c(t, e, i, n) {
			return 2 * ((1 - n) * (e - t) + n * (i - e))
		}

		function h(t, n, r, a, o) {
			var s = t - 2 * n + r,
				l = 2 * (n - t),
				u = t - a,
				c = 0;
			if (e(s)) {
				if (i(l)) {
					var h = -u / l;
					h >= 0 && 1 >= h && (o[c++] = h)
				}
			} else {
				var d = l * l - 4 * s * u;
				if (e(d)) {
					var h = -l / (2 * s);
					h >= 0 && 1 >= h && (o[c++] = h)
				} else if (d > 0) {
					var f = x(d),
						h = (-l + f) / (2 * s),
						p = (-l - f) / (2 * s);
					h >= 0 && 1 >= h && (o[c++] = h), p >= 0 && 1 >= p && (o[c++] = p)
				}
			}
			return c
		}

		function d(t, e, i) {
			var n = t + i - 2 * e;
			return 0 === n ? .5 : (t - e) / n
		}

		function f(t, e, i, n, r) {
			var a = (e - t) * n + t,
				o = (i - e) * n + e,
				s = (o - a) * n + a;
			r[0] = t, r[1] = a, r[2] = s, r[3] = s, r[4] = o, r[5] = i
		}

		function p(t, e, i, n, r, a, o, s, l) {
			var c, h = .005,
				d = 1 / 0;
			S[0] = o, S[1] = s;
			for (var f = 0; 1 > f; f += .05) {
				A[0] = u(t, i, r, f), A[1] = u(e, n, a, f);
				var p = g(S, A);
				d > p && (c = f, d = p)
			}
			d = 1 / 0;
			for (var m = 0; 32 > m && !(b > h); m++) {
				var v = c - h,
					y = c + h;
				A[0] = u(t, i, r, v), A[1] = u(e, n, a, v);
				var p = g(A, S);
				if (v >= 0 && d > p) c = v, d = p;
				else {
					C[0] = u(t, i, r, y), C[1] = u(e, n, a, y);
					var _ = g(C, S);
					1 >= y && d > _ ? (c = y, d = _) : h *= .5
				}
			}
			return l && (l[0] = u(t, i, r, c), l[1] = u(e, n, a, c)), x(d)
		}
		var m = t("./vector"),
			v = m[re],
			g = m.distSquare,
			y = Math.pow,
			x = Math.sqrt,
			_ = 1e-8,
			b = 1e-4,
			w = x(3),
			M = 1 / 3,
			S = v(),
			A = v(),
			C = v();
		return {
			cubicAt: n,
			cubicDerivativeAt: r,
			cubicRootAt: a,
			cubicExtrema: o,
			cubicSubdivide: s,
			cubicProjectPoint: l,
			quadraticAt: u,
			quadraticDerivativeAt: c,
			quadraticRootAt: h,
			quadraticExtremum: d,
			quadraticSubdivide: f,
			quadraticProjectPoint: p
		}
	}), e("zrender/core/bbox", [ve, "./vector", "./curve"], function(t) {
		var e = t("./vector"),
			i = t("./curve"),
			n = {},
			r = Math.min,
			a = Math.max,
			o = Math.sin,
			s = Math.cos,
			l = e[re](),
			u = e[re](),
			c = e[re](),
			h = 2 * Math.PI;
		n.fromPoints = function(t, e, i) {
			if (0 !== t[$]) {
				var n, o = t[0],
					s = o[0],
					l = o[0],
					u = o[1],
					c = o[1];
				for (n = 1; n < t[$]; n++) o = t[n], s = r(s, o[0]), l = a(l, o[0]), u = r(u, o[1]), c = a(c, o[1]);
				e[0] = s, e[1] = u, i[0] = l, i[1] = c
			}
		}, n.fromLine = function(t, e, i, n, o, s) {
			o[0] = r(t, i), o[1] = r(e, n), s[0] = a(t, i), s[1] = a(e, n)
		};
		var d = [],
			f = [];
		return n.fromCubic = function(t, e, n, o, s, l, u, c, h, p) {
			var m, v = i.cubicExtrema,
				g = i.cubicAt,
				y = v(t, n, s, u, d);
			for (h[0] = 1 / 0, h[1] = 1 / 0, p[0] = -1 / 0, p[1] = -1 / 0, m = 0; y > m; m++) {
				var x = g(t, n, s, u, d[m]);
				h[0] = r(x, h[0]), p[0] = a(x, p[0])
			}
			for (y = v(e, o, l, c, f), m = 0; y > m; m++) {
				var _ = g(e, o, l, c, f[m]);
				h[1] = r(_, h[1]), p[1] = a(_, p[1])
			}
			h[0] = r(t, h[0]), p[0] = a(t, p[0]), h[0] = r(u, h[0]), p[0] = a(u, p[0]), h[1] = r(e, h[1]), p[1] = a(e, p[1]), h[1] = r(c, h[1]), p[1] = a(c, p[1])
		}, n.fromQuadratic = function(t, e, n, o, s, l, u, c) {
			var h = i.quadraticExtremum,
				d = i.quadraticAt,
				f = a(r(h(t, n, s), 1), 0),
				p = a(r(h(e, o, l), 1), 0),
				m = d(t, n, s, f),
				v = d(e, o, l, p);
			u[0] = r(t, s, m), u[1] = r(e, l, v), c[0] = a(t, s, m), c[1] = a(e, l, v)
		}, n.fromArc = function(t, i, n, r, a, d, f, p, m) {
			var v = e.min,
				g = e.max,
				y = Math.abs(a - d);
			if (1e-4 > y % h && y > 1e-4) return p[0] = t - n, p[1] = i - r, m[0] = t + n, void(m[1] = i + r);
			if (l[0] = s(a) * n + t, l[1] = o(a) * r + i, u[0] = s(d) * n + t, u[1] = o(d) * r + i, v(p, l, u), g(m, l, u), a %= h, 0 > a && (a += h), d %= h, 0 > d && (d += h), a > d && !f ? d += h : d > a && f && (a += h), f) {
				var x = d;
				d = a, a = x
			}
			for (var _ = 0; d > _; _ += Math.PI / 2) _ > a && (c[0] = s(_) * n + t, c[1] = o(_) * r + i, v(p, c, p), g(m, c, m))
		}, n
	}), e("zrender/contain/line", [], function() {
		return {
			containStroke: function(t, e, i, n, r, a, o) {
				if (0 === r) return !1;
				var s = r,
					l = 0,
					u = t;
				if (o > e + s && o > n + s || e - s > o && n - s > o || a > t + s && a > i + s || t - s > a && i - s > a) return !1;
				if (t === i) return Math.abs(a - t) <= s / 2;
				l = (e - n) / (t - i), u = (t * n - i * e) / (t - i);
				var c = l * a - o + u,
					h = c * c / (l * l + 1);
				return s / 2 * s / 2 >= h
			}
		}
	}), e("zrender/contain/cubic", [ve, "../core/curve"], function(t) {
		var e = t("../core/curve");
		return {
			containStroke: function(t, i, n, r, a, o, s, l, u, c, h) {
				if (0 === u) return !1;
				var d = u;
				if (h > i + d && h > r + d && h > o + d && h > l + d || i - d > h && r - d > h && o - d > h && l - d > h || c > t + d && c > n + d && c > a + d && c > s + d || t - d > c && n - d > c && a - d > c && s - d > c) return !1;
				var f = e.cubicProjectPoint(t, i, n, r, a, o, s, l, c, h, null);
				return d / 2 >= f
			}
		}
	}), e("zrender/contain/quadratic", [ve, "../core/curve"], function(t) {
		var e = t("../core/curve");
		return {
			containStroke: function(t, i, n, r, a, o, s, l, u) {
				if (0 === s) return !1;
				var c = s;
				if (u > i + c && u > r + c && u > o + c || i - c > u && r - c > u && o - c > u || l > t + c && l > n + c && l > a + c || t - c > l && n - c > l && a - c > l) return !1;
				var h = e.quadraticProjectPoint(t, i, n, r, a, o, l, u, null);
				return c / 2 >= h
			}
		}
	}), e("zrender/contain/windingLine", [], function() {
		return function(t, e, i, n, r, a) {
			if (a > e && a > n || e > a && n > a) return 0;
			if (n === e) return 0;
			var o = e > n ? 1 : -1,
				s = (a - e) / (n - e),
				l = s * (i - t) + t;
			return l > r ? o : 0
		}
	}), e("zrender/contain/util", [ve], function() {
		var t = 2 * Math.PI;
		return {
			normalizeRadian: function(e) {
				return e %= t, 0 > e && (e += t), e
			}
		}
	}), e("zrender/contain/arc", [ve, "./util"], function(t) {
		var e = t("./util").normalizeRadian,
			i = 2 * Math.PI;
		return {
			containStroke: function(t, n, r, a, o, s, l, u, c) {
				if (0 === l) return !1;
				var h = l;
				u -= t, c -= n;
				var d = Math.sqrt(u * u + c * c);
				if (d - h > r || r > d + h) return !1;
				if (Math.abs(a - o) % i < 1e-4) return !0;
				if (s) {
					var f = a;
					a = e(o), o = e(f)
				} else a = e(a), o = e(o);
				a > o && (o += i);
				var p = Math.atan2(c, u);
				return 0 > p && (p += i), p >= a && o >= p || p + i >= a && o >= p + i
			}
		}
	}), e("zrender/core/LRU", [ve], function() {
		var t = function() {
				this.head = null, this.tail = null, this._len = 0
			},
			e = t[de];
		e.insert = function(t) {
			var e = new i(t);
			return this.insertEntry(e), e
		}, e.insertEntry = function(t) {
			this.head ? (this.tail.next = t, t.prev = this.tail, this.tail = t) : this.head = this.tail = t, this._len++
		}, e[ee] = function(t) {
			var e = t.prev,
				i = t.next;
			e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len--
		}, e.len = function() {
			return this._len
		};
		var i = function(t) {
				this.value = t, this.next, this.prev
			},
			n = function(e) {
				this._list = new t, this._map = {}, this._maxSize = e || 10
			},
			r = n[de];
		return r.put = function(t, e) {
			var i = this._list,
				n = this._map;
			if (null == n[t]) {
				var r = i.len();
				if (r >= this._maxSize && r > 0) {
					var a = i.head;
					i[ee](a), delete n[a.key]
				}
				var o = i.insert(e);
				o.key = t, n[t] = o
			}
		}, r.get = function(t) {
			var e = this._map[t],
				i = this._list;
			return null != e ? (e !== i.tail && (i[ee](e), i.insertEntry(e)), e.value) : void 0
		}, r.clear = function() {
			this._list.clear(), this._map = {}
		}, n
	}), e("zrender/graphic/helper/roundRect", [ve], function() {
		return {
			buildPath: function(t, e) {
				var i, n, r, a, o = e.x,
					s = e.y,
					l = e.width,
					u = e[ae],
					c = e.r;
				0 > l && (o += l, l = -l), 0 > u && (s += u, u = -u), typeof c === V ? i = n = r = a = c : c instanceof Array ? 1 === c[$] ? i = n = r = a = c[0] : 2 === c[$] ? (i = r = c[0], n = a = c[1]) : 3 === c[$] ? (i = c[0], n = a = c[1], r = c[2]) : (i = c[0], n = c[1], r = c[2], a = c[3]) : i = n = r = a = 0;
				var h;
				i + n > l && (h = i + n, i *= l / h, n *= l / h), r + a > l && (h = r + a, r *= l / h, a *= l / h), n + r > u && (h = n + r, n *= u / h, r *= u / h), i + a > u && (h = i + a, i *= u / h, a *= u / h), t.moveTo(o + i, s), t.lineTo(o + l - n, s), 0 !== n && t.quadraticCurveTo(o + l, s, o + l, s + n), t.lineTo(o + l, s + u - r), 0 !== r && t.quadraticCurveTo(o + l, s + u, o + l - r, s + u), t.lineTo(o + a, s + u), 0 !== a && t.quadraticCurveTo(o, s + u, o, s + u - a), t.lineTo(o, s + i), 0 !== i && t.quadraticCurveTo(o, s, o + i, s)
			}
		}
	}), e("zrender/graphic/helper/poly", [ve, "./smoothSpline", "./smoothBezier"], function(t) {
		var e = t("./smoothSpline"),
			i = t("./smoothBezier");
		return {
			buildPath: function(t, n, r) {
				var a = n.points,
					o = n.smooth;
				if (a && a[$] >= 2) {
					if (o && "spline" !== o) {
						var s = i(a, o, r, n.smoothConstraint);
						t.moveTo(a[0][0], a[0][1]);
						for (var l = a[$], u = 0;
							(r ? l : l - 1) > u; u++) {
							var c = s[2 * u],
								h = s[2 * u + 1],
								d = a[(u + 1) % l];
							t.bezierCurveTo(c[0], c[1], h[0], h[1], d[0], d[1])
						}
					} else {
						"spline" === o && (a = e(a, r)), t.moveTo(a[0][0], a[0][1]);
						for (var u = 1, f = a[$]; f > u; u++) t.lineTo(a[u][0], a[u][1])
					}
					r && t.closePath()
				}
			}
		}
	}), e("zrender/graphic/helper/smoothSpline", [ve, "../../core/vector"], function(t) {
		function e(t, e, i, n, r, a, o) {
			var s = .5 * (i - t),
				l = .5 * (n - e);
			return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
		}
		var i = t("../../core/vector");
		return function(t, n) {
			for (var r = t[$], a = [], o = 0, s = 1; r > s; s++) o += i.distance(t[s - 1], t[s]);
			var l = o / 2;
			l = r > l ? r : l;
			for (var s = 0; l > s; s++) {
				var u, c, h, d = s / (l - 1) * (n ? r : r - 1),
					f = Math.floor(d),
					p = d - f,
					m = t[f % r];
				n ? (u = t[(f - 1 + r) % r], c = t[(f + 1) % r], h = t[(f + 2) % r]) : (u = t[0 === f ? f : f - 1], c = t[f > r - 2 ? r - 1 : f + 1], h = t[f > r - 3 ? r - 1 : f + 2]);
				var v = p * p,
					g = p * v;
				a.push([e(u[0], m[0], c[0], h[0], p, v, g), e(u[1], m[1], c[1], h[1], p, v, g)])
			}
			return a
		}
	}), e("zrender/graphic/helper/smoothBezier", [ve, "../../core/vector"], function(t) {
		var e = t("../../core/vector"),
			i = e.min,
			n = e.max,
			r = e.scale,
			a = e.distance,
			o = e.add;
		return function(t, s, l, u) {
			var c, h, d, f, p = [],
				m = [],
				v = [],
				g = [];
			if (u) {
				d = [1 / 0, 1 / 0], f = [-1 / 0, -1 / 0];
				for (var y = 0, x = t[$]; x > y; y++) i(d, d, t[y]), n(f, f, t[y]);
				i(d, d, u[0]), n(f, f, u[1])
			}
			for (var y = 0, x = t[$]; x > y; y++) {
				var _ = t[y];
				if (l) c = t[y ? y - 1 : x - 1], h = t[(y + 1) % x];
				else {
					if (0 === y || y === x - 1) {
						p.push(e.clone(t[y]));
						continue
					}
					c = t[y - 1], h = t[y + 1]
				}
				e.sub(m, h, c), r(m, m, s);
				var b = a(_, c),
					w = a(_, h),
					M = b + w;
				0 !== M && (b /= M, w /= M), r(v, m, -b), r(g, m, w);
				var S = o([], _, v),
					A = o([], _, g);
				u && (n(S, S, d), i(S, S, f), n(A, A, d), i(A, A, f)), p.push(S), p.push(A)
			}
			return l && p.push(p.shift()), p
		}
	}), e("zrender/Handler", [ve, "./core/env", "./core/event", "./core/util", "./mixin/Draggable", "./core/GestureMgr", "./mixin/Eventful"], function(t) {
		function e(t, e, i) {
			return {
				type: t,
				event: i,
				target: e,
				cancelBubble: !1,
				offsetX: i.zrX,
				offsetY: i.zrY,
				gestureEvent: i.gestureEvent,
				pinchX: i.pinchX,
				pinchY: i.pinchY,
				pinchScale: i.pinchScale,
				wheelDelta: i.zrDelta
			}
		}

		function i(t, e, i) {
			var n = t._gestureMgr;
			"start" === i && n.clear();
			var r = n.recognize(e, t.findHover(e.zrX, e.zrY, null));
			if ("end" === i && n.clear(), r) {
				var a = r.type;
				e.gestureEvent = a, t._dispatchProxy(r.target, a, r.event)
			}
		}

		function n(t) {
			function e(t, e) {
				return function() {
					return e._touching ? void 0 : t.apply(e, arguments)
				}
			}
			for (var i = g.concat(y), n = 0; n < i[$]; n++) {
				var r = i[n];
				t._handlers[r] = d.bind(M[r], t)
			}
			for (var n = 0; n < v[$]; n++) {
				var r = v[n];
				t._handlers[r] = e(M[r], t)
			}
		}

		function r(t, e, i) {
			if (t[t.rectHover ? "rectContain" : S](e, i)) {
				for (var n = t[c]; n;) {
					if (n.clipPath && !n.clipPath[S](e, i)) return !1;
					n = n[c]
				}
				return !0
			}
			return !1
		}

		function a(t) {
			t._touching = !0, clearTimeout(t._touchTimer), t._touchTimer = setTimeout(function() {
				t._touching = !1
			}, 700)
		}

		function o() {
			return !1
		}

		function s() {
			return u.touchEventsSupported
		}

		function l(t) {
			return "mousewheel" === t && u.browser.firefox ? "DOMMouseScroll" : t
		}
		var u = t("./core/env"),
			h = t("./core/event"),
			d = t("./core/util"),
			f = t("./mixin/Draggable"),
			p = t("./core/GestureMgr"),
			m = t("./mixin/Eventful"),
			v = ["click", "dblclick", "mousewheel", W];
		!o() && v.push("mouseup", "mousedown", "mousemove");
		var g = ["touchstart", "touchend", "touchmove"],
			y = ["pointerdown", "pointerup", "pointermove"],
			x = 300,
			_ = h.addEventListener,
			b = h.removeEventListener,
			w = h.normalizeEvent,
			M = {
				mousemove: function(t) {
					t = w(this.root, t);
					var e = t.zrX,
						i = t.zrY,
						n = this.findHover(e, i, null),
						r = this._hovered;
					this._hovered = n, this.root.style.cursor = n ? n.cursor : this._defaultCursorStyle, r && n !== r && r.__zr && this._dispatchProxy(r, W, t), this._dispatchProxy(n, "mousemove", t), n && n !== r && this._dispatchProxy(n, H, t)
				},
				mouseout: function(t) {
					t = w(this.root, t);
					var e = t.toElement || t.relatedTarget;
					if (e != this.root)
						for (; e && 9 != e.nodeType;) {
							if (e === this.root) return;
							e = e.parentNode
						}
					this._dispatchProxy(this._hovered, W, t), this[Q]("globalout", {
						event: t
					})
				},
				touchstart: function(t) {
					t = w(this.root, t), this._lastTouchMoment = new Date, i(this, t, "start"), M.mousemove.call(this, t), M.mousedown.call(this, t), a(this)
				},
				touchmove: function(t) {
					t = w(this.root, t), i(this, t, "change"), M.mousemove.call(this, t), a(this)
				},
				touchend: function(t) {
					t = w(this.root, t), i(this, t, "end"), M.mouseup.call(this, t), +new Date - this._lastTouchMoment < x && M.click.call(this, t), a(this)
				}
			};
		d.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick"], function(t) {
			M[t] = function(e) {
				e = w(this.root, e);
				var i = this.findHover(e.zrX, e.zrY, null);
				this._dispatchProxy(i, t, e)
			}
		});
		var A = function(t, e, i) {
			function r(e, i) {
				d.each(e, function(e) {
					_(t, l(e), i._handlers[e])
				}, i)
			}
			m.call(this), this.root = t, this.storage = e, this.painter = i, this._hovered, this._lastTouchMoment, this._lastX, this._lastY, this._defaultCursorStyle = "default", this._gestureMgr = new p, this._handlers = [], this._touching = !1, this._touchTimer, n(this), o() ? r(y, this) : s() && r(g, this), r(v, this), f.call(this)
		};
		return A[de] = {
			constructor: A,
			resize: function() {
				this._hovered = null
			},
			dispatch: function(t, e) {
				var i = this._handlers[t];
				i && i.call(this, e)
			},
			dispose: function() {
				for (var t = this.root, e = v.concat(g), i = 0; i < e[$]; i++) {
					var n = e[i];
					b(t, l(n), this._handlers[n])
				}
				this.root = this.storage = this.painter = null
			},
			setDefaultCursorStyle: function(t) {
				this._defaultCursorStyle = t
			},
			_dispatchProxy: function(t, i, n) {
				for (var r = "on" + i, a = e(i, t, n), o = t; o && (o[r] && (a.cancelBubble = o[r].call(o, a)), o[Q](i, a), o = o[c], !a.cancelBubble););
				a.cancelBubble || (this[Q](i, a), this.painter && this.painter.eachOtherLayer(function(t) {
					typeof t[r] == Z && t[r].call(t, a), t[Q] && t[Q](i, a)
				}))
			},
			findHover: function(t, e, i) {
				for (var n = this.storage.getDisplayList(), a = n[$] - 1; a >= 0; a--)
					if (!n[a].silent && n[a] !== i && !n[a][se] && r(n[a], t, e)) return n[a]
			}
		}, d.mixin(A, m), d.mixin(A, f), A
	}), e("zrender/Painter", [ve, "./config", "./core/util", "./core/log", "./core/BoundingRect", "./Layer", "./graphic/Image"], function(t) {
		function e(t) {
			return parseInt(t, 10)
		}

		function i(t) {
			return t ? t.isBuildin ? !0 : typeof t.resize !== Z || typeof t.refresh !== Z ? !1 : !0 : !1
		}

		function n(t) {
			t.__unusedCount++
		}

		function r(t) {
			t.__dirty = !1, 1 == t.__unusedCount && t.clear()
		}

		function a(t, e, i) {
			return m.copy(t[P]()), t.transform && m[p](t.transform), v.width = e, v[ae] = i, !m.intersect(v)
		}

		function s(t, e) {
			if (!t || !e || t[$] !== e[$]) return !0;
			for (var i = 0; i < t[$]; i++)
				if (t[i] !== e[i]) return !0
		}

		function l(t, e) {
			for (var i = 0; i < t[$]; i++) {
				var n, r = t[i];
				r.transform && (n = r.transform, e.transform(n[0], n[1], n[2], n[3], n[4], n[5]));
				var a = r.path;
				a.beginPath(e), r.buildPath(a, r.shape), e.clip(), r.transform && (n = r.invTransform, e.transform(n[0], n[1], n[2], n[3], n[4], n[5]))
			}
		}
		var u = t("./config"),
			c = t("./core/util"),
			h = t("./core/log"),
			d = t("./core/BoundingRect"),
			f = t("./Layer"),
			m = new d(0, 0, 0, 0),
			v = new d(0, 0, 0, 0),
			g = function(t, e, i) {
				var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();
				i = i || {}, this.dpr = i.devicePixelRatio || u.devicePixelRatio, this._singleCanvas = n, this.root = t;
				var r = t.style;
				if (r && (r["-webkit-tap-highlight-color"] = "transparent", r["-webkit-user-select"] = "none", r["user-select"] = "none", r["-webkit-touch-callout"] = "none", t.innerHTML = ""), this.storage = e, n) {
					var a = t.width,
						o = t[ae];
					this._width = a, this._height = o;
					var s = new f(t, this, 1);
					s.initContext(), this._layers = {
						0: s
					}, this._zlevelList = [0]
				} else {
					var a = this._getWidth(),
						o = this._getHeight();
					this._width = a, this._height = o;
					var l = document.createElement("div");
					this._domRoot = l;
					var c = l.style;
					c[L] = "relative", c.overflow = "hidden", c.width = this._width + "px", c[ae] = this._height + "px", t.appendChild(l), this._layers = {}, this._zlevelList = []
				}
				this._layerConfig = {}, this.pathToImage = this._createPathToImage()
			};
		return g[de] = {
			constructor: g,
			isSingleCanvas: function() {
				return this._singleCanvas
			},
			getViewportRoot: function() {
				return this._singleCanvas ? this._layers[0].dom : this._domRoot
			},
			refresh: function(t) {
				var e = this.storage.getDisplayList(!0),
					i = this._zlevelList;
				this._paintList(e, t);
				for (var n = 0; n < i[$]; n++) {
					var r = i[n],
						a = this._layers[r];
					!a.isBuildin && a.refresh && a.refresh()
				}
				return this
			},
			_paintList: function(t, e) {
				null == e && (e = !1), this._updateLayerStatus(t);
				var i, o, u, c = this._width,
					d = this._height;
				this.eachBuildinLayer(n);
				for (var f = null, p = 0, m = t[$]; m > p; p++) {
					var v = t[p],
						g = this._singleCanvas ? 0 : v.zlevel;
					if (o !== g && (o = g, i = this.getLayer(o), i.isBuildin || h("ZLevel " + o + " has been used by unkown layer " + i.id), u = i.ctx, i.__unusedCount = 0, (i.__dirty || e) && i.clear()), (i.__dirty || e) && !v.invisible && 0 !== v.style[C] && v.scale[0] && v.scale[1] && (!v.culling || !a(v, c, d))) {
						var y = v.__clipPaths;
						s(y, f) && (f && u.restore(), y && (u.save(), l(y, u)), f = y), v.beforeBrush && v.beforeBrush(u), v.brush(u, !1), v.afterBrush && v.afterBrush(u)
					}
					v.__dirty = !1
				}
				f && u.restore(), this.eachBuildinLayer(r)
			},
			getLayer: function(t) {
				if (this._singleCanvas) return this._layers[0];
				var e = this._layers[t];
				return e || (e = new f("zr_" + t, this, this.dpr), e.isBuildin = !0, this._layerConfig[t] && c.merge(e, this._layerConfig[t], !0), this.insertLayer(t, e), e.initContext()), e
			},
			insertLayer: function(t, e) {
				var n = this._layers,
					r = this._zlevelList,
					a = r[$],
					o = null,
					s = -1,
					l = this._domRoot;
				if (n[t]) return void h("ZLevel " + t + " has been used already");
				if (!i(e)) return void h("Layer of zlevel " + t + " is not valid");
				if (a > 0 && t > r[0]) {
					for (s = 0; a - 1 > s && !(r[s] < t && r[s + 1] > t); s++);
					o = n[r[s]]
				}
				if (r[X](s + 1, 0, t), o) {
					var u = o.dom;
					u.nextSibling ? l.insertBefore(e.dom, u.nextSibling) : l.appendChild(e.dom)
				} else l.firstChild ? l.insertBefore(e.dom, l.firstChild) : l.appendChild(e.dom);
				n[t] = e
			},
			eachLayer: function(t, e) {
				var i, n, r = this._zlevelList;
				for (n = 0; n < r[$]; n++) i = r[n], t.call(e, this._layers[i], i)
			},
			eachBuildinLayer: function(t, e) {
				var i, n, r, a = this._zlevelList;
				for (r = 0; r < a[$]; r++) n = a[r], i = this._layers[n], i.isBuildin && t.call(e, i, n)
			},
			eachOtherLayer: function(t, e) {
				var i, n, r, a = this._zlevelList;
				for (r = 0; r < a[$]; r++) n = a[r], i = this._layers[n], i.isBuildin || t.call(e, i, n)
			},
			getLayers: function() {
				return this._layers
			},
			_updateLayerStatus: function(t) {
				var e = this._layers,
					i = {};
				this.eachBuildinLayer(function(t, e) {
					i[e] = t.elCount, t.elCount = 0
				});
				for (var n = 0, r = t[$]; r > n; n++) {
					var a = t[n],
						o = this._singleCanvas ? 0 : a.zlevel,
						s = e[o];
					if (s) {
						if (s.elCount++, s.__dirty) continue;
						s.__dirty = a.__dirty
					}
				}
				this.eachBuildinLayer(function(t, e) {
					i[e] !== t.elCount && (t.__dirty = !0)
				})
			},
			clear: function() {
				return this.eachBuildinLayer(this._clearLayer), this
			},
			_clearLayer: function(t) {
				t.clear()
			},
			configLayer: function(t, e) {
				if (e) {
					var i = this._layerConfig;
					i[t] ? c.merge(i[t], e, !0) : i[t] = e;
					var n = this._layers[t];
					n && c.merge(n, i[t], !0)
				}
			},
			delLayer: function(t) {
				var e = this._layers,
					i = this._zlevelList,
					n = e[t];
				n && (n.dom.parentNode.removeChild(n.dom), delete e[t], i[X](c[N](i, t), 1))
			},
			resize: function(t, e) {
				var i = this._domRoot;
				if (i.style.display = "none", t = t || this._getWidth(), e = e || this._getHeight(), i.style.display = "", this._width != t || e != this._height) {
					i.style.width = t + "px", i.style[ae] = e + "px";
					for (var n in this._layers) this._layers[n].resize(t, e);
					this.refresh(!0)
				}
				return this._width = t, this._height = e, this
			},
			clearLayer: function(t) {
				var e = this._layers[t];
				e && e.clear()
			},
			dispose: function() {
				this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null
			},
			getRenderedCanvas: function(t) {
				if (t = t || {}, this._singleCanvas) return this._layers[0].dom;
				var e = new f("image", this, t.pixelRatio || this.dpr);
				e.initContext();
				var i = e.ctx;
				e.clearColor = t.backgroundColor, e.clear();
				for (var n = this.storage.getDisplayList(!0), r = 0; r < n[$]; r++) {
					var a = n[r];
					a.invisible || (a.beforeBrush && a.beforeBrush(i), a.brush(i, !1), a.afterBrush && a.afterBrush(i))
				}
				return e.dom
			},
			getWidth: function() {
				return this._width
			},
			getHeight: function() {
				return this._height
			},
			_getWidth: function() {
				var t = this.root,
					i = document.defaultView.getComputedStyle(t);
				return (t.clientWidth || e(i.width) || e(t.style.width)) - (e(i.paddingLeft) || 0) - (e(i.paddingRight) || 0) | 0
			},
			_getHeight: function() {
				var t = this.root,
					i = document.defaultView.getComputedStyle(t);
				return (t.clientHeight || e(i[ae]) || e(t.style[ae])) - (e(i.paddingTop) || 0) - (e(i.paddingBottom) || 0) | 0
			},
			_pathToImage: function(e, i, n, r, a) {
				var s = document.createElement("canvas"),
					l = s[M]("2d");
				s.width = n * a, s[ae] = r * a, l.clearRect(0, 0, n * a, r * a);
				var u = {
					position: i[L],
					rotation: i[o],
					scale: i.scale
				};
				i[L] = [0, 0, 0], i[o] = 0, i.scale = [1, 1], i && i.brush(l);
				var c = t("./graphic/Image"),
					h = new c({
						id: e,
						style: {
							x: 0,
							y: 0,
							image: s
						}
					});
				return null != u[L] && (h[L] = i[L] = u[L]), null != u[o] && (h[o] = i[o] = u[o]), null != u.scale && (h.scale = i.scale = u.scale), h
			},
			_createPathToImage: function() {
				var t = this;
				return function(e, i, n, r) {
					return t._pathToImage(e, i, n, r, t.dpr)
				}
			}
		}, g
	}), e("zrender/animation/Animation", [ve, l, "../core/event", "./Animator"], function(t) {
		var e = t(l),
			i = t("../core/event").Dispatcher,
			n = typeof window !== u && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(t) {
				setTimeout(t, 16)
			},
			r = t("./Animator"),
			a = function(t) {
				t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function() {}, this._clips = [], this._running = !1, this._time = 0, i.call(this)
			};
		return a[de] = {
			constructor: a,
			addClip: function(t) {
				this._clips.push(t)
			},
			addAnimator: function(t) {
				t.animation = this;
				for (var e = t.getClips(), i = 0; i < e[$]; i++) this.addClip(e[i])
			},
			removeClip: function(t) {
				var i = e[N](this._clips, t);
				i >= 0 && this._clips[X](i, 1)
			},
			removeAnimator: function(t) {
				for (var e = t.getClips(), i = 0; i < e[$]; i++) this.removeClip(e[i]);
				t.animation = null
			},
			_update: function() {
				for (var t = (new Date).getTime(), e = t - this._time, i = this._clips, n = i[$], r = [], a = [], o = 0; n > o; o++) {
					var s = i[o],
						l = s.step(t);
					l && (r.push(l), a.push(s))
				}
				for (var o = 0; n > o;) i[o]._needsRemove ? (i[o] = i[n - 1], i.pop(), n--) : o++;
				n = r[$];
				for (var o = 0; n > o; o++) a[o].fire(r[o]);
				this._time = t, this.onframe(e), this[Q]("frame", e), this.stage[ne] && this.stage[ne]()
			},
			start: function() {
				function t() {
					e._running && (n(t), e._update())
				}
				var e = this;
				this._running = !0, this._time = (new Date).getTime(), n(t)
			},
			stop: function() {
				this._running = !1
			},
			clear: function() {
				this._clips = []
			},
			animate: function(t, e) {
				e = e || {};
				var i = new r(t, e.loop, e.getter, e.setter);
				return i
			}
		}, e.mixin(a, i), a
	}), e("echarts/coord/axisHelper", [ve, "../scale/Ordinal", "../scale/Interval", "../scale/Time", "../scale/Log", "../scale/Scale", "../util/number", me, "zrender/contain/text"], function(t) {
		var e = t("../scale/Ordinal"),
			n = t("../scale/Interval");
		t("../scale/Time"), t("../scale/Log");
		var a = t("../scale/Scale"),
			o = t("../util/number"),
			s = t(me),
			l = t("zrender/contain/text"),
			u = {};
		return u.getScaleExtent = function(t, e) {
			var i = t.scale,
				n = i[A](),
				a = n[1] - n[0];
			if (i.type === r) return isFinite(a) ? n : [0, 0];
			var l = e.getMin ? e.getMin() : e.get("min"),
				u = e.getMax ? e.getMax() : e.get("max"),
				c = e.getNeedCrossZero ? e.getNeedCrossZero() : !e.get("scale"),
				h = e.get("boundaryGap");
			s[G](h) || (h = [h || 0, h || 0]), h[0] = o.parsePercent(h[0], 1), h[1] = o.parsePercent(h[1], 1);
			var d = !0,
				f = !0;
			return null == l && (l = n[0] - h[0] * a, d = !1), null == u && (u = n[1] + h[1] * a, f = !1), "dataMin" === l && (l = n[0]), "dataMax" === u && (u = n[1]), c && (l > 0 && u > 0 && !d && (l = 0), 0 > l && 0 > u && !f && (u = 0)), [l, u]
		}, u.niceScaleExtent = function(t, e) {
			var i = t.scale,
				n = u.getScaleExtent(t, e),
				r = null != (e.getMin ? e.getMin() : e.get("min")),
				a = null != (e.getMax ? e.getMax() : e.get("max"));
			i.setExtent(n[0], n[1]), i.niceExtent(e.get("splitNumber"), r, a);
			var o = e.get("interval");
			null != o && i.setInterval && i.setInterval(o)
		}, u.createScaleByModel = function(t, r) {
			if (r = r || t.get("type")) switch (r) {
				case i:
					return new e(t.getCategories(), [1 / 0, -1 / 0]);
				case "value":
					return new n;
				default:
					return (a.getClass(r) || n)[re](t)
			}
		}, u.ifAxisCrossZero = function(t) {
			var e = t.scale[A](),
				i = e[0],
				n = e[1];
			return !(i > 0 && n > 0 || 0 > i && 0 > n)
		}, u.getAxisLabelInterval = function(t, e, i, n) {
			var r, a = 0,
				o = 0,
				s = 1;
			e[$] > 40 && (s = Math.round(e[$] / 40));
			for (var u = 0; u < t[$]; u += s) {
				var c = t[u],
					h = l[P](e[u], i, k, "top");
				h[n ? "x" : "y"] += c, h[n ? "width" : ae] *= 1.5, r ? r.intersect(h) ? (o++, a = Math.max(a, o)) : (r.union(h), o = 0) : r = h.clone()
			}
			return 0 === a && s > 1 ? s : a * s
		}, u.getFormattedLabels = function(t, e) {
			var n = t.scale,
				r = n.getTicksLabels(),
				a = n.getTicks();
			return typeof e === he ? (e = function(t) {
				return function(e) {
					return t[F]("{value}", e)
				}
			}(e), s.map(r, e)) : typeof e === Z ? s.map(a, function(r, a) {
				return e(t.type === i ? n.getLabel(r) : r, a)
			}, this) : r
		}, u
	}), e("zrender/Storage", [ve, "./core/util", "./container/Group"], function(t) {
		function e(t, e) {
			return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 === e.z2 ? t.__renderidx - e.__renderidx : t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel
		}
		var i = t("./core/util"),
			n = t("./container/Group"),
			r = function() {
				this._elements = {}, this._roots = [], this._displayList = [], this._displayListLen = 0
			};
		return r[de] = {
			constructor: r,
			getDisplayList: function(t, e) {
				return e = e || !1, t && this.updateDisplayList(e), this._displayList
			},
			updateDisplayList: function(t) {
				this._displayListLen = 0;
				for (var i = this._roots, n = this._displayList, r = 0, a = i[$]; a > r; r++) this._updateAndAddDisplayable(i[r], null, t);
				n[$] = this._displayListLen;
				for (var r = 0, a = n[$]; a > r; r++) n[r].__renderidx = r;
				n.sort(e)
			},
			_updateAndAddDisplayable: function(t, e, i) {
				if (!t[se] || i) {
					t.beforeUpdate(), t[ne](), t.afterUpdate();
					var n = t.clipPath;
					if (n && (n[c] = t, n.updateTransform(), e ? (e = e.slice(), e.push(n)) : e = [n]), "group" == t.type) {
						for (var r = t._children, a = 0; a < r[$]; a++) {
							var o = r[a];
							o.__dirty = t.__dirty || o.__dirty, this._updateAndAddDisplayable(o, e, i)
						}
						t.__dirty = !1
					} else t.__clipPaths = e, this._displayList[this._displayListLen++] = t
				}
			},
			addRoot: function(t) {
				this._elements[t.id] || (t instanceof n && t.addChildrenToStorage(this), this.addToMap(t), this._roots.push(t))
			},
			delRoot: function(t) {
				if (null == t) {
					for (var e = 0; e < this._roots[$]; e++) {
						var r = this._roots[e];
						r instanceof n && r.delChildrenFromStorage(this)
					}
					return this._elements = {}, this._roots = [], this._displayList = [], void(this._displayListLen = 0)
				}
				if (t instanceof Array)
					for (var e = 0, a = t[$]; a > e; e++) this.delRoot(t[e]);
				else {
					var o;
					o = typeof t == he ? this._elements[t] : t;
					var s = i[N](this._roots, o);
					s >= 0 && (this.delFromMap(o.id), this._roots[X](s, 1), o instanceof n && o.delChildrenFromStorage(this))
				}
			},
			addToMap: function(t) {
				return t instanceof n && (t.__storage = this), t.dirty(), this._elements[t.id] = t, this
			},
			get: function(t) {
				return this._elements[t]
			},
			delFromMap: function(t) {
				var e = this._elements,
					i = e[t];
				return i && (delete e[t], i instanceof n && (i.__storage = null)), this
			},
			dispose: function() {
				this._elements = this._renderList = this._roots = null
			}
		}, r
	}), e("echarts/coord/cartesian/Cartesian2D", [ve, me, "./Cartesian"], function(t) {
		function e(t) {
			n.call(this, t)
		}
		var i = t(me),
			n = t("./Cartesian");
		return e[de] = {
			constructor: e,
			type: "cartesian2d",
			dimensions: ["x", "y"],
			getBaseAxis: function() {
				return this.getAxesByScale(r)[0] || this.getAxesByScale("time")[0] || this[a]("x")
			},
			containPoint: function(t) {
				var e = this[a]("x"),
					i = this[a]("y");
				return e[S](e.toLocalCoord(t[0])) && i[S](i.toLocalCoord(t[1]))
			},
			containData: function(t) {
				return this[a]("x").containData(t[0]) && this[a]("y").containData(t[1])
			},
			dataToPoints: function(t, e) {
				return t.mapArray(["x", "y"], function(t, e) {
					return this.dataToPoint([t, e])
				}, e, this)
			},
			dataToPoint: function(t, e) {
				var i = this[a]("x"),
					n = this[a]("y");
				return [i.toGlobalCoord(i.dataToCoord(t[0], e)), n.toGlobalCoord(n.dataToCoord(t[1], e))]
			},
			pointToData: function(t, e) {
				var i = this[a]("x"),
					n = this[a]("y");
				return [i.coordToData(i.toLocalCoord(t[0]), e), n.coordToData(n.toLocalCoord(t[1]), e)]
			},
			getOtherAxis: function(t) {
				return this[a]("x" === t.dim ? "y" : "x")
			}
		}, i[B](e, n), e
	}), e("echarts/coord/cartesian/GridModel", [ve, "./AxisModel", "../../model/Component"], function(t) {
		t("./AxisModel");
		var e = t("../../model/Component");
		return e[te]({
			type: "grid",
			dependencies: ["xAxis", "yAxis"],
			layoutMode: "box",
			coordinateSystem: null,
			defaultOption: {
				show: !1,
				zlevel: 0,
				z: 0,
				left: "10%",
				top: 60,
				right: "10%",
				bottom: 60,
				containLabel: !1,
				backgroundColor: "rgba(0,0,0,0)",
				borderWidth: 1,
				borderColor: "#ccc"
			}
		})
	}), e("echarts/coord/cartesian/Axis2D", [ve, me, "../Axis", "./axisLabelInterval"], function(t) {
		var e = t(me),
			n = t("../Axis"),
			r = t("./axisLabelInterval"),
			a = function(t, e, i, r, a) {
				n.call(this, t, e, i), this.type = r || "value", this[L] = a || oe
			};
		return a[de] = {
			constructor: a,
			index: 0,
			onZero: !1,
			model: null,
			isHorizontal: function() {
				var t = this[L];
				return "top" === t || t === oe
			},
			getGlobalExtent: function() {
				var t = this[A]();
				return t[0] = this.toGlobalCoord(t[0]), t[1] = this.toGlobalCoord(t[1]), t
			},
			getLabelInterval: function() {
				var t = this._labelInterval;
				return t || (t = this._labelInterval = r(this)), t
			},
			isLabelIgnored: function(t) {
				if (this.type === i) {
					var e = this.getLabelInterval();
					return typeof e === Z && !e(t, this.scale.getLabel(t)) || t % (e + 1)
				}
			},
			toLocalCoord: null,
			toGlobalCoord: null
		}, e[B](a, n), a
	}), e("zrender/core/event", [ve, "../mixin/Eventful"], function(t) {
		function e(t) {
			return t.getBoundingClientRect ? t.getBoundingClientRect() : {
				left: 0,
				top: 0
			}
		}

		function i(t, i) {
			if (i = i || window.event, null != i.zrX) return i;
			var n = i.type,
				r = n && n[N]("touch") >= 0;
			if (r) {
				var a = "touchend" != n ? i.targetTouches[0] : i.changedTouches[0];
				if (a) {
					var o = e(t);
					i.zrX = a.clientX - o.left, i.zrY = a.clientY - o.top
				}
			} else {
				var s = e(t);
				i.zrX = i.clientX - s.left, i.zrY = i.clientY - s.top, i.zrDelta = i.wheelDelta ? i.wheelDelta / 120 : -(i.detail || 0) / 3
			}
			return i
		}

		function n(t, e, i) {
			o ? t.addEventListener(e, i) : t.attachEvent("on" + e, i)
		}

		function r(t, e, i) {
			o ? t.removeEventListener(e, i) : t.detachEvent("on" + e, i)
		}
		var a = t("../mixin/Eventful"),
			o = typeof window !== u && !!window.addEventListener,
			s = o ? function(t) {
				t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0
			} : function(t) {
				t.returnValue = !1, t.cancelBubble = !0
			};
		return {
			normalizeEvent: i,
			addEventListener: n,
			removeEventListener: r,
			stop: s,
			Dispatcher: a
		}
	}), e("zrender/mixin/Draggable", [ve], function() {
		function t() {
			this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), this.on("mouseup", this._dragEnd, this), this.on("globalout", this._dragEnd, this)
		}
		return t[de] = {
			constructor: t,
			_dragStart: function(t) {
				var e = t.target;
				e && e.draggable && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this._dispatchProxy(e, "dragstart", t.event))
			},
			_drag: function(t) {
				var e = this._draggingTarget;
				if (e) {
					var i = t.offsetX,
						n = t.offsetY,
						r = i - this._x,
						a = n - this._y;
					this._x = i, this._y = n, e.drift(r, a, t), this._dispatchProxy(e, "drag", t.event);
					var o = this.findHover(i, n, e),
						s = this._dropTarget;
					this._dropTarget = o, e !== o && (s && o !== s && this._dispatchProxy(s, "dragleave", t.event), o && o !== s && this._dispatchProxy(o, "dragenter", t.event))
				}
			},
			_dragEnd: function(t) {
				var e = this._draggingTarget;
				e && (e.dragging = !1), this._dispatchProxy(e, "dragend", t.event), this._dropTarget && this._dispatchProxy(this._dropTarget, "drop", t.event), this._draggingTarget = null, this._dropTarget = null
			}
		}, t
	}), e("zrender/core/GestureMgr", [ve], function() {
		function t(t) {
			var e = t[1][0] - t[0][0],
				i = t[1][1] - t[0][1];
			return Math.sqrt(e * e + i * i)
		}

		function e(t) {
			return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]
		}
		var i = function() {
			this._track = []
		};
		i[de] = {
			constructor: i,
			recognize: function(t, e) {
				return this._doTrack(t, e), this._recognize(t)
			},
			clear: function() {
				return this._track[$] = 0, this
			},
			_doTrack: function(t, e) {
				var i = t.touches;
				if (i) {
					for (var n = {
							points: [],
							touches: [],
							target: e,
							event: t
						}, r = 0, a = i[$]; a > r; r++) {
						var o = i[r];
						n.points.push([o.clientX, o.clientY]), n.touches.push(o)
					}
					this._track.push(n)
				}
			},
			_recognize: function(t) {
				for (var e in n)
					if (n.hasOwnProperty(e)) {
						var i = n[e](this._track, t);
						if (i) return i
					}
			}
		};
		var n = {
			pinch: function(i, n) {
				var r = i[$];
				if (r) {
					var a = (i[r - 1] || {}).points,
						o = (i[r - 2] || {}).points || a;
					if (o && o[$] > 1 && a && a[$] > 1) {
						var s = t(a) / t(o);
						!isFinite(s) && (s = 1), n.pinchScale = s;
						var l = e(a);
						return n.pinchX = l[0], n.pinchY = l[1], {
							type: "pinch",
							target: i[0].target,
							event: n
						}
					}
				}
			}
		};
		return i
	}), e("echarts/scale/Ordinal", [ve, me, "./Scale"], function(t) {
		var e = t(me),
			i = t("./Scale"),
			n = i[de],
			r = i[te]({
				type: "ordinal",
				init: function(t, e) {
					this._data = t, this._extent = e || [0, t[$] - 1]
				},
				parse: function(t) {
					return typeof t === he ? e[N](this._data, t) : Math.round(t)
				},
				contain: function(t) {
					return t = this.parse(t), n[S].call(this, t) && null != this._data[t]
				},
				normalize: function(t) {
					return n.normalize.call(this, this.parse(t))
				},
				scale: function(t) {
					return Math.round(n.scale.call(this, t))
				},
				getTicks: function() {
					for (var t = [], e = this._extent, i = e[0]; i <= e[1];) t.push(i), i++;
					return t
				},
				getLabel: function(t) {
					return this._data[t]
				},
				count: function() {
					return this._extent[1] - this._extent[0] + 1
				},
				niceTicks: e.noop,
				niceExtent: e.noop
			});
		return r[re] = function() {
			return new r
		}, r
	}), e("echarts/coord/cartesian/Cartesian", [ve, me], function(t) {
		function e(t) {
			return this._axes[t]
		}
		var i = t(me),
			n = function(t) {
				this._axes = {}, this._dimList = [], this.name = t || ""
			};
		return n[de] = {
			constructor: n,
			type: "cartesian",
			getAxis: function(t) {
				return this._axes[t]
			},
			getAxes: function() {
				return i.map(this._dimList, e, this)
			},
			getAxesByScale: function(t) {
				return t = t[fe](), i[pe](this.getAxes(), function(e) {
					return e.scale.type === t
				})
			},
			addAxis: function(t) {
				var e = t.dim;
				this._axes[e] = t, this._dimList.push(e)
			},
			dataToCoord: function(t) {
				return this._dataCoordConvert(t, "dataToCoord")
			},
			coordToData: function(t) {
				return this._dataCoordConvert(t, "coordToData")
			},
			_dataCoordConvert: function(t, e) {
				for (var i = this._dimList, n = t instanceof Array ? [] : {}, r = 0; r < i[$]; r++) {
					var a = i[r],
						o = this._axes[a];
					n[a] = o[e](t[a])
				}
				return n
			}
		}, n
	}), e("zrender/Layer", [ve, "./core/util", "./config"], function(t) {
		function e() {
			return !1
		}

		function i(t, e, i, n) {
			var r = document.createElement(e),
				a = i[ue](),
				o = i[le](),
				s = r.style;
			return s[L] = "absolute", s.left = 0, s.top = 0, s.width = a + "px", s[ae] = o + "px", r.width = a * n, r[ae] = o * n, r.setAttribute("data-zr-dom-id", t), r
		}
		var n = t("./core/util"),
			r = t("./config"),
			a = function(t, a, o) {
				var s;
				o = o || r.devicePixelRatio, typeof t === he ? s = i(t, "canvas", a, o) : n[ie](t) && (s = t, t = s.id), this.id = t, this.dom = s;
				var l = s.style;
				l && (s.onselectstart = e, l["-webkit-user-select"] = "none", l["user-select"] = "none", l["-webkit-touch-callout"] = "none", l["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)"), this.domBack = null, this.ctxBack = null, this.painter = a, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = o
			};
		return a[de] = {
			constructor: a,
			elCount: 0,
			__dirty: !0,
			initContext: function() {
				this.ctx = this.dom[M]("2d");
				var t = this.dpr;
				1 != t && this.ctx.scale(t, t)
			},
			createBackBuffer: function() {
				var t = this.dpr;
				this.domBack = i("back-" + this.id, "canvas", this.painter, t), this.ctxBack = this.domBack[M]("2d"), 1 != t && this.ctxBack.scale(t, t)
			},
			resize: function(t, e) {
				var i = this.dpr,
					n = this.dom,
					r = n.style,
					a = this.domBack;
				r.width = t + "px", r[ae] = e + "px", n.width = t * i, n[ae] = e * i, 1 != i && this.ctx.scale(i, i), a && (a.width = t * i, a[ae] = e * i, 1 != i && this.ctxBack.scale(i, i))
			},
			clear: function(t) {
				var e = this.dom,
					i = this.ctx,
					n = e.width,
					r = e[ae],
					a = this.clearColor,
					o = this.motionBlur && !t,
					s = this.lastFrameAlpha,
					l = this.dpr;
				if (o && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(e, 0, 0, n / l, r / l)), i.clearRect(0, 0, n / l, r / l), a && (i.save(), i.fillStyle = this.clearColor, i.fillRect(0, 0, n / l, r / l), i.restore()), o) {
					var u = this.domBack;
					i.save(), i.globalAlpha = s, i.drawImage(u, 0, 0, n / l, r / l), i.restore()
				}
			}
		}, a
	}), e("echarts/coord/Axis", [ve, "../util/number", me], function(t) {
		function e(t, e) {
			var i = t[1] - t[0],
				n = e,
				r = i / n / 2;
			t[0] += r, t[1] -= r
		}
		var i = t("../util/number"),
			n = i.linearMap,
			a = t(me),
			o = [0, 1],
			s = function(t, e, i) {
				this.dim = t, this.scale = e, this._extent = i || [0, 0], this.inverse = !1, this.onBand = !1
			};
		return s[de] = {
			constructor: s,
			contain: function(t) {
				var e = this._extent,
					i = Math.min(e[0], e[1]),
					n = Math.max(e[0], e[1]);
				return t >= i && n >= t
			},
			containData: function(t) {
				return this[S](this.dataToCoord(t))
			},
			getExtent: function() {
				var t = this._extent.slice();
				return t
			},
			getPixelPrecision: function(t) {
				return i.getPixelPrecision(t || this.scale[A](), this._extent)
			},
			setExtent: function(t, e) {
				var i = this._extent;
				i[0] = t, i[1] = e
			},
			dataToCoord: function(t, i) {
				var a = this._extent,
					s = this.scale;
				return t = s.normalize(t), this.onBand && s.type === r && (a = a.slice(), e(a, s.count())), n(t, o, a, i)
			},
			coordToData: function(t, i) {
				var a = this._extent,
					s = this.scale;
				this.onBand && s.type === r && (a = a.slice(), e(a, s.count()));
				var l = n(t, a, o, i);
				return this.scale.scale(l)
			},
			getTicksCoords: function() {
				if (this.onBand) {
					for (var t = this.getBands(), e = [], i = 0; i < t[$]; i++) e.push(t[i][0]);
					return t[i - 1] && e.push(t[i - 1][1]), e
				}
				return a.map(this.scale.getTicks(), this.dataToCoord, this)
			},
			getLabelsCoords: function() {
				if (this.onBand) {
					for (var t, e = this.getBands(), i = [], n = 0; n < e[$]; n++) t = e[n], i.push((t[0] + t[1]) / 2);
					return i
				}
				return a.map(this.scale.getTicks(), this.dataToCoord, this)
			},
			getBands: function() {
				for (var t = this[A](), e = [], i = this.scale.count(), n = t[0], r = t[1], a = r - n, o = 0; i > o; o++) e.push([a * o / i + n, a * (o + 1) / i + n]);
				return e
			},
			getBandWidth: function() {
				var t = this._extent,
					e = this.scale[A](),
					i = e[1] - e[0] + (this.onBand ? 1 : 0);
				0 === i && (i = 1);
				var n = Math.abs(t[1] - t[0]);
				return Math.abs(n) / i
			}
		}, s
	}), e("echarts/coord/cartesian/axisLabelInterval", [ve, me, "../axisHelper"], function(t) {
		var e = t(me),
			n = t("../axisHelper");
		return function(t) {
			var r = t.model,
				a = r[ce]("axisLabel"),
				o = a.get("interval");
			return t.type !== i || "auto" !== o ? "auto" === o ? 0 : o : n.getAxisLabelInterval(e.map(t.scale.getTicks(), t.dataToCoord, t), r.getFormattedLabels(), a[ce](O)[D](), t.isHorizontal())
		}
	}), e("echarts/preprocessor/helper/compatStyle", [ve, me], function(t) {
		function e(t) {
			var e = t && t.itemStyle;
			e && i.each(n, function(n) {
				var r = e[d],
					a = e[f];
				r && r[n] && (t[n] = t[n] || {}, t[n][d] ? i.merge(t[n][d], r[n]) : t[n][d] = r[n], r[n] = null), a && a[n] && (t[n] = t[n] || {}, t[n][f] ? i.merge(t[n][f], a[n]) : t[n][f] = a[n], a[n] = null)
			})
		}
		var i = t(me),
			n = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
		return function(t) {
			if (t) {
				e(t), e(t.markPoint), e(t.markLine);
				var n = t.data;
				if (n) {
					for (var r = 0; r < n[$]; r++) e(n[r]);
					var a = t.markPoint;
					if (a && a.data)
						for (var o = a.data, r = 0; r < o[$]; r++) e(o[r]);
					var s = t.markLine;
					if (s && s.data)
						for (var l = s.data, r = 0; r < l[$]; r++) i[G](l[r]) ? (e(l[r][0]), e(l[r][1])) : e(l[r])
				}
			}
		}
	}), e("echarts/coord/cartesian/AxisModel", [ve, "../../model/Component", me, "../axisModelCreator", "../axisModelCommonMixin"], function(t) {
		function e(t, e) {
			return e.type || (e.data ? i : "value")
		}
		var n = t("../../model/Component"),
			r = t(me),
			a = t("../axisModelCreator"),
			o = n[te]({
				type: "cartesian2dAxis",
				axis: null,
				init: function() {
					o.superApply(this, "init", arguments), this._resetRange()
				},
				mergeOption: function() {
					o.superApply(this, x, arguments), this._resetRange()
				},
				restoreData: function() {
					o.superApply(this, "restoreData", arguments), this._resetRange()
				},
				setRange: function(t, e) {
					this[_].rangeStart = t, this[_].rangeEnd = e
				},
				getMin: function() {
					var t = this[_];
					return null != t.rangeStart ? t.rangeStart : t.min
				},
				getMax: function() {
					var t = this[_];
					return null != t.rangeEnd ? t.rangeEnd : t.max
				},
				getNeedCrossZero: function() {
					var t = this[_];
					return null != t.rangeStart || null != t.rangeEnd ? !1 : !t.scale
				},
				_resetRange: function() {
					this[_].rangeStart = this[_].rangeEnd = null
				}
			});
		r.merge(o[de], t("../axisModelCommonMixin"));
		var s = {
			gridIndex: 0
		};
		return a("x", o, e, s), a("y", o, e, s), o
	}), e("echarts/chart/helper/createListFromArray", [ve, "../../data/List", "../../data/helper/completeDimensions", me, "../../util/model", "../../CoordinateSystem"], function(t) {
		function e(t) {
			for (var e = 0; e < t[$] && null == t[e];) e++;
			return t[e]
		}

		function n(t) {
			var i = e(t);
			return null != i && !h[G](p(i))
		}

		function a(t, e, i) {
			t = t || [];
			var a = e.get(R),
				o = v[a],
				s = f.get(a),
				h = o && o(t, e, i),
				d = h && h[w];
			d || (d = s && s[w] || ["x", "y"], d = c(d, t, d.concat(["value"])));
			var g = h && h.categoryAxisModel,
				y = d[0].type === r ? 0 : d[1].type === r ? 1 : -1,
				x = new u(d, e),
				_ = l(h, t),
				b = g && n(t) ? function(t, e, i, n) {
					return n === y ? i : m(p(t), d[n])
				} : function(t, e, i, n) {
					var r = p(t);
					return m(r && r[n], d[n])
				};
			return x.initData(t, _, b), x
		}

		function o(t) {
			return t !== i && "time" !== t
		}

		function s(t) {
			return t === i ? r : "time" === t ? "time" : "float"
		}

		function l(t, e) {
			var i = [];
			if (t && t.categoryAxisModel) {
				var n = t.categoryAxisModel.getCategories();
				if (n) {
					var r = e[$];
					if (h[G](e[0]) && e[0][$] > 1) {
						i = [];
						for (var a = 0; r > a; a++) i[a] = n[e[a][t.categoryIndex || 0]]
					} else i = n.slice(0)
				}
			}
			return i
		}
		var u = t("../../data/List"),
			c = t("../../data/helper/completeDimensions"),
			h = t(me),
			d = t("../../util/model"),
			f = t("../../CoordinateSystem"),
			p = d.getDataItemValue,
			m = d.converDataValue,
			v = {
				cartesian2d: function(t, e, n) {
					var r = n[y]("xAxis", e.get("xAxisIndex")),
						a = n[y]("yAxis", e.get("yAxisIndex")),
						l = r.get("type"),
						u = a.get("type"),
						h = [{
							name: "x",
							type: s(l),
							stackable: o(l)
						}, {
							name: "y",
							type: s(u),
							stackable: o(u)
						}],
						d = l === i;
					return c(h, t, ["x", "y", "z"]), {
						dimensions: h,
						categoryIndex: d ? 0 : 1,
						categoryAxisModel: d ? r : u === i ? a : null
					}
				},
				polar: function(t, e, n) {
					var r = e.get("polarIndex") || 0,
						a = function(t) {
							return t.get("polarIndex") === r
						},
						l = n.findComponents({
							mainType: "angleAxis",
							filter: a
						})[0],
						u = n.findComponents({
							mainType: "radiusAxis",
							filter: a
						})[0],
						h = u.get("type"),
						d = l.get("type"),
						f = [{
							name: "radius",
							type: s(h),
							stackable: o(h)
						}, {
							name: "angle",
							type: s(d),
							stackable: o(d)
						}],
						p = d === i;
					return c(f, t, ["radius", "angle", "value"]), {
						dimensions: f,
						categoryIndex: p ? 1 : 0,
						categoryAxisModel: p ? l : h === i ? u : null
					}
				},
				geo: function(t) {
					return {
						dimensions: c([{
							name: "lng"
						}, {
							name: "lat"
						}], t, ["lng", "lat", "value"])
					}
				}
			};
		return a
	}), e("echarts/chart/helper/dataSelectableMixin", [ve, me], function(t) {
		var e = t(me);
		return {
			updateSelectedMap: function() {
				var t = this[_];
				this._dataOptMap = e.reduce(t.data, function(t, e) {
					return t[e.name] = e, t
				}, {})
			},
			select: function(t) {
				var i = this._dataOptMap,
					n = i[t],
					r = this.get("selectedMode");
				"single" === r && e.each(i, function(t) {
					t.selected = !1
				}), n && (n.selected = !0)
			},
			unSelect: function(t) {
				var e = this._dataOptMap[t];
				e && (e.selected = !1)
			},
			toggleSelected: function(t) {
				var e = this._dataOptMap[t];
				return null != e ? (this[e.selected ? "unSelect" : "select"](t), e.selected) : void 0
			},
			isSelected: function(t) {
				var e = this._dataOptMap[t];
				return e && e.selected
			}
		}
	}), e("echarts/util/symbol", [ve, "./graphic", "zrender/core/BoundingRect"], function(t) {
		var e = t("./graphic"),
			i = t("zrender/core/BoundingRect"),
			n = e.extendShape({
				type: "triangle",
				shape: {
					cx: 0,
					cy: 0,
					width: 0,
					height: 0
				},
				buildPath: function(t, e) {
					var i = e.cx,
						n = e.cy,
						r = e.width / 2,
						a = e[ae] / 2;
					t.moveTo(i, n - a), t.lineTo(i + r, n + a), t.lineTo(i - r, n + a), t.closePath()
				}
			}),
			r = e.extendShape({
				type: "diamond",
				shape: {
					cx: 0,
					cy: 0,
					width: 0,
					height: 0
				},
				buildPath: function(t, e) {
					var i = e.cx,
						n = e.cy,
						r = e.width / 2,
						a = e[ae] / 2;
					t.moveTo(i, n - a), t.lineTo(i + r, n), t.lineTo(i, n + a), t.lineTo(i - r, n), t.closePath()
				}
			}),
			a = e.extendShape({
				type: "pin",
				shape: {
					x: 0,
					y: 0,
					width: 0,
					height: 0
				},
				buildPath: function(t, e) {
					var i = e.x,
						n = e.y,
						r = e.width / 5 * 3,
						a = Math.max(r, e[ae]),
						o = r / 2,
						s = o * o / (a - o),
						l = n - a + o + s,
						u = Math.asin(s / o),
						c = Math.cos(u) * o,
						h = Math.sin(u),
						d = Math.cos(u);
					t.arc(i, l, o, Math.PI - u, 2 * Math.PI + u);
					var f = .6 * o,
						p = .7 * o;
					t.bezierCurveTo(i + c - h * f, l + s + d * f, i, n - p, i, n), t.bezierCurveTo(i, n - p, i - c + h * f, l + s + d * f, i - c, l + s), t.closePath()
				}
			}),
			o = e.extendShape({
				type: "arrow",
				shape: {
					x: 0,
					y: 0,
					width: 0,
					height: 0
				},
				buildPath: function(t, e) {
					var i = e[ae],
						n = e.width,
						r = e.x,
						a = e.y,
						o = n / 3 * 2;
					t.moveTo(r, a), t.lineTo(r + o, a + i), t.lineTo(r, a + i / 4 * 3), t.lineTo(r - o, a + i), t.lineTo(r, a), t.closePath()
				}
			}),
			s = {
				line: e.Line,
				rect: e.Rect,
				roundRect: e.Rect,
				square: e.Rect,
				circle: e.Circle,
				diamond: r,
				pin: a,
				arrow: o,
				triangle: n
			},
			l = {
				line: function(t, e, i, n, r) {
					r.x1 = t, r.y1 = e + n / 2, r.x2 = t + i, r.y2 = e + n / 2
				},
				rect: function(t, e, i, n, r) {
					r.x = t, r.y = e, r.width = i, r[ae] = n
				},
				roundRect: function(t, e, i, n, r) {
					r.x = t, r.y = e, r.width = i, r[ae] = n, r.r = Math.min(i, n) / 4
				},
				square: function(t, e, i, n, r) {
					var a = Math.min(i, n);
					r.x = t, r.y = e, r.width = a, r[ae] = a
				},
				circle: function(t, e, i, n, r) {
					r.cx = t + i / 2, r.cy = e + n / 2, r.r = Math.min(i, n) / 2
				},
				diamond: function(t, e, i, n, r) {
					r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r[ae] = n
				},
				pin: function(t, e, i, n, r) {
					r.x = t + i / 2, r.y = e + n / 2, r.width = i, r[ae] = n
				},
				arrow: function(t, e, i, n, r) {
					r.x = t + i / 2, r.y = e + n / 2, r.width = i, r[ae] = n
				},
				triangle: function(t, e, i, n, r) {
					r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r[ae] = n
				}
			},
			u = {};
		for (var c in s) u[c] = new s[c];
		var h = e.extendShape({
				type: "symbol",
				shape: {
					symbolType: "",
					x: 0,
					y: 0,
					width: 0,
					height: 0
				},
				beforeBrush: function() {
					var t = this.style,
						e = this.shape;
					"pin" === e.symbolType && "inside" === t.textPosition && (t.textPosition = ["50%", "40%"], t[I] = k, t.textVerticalAlign = z)
				},
				buildPath: function(t, e) {
					var i = e.symbolType,
						n = u[i];
					"none" !== e.symbolType && (n || (i = "rect", n = u[i]), l[i](e.x, e.y, e.width, e[ae], n.shape), n.buildPath(t, n.shape))
				}
			}),
			d = function(t) {
				if ("image" !== this.type) {
					var e = this.style,
						i = this.shape;
					i && "line" === i.symbolType ? e.stroke = t : this.__isEmptyBrush ? (e.stroke = t, e.fill = "#fff") : (e.fill && (e.fill = t), e.stroke && (e.stroke = t)), this.dirty()
				}
			},
			f = {
				createSymbol: function(t, n, r, a, o, s) {
					var l = 0 === t[N]("empty");
					l && (t = t.substr(5, 1)[fe]() + t.substr(6));
					var u;
					return u = 0 === t[N]("image://") ? new e.Image({
						style: {
							image: t.slice(8),
							x: n,
							y: r,
							width: a,
							height: o
						}
					}) : 0 === t[N]("path://") ? e.makePath(t.slice(7), {}, new i(n, r, a, o)) : new h({
						shape: {
							symbolType: t,
							x: n,
							y: r,
							width: a,
							height: o
						}
					}), u.__isEmptyBrush = l, u.setColor = d, u.setColor(s), u
				}
			};
		return f
	}), e("echarts/data/helper/completeDimensions", [ve, me], function(t) {
		function e(t, e, a, o) {
			if (!e) return t;
			var s = n(e[0]),
				l = r[G](s) && s[$] || 1;
			a = a || [], o = o || "extra";
			for (var u = 0; l > u; u++)
				if (!t[u]) {
					var c = a[u] || o + (u - a[$]);
					t[u] = i(e, u) ? {
						type: "ordinal",
						name: c
					} : c
				}
			return t
		}

		function i(t, e) {
			for (var i = 0, a = t[$]; a > i; i++) {
				var o = n(t[i]);
				if (!r[G](o)) return !1;
				var o = o[e];
				if (null != o && isFinite(o)) return !1;
				if (r.isString(o) && "-" !== o) return !0
			}
			return !1
		}

		function n(t) {
			return r[G](t) ? t : r[ie](t) ? t.value : t
		}
		var r = t(me);
		return e
	}), e("echarts/data/List", [ve, "../model/Model", "./DataDiffer", me, "../util/model"], function(t) {
		function e(t) {
			return d[G](t) || (t = [t]), t
		}

		function i(t, e) {
			var i = t[w],
				n = new _(d.map(i, t.getDimensionInfo, t), t.hostModel);
			x(n, t, t._wrappedMethods);
			for (var r = n._storage = {}, a = t._storage, o = 0; o < i[$]; o++) {
				var s = i[o],
					l = a[s];
				r[s] = d[N](e, s) >= 0 ? new l.constructor(a[s][$]) : a[s]
			}
			return n
		}
		var n = u,
			a = typeof window === u ? global : window,
			o = typeof a.Float64Array === n ? Array : a.Float64Array,
			s = typeof a.Int32Array === n ? Array : a.Int32Array,
			l = {
				"float": o,
				"int": s,
				ordinal: Array,
				number: Array,
				time: Array
			},
			c = t("../model/Model"),
			h = t("./DataDiffer"),
			d = t(me),
			f = t("../util/model"),
			p = d[ie],
			y = ["stackedOn", "_nameList", "_idList", "_rawData"],
			x = function(t, e, i) {
				d.each(y.concat(i || []), function(i) {
					e.hasOwnProperty(i) && (t[i] = e[i])
				})
			},
			_ = function(t, e) {
				t = t || ["x", "y"];
				for (var i = {}, n = [], r = 0; r < t[$]; r++) {
					var a, o = {};
					typeof t[r] === he ? (a = t[r], o = {
						name: a,
						stackable: !1,
						type: "number"
					}) : (o = t[r], a = o.name, o.type = o.type || V), n.push(a), i[a] = o
				}
				this[w] = n, this._dimensionInfos = i, this.hostModel = e, this.indices = [], this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this.stackedOn = null, this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._rawData, this._extent
			},
			M = _[de];
		M.type = "list", M.getDimension = function(t) {
			return isNaN(t) || (t = this[w][t] || t), t
		}, M.getDimensionInfo = function(t) {
			return d.clone(this._dimensionInfos[this.getDimension(t)])
		}, M.initData = function(t, e, i) {
			t = t || [], this._rawData = t;
			var n = this._storage = {},
				r = this.indices = [],
				a = this[w],
				o = t[$],
				s = this._dimensionInfos,
				u = [],
				c = {};
			e = e || [];
			for (var h = 0; h < a[$]; h++) {
				var p = s[a[h]],
					m = l[p.type];
				n[a[h]] = new m(o)
			}
			i = i || function(t, e, i, n) {
				var r = f.getDataItemValue(t);
				return f.converDataValue(d[G](r) ? r[n] : r, s[e])
			};
			for (var v = 0; v < t[$]; v++) {
				for (var g = t[v], y = 0; y < a[$]; y++) {
					var x = a[y],
						_ = n[x];
					_[v] = i(g, x, v, y)
				}
				r.push(v)
			}
			for (var h = 0; h < t[$]; h++) {
				var b = "";
				e[h] || (e[h] = t[h].name, b = t[h].id);
				var M = e[h] || "";
				!b && M && (c[M] = c[M] || 0, b = M, c[M] > 0 && (b += "__ec__" + c[M]), c[M]++), b && (u[h] = b)
			}
			this._nameList = e, this._idList = u
		}, M.count = function() {
			return this.indices[$]
		}, M.get = function(t, e, i) {
			var n = this._storage,
				r = this.indices[e];
			if (null == r) return 0 / 0;
			var a = n[t] && n[t][r];
			if (i) {
				var o = this._dimensionInfos[t];
				if (o && o.stackable)
					for (var s = this.stackedOn; s;) {
						var l = s.get(t, e);
						(a >= 0 && l > 0 || 0 >= a && 0 > l) && (a += l), s = s.stackedOn
					}
			}
			return a
		}, M.getValues = function(t, e, i) {
			var n = [];
			d[G](t) || (i = e, e = t, t = this[w]);
			for (var r = 0, a = t[$]; a > r; r++) n.push(this.get(t[r], e, i));
			return n
		}, M.hasValue = function(t) {
			for (var e = this[w], i = this._dimensionInfos, n = 0, a = e[$]; a > n; n++)
				if (i[e[n]].type !== r && isNaN(this.get(e[n], t))) return !1;
			return !0
		}, M.getDataExtent = function(t, e) {
			var i = this._storage[t],
				n = this.getDimensionInfo(t);
			e = n && n.stackable && e;
			var r, a = (this._extent || (this._extent = {}))[t + !!e];
			if (a) return a;
			if (i) {
				for (var o = 1 / 0, s = -1 / 0, l = 0, u = this.count(); u > l; l++) r = this.get(t, l, e), o > r && (o = r), r > s && (s = r);
				return this._extent[t + e] = [o, s]
			}
			return [1 / 0, -1 / 0]
		}, M.getSum = function(t, e) {
			var i = this._storage[t],
				n = 0;
			if (i)
				for (var r = 0, a = this.count(); a > r; r++) {
					var o = this.get(t, r, e);
					isNaN(o) || (n += o)
				}
			return n
		}, M[N] = function(t, e) {
			var i = this._storage,
				n = i[t],
				r = this.indices;
			if (n)
				for (var a = 0, o = r[$]; o > a; a++) {
					var s = r[a];
					if (n[s] === e) return a
				}
			return -1
		}, M.indexOfName = function(t) {
			for (var e = this.indices, i = this._nameList, n = 0, r = e[$]; r > n; n++) {
				var a = e[n];
				if (i[a] === t) return n
			}
			return -1
		}, M.indexOfNearest = function(t, e, i) {
			var n = this._storage,
				r = n[t];
			if (r) {
				for (var a = Number.MAX_VALUE, o = -1, s = 0, l = this.count(); l > s; s++) {
					var u = e - this.get(t, s, i),
						c = Math.abs(u);
					(a > c || c === a && u > 0) && (a = c, o = s)
				}
				return o
			}
			return -1
		}, M.getRawIndex = function(t) {
			var e = this.indices[t];
			return null == e ? -1 : e
		}, M[g] = function(t) {
			return this._nameList[this.indices[t]] || ""
		}, M.getId = function(t) {
			return this._idList[this.indices[t]] || this.getRawIndex(t) + ""
		}, M.each = function(t, i, n, r) {
			typeof t === Z && (r = n, n = i, i = t, t = []), t = d.map(e(t), this.getDimension, this);
			var a = [],
				o = t[$],
				s = this.indices;
			r = r || this;
			for (var l = 0; l < s[$]; l++)
				if (0 === o) i.call(r, l);
				else if (1 === o) i.call(r, this.get(t[0], l, n), l);
			else {
				for (var u = 0; o > u; u++) a[u] = this.get(t[u], l, n);
				a[u] = l, i.apply(r, a)
			}
		}, M.filterSelf = function(t, i, n, r) {
			typeof t === Z && (r = n, n = i, i = t, t = []), t = d.map(e(t), this.getDimension, this);
			var a = [],
				o = [],
				s = t[$],
				l = this.indices;
			r = r || this;
			for (var u = 0; u < l[$]; u++) {
				var c;
				if (1 === s) c = i.call(r, this.get(t[0], u, n), u);
				else {
					for (var h = 0; s > h; h++) o[h] = this.get(t[h], u, n);
					o[h] = u, c = i.apply(r, o)
				}
				c && a.push(l[u])
			}
			return this.indices = a, this._extent = {}, this
		}, M.mapArray = function(t, e, i, n) {
			typeof t === Z && (n = i, i = e, e = t, t = []);
			var r = [];
			return this.each(t, function() {
				r.push(e && e.apply(this, arguments))
			}, i, n), r
		}, M.map = function(t, n, r, a) {
			t = d.map(e(t), this.getDimension, this);
			var o = i(this, t),
				s = o.indices = this.indices,
				l = o._storage,
				u = [];
			return this.each(t, function() {
				var e = arguments[arguments[$] - 1],
					i = n && n.apply(this, arguments);
				if (null != i) {
					typeof i === V && (u[0] = i, i = u);
					for (var r = 0; r < i[$]; r++) {
						var a = t[r],
							o = l[a],
							c = s[e];
						o && (o[c] = i[r])
					}
				}
			}, r, a), o
		}, M.downSample = function(t, e, n, r) {
			for (var a = i(this, [t]), o = this._storage, s = a._storage, l = this.indices, u = a.indices = [], c = [], h = [], d = Math.floor(1 / e), f = s[t], p = this.count(), m = 0; m < o[t][$]; m++) s[t][m] = o[t][m];
			for (var m = 0; p > m; m += d) {
				d > p - m && (d = p - m, c[$] = d);
				for (var v = 0; d > v; v++) {
					var g = l[m + v];
					c[v] = f[g], h[v] = g
				}
				var y = n(c),
					g = h[r(c, y) || 0];
				f[g] = y, u.push(g)
			}
			return a
		}, M[b] = function(t) {
			var e = this.hostModel;
			return t = this.indices[t], new c(this._rawData[t], e, e[m])
		}, M.diff = function(t) {
			var e = this._idList,
				i = t && t._idList;
			return new h(t ? t.indices : [], this.indices, function(t) {
				return i[t] || t + ""
			}, function(t) {
				return e[t] || t + ""
			})
		}, M.getVisual = function(t) {
			var e = this._visual;
			return e && e[t]
		}, M.setVisual = function(t, e) {
			if (p(t))
				for (var i in t) t.hasOwnProperty(i) && this.setVisual(i, t[i]);
			else this._visual = this._visual || {}, this._visual[t] = e
		}, M.setLayout = function(t, e) {
			if (p(t))
				for (var i in t) t.hasOwnProperty(i) && this.setLayout(i, t[i]);
			else this._layout[t] = e
		}, M.getLayout = function(t) {
			return this._layout[t]
		}, M.getItemLayout = function(t) {
			return this._itemLayouts[t]
		}, M.setItemLayout = function(t, e, i) {
			this._itemLayouts[t] = i ? d[te](this._itemLayouts[t] || {}, e) : e
		}, M[v] = function(t, e, i) {
			var n = this._itemVisuals[t],
				r = n && n[e];
			return null != r || i ? r : this.getVisual(e)
		}, M.setItemVisual = function(t, e, i) {
			var n = this._itemVisuals[t] || {};
			if (this._itemVisuals[t] = n, p(e))
				for (var r in e) e.hasOwnProperty(r) && (n[r] = e[r]);
			else n[e] = i
		};
		var S = function(t) {
			t[q] = this[q], t.dataIndex = this.dataIndex
		};
		return M.setItemGraphicEl = function(t, e) {
			var i = this.hostModel;
			e && (e.dataIndex = t, e[q] = i && i[q], "group" === e.type && e.traverse(S, e)), this._graphicEls[t] = e
		}, M.getItemGraphicEl = function(t) {
			return this._graphicEls[t]
		}, M.eachItemGraphicEl = function(t, e) {
			d.each(this._graphicEls, function(i, n) {
				i && t && t.call(e, i, n)
			})
		}, M.cloneShallow = function() {
			var t = d.map(this[w], this.getDimensionInfo, this),
				e = new _(t, this.hostModel);
			return e._storage = this._storage, x(e, this, this._wrappedMethods), e.indices = this.indices.slice(), e
		}, M.wrapMethod = function(t, e) {
			var i = this[t];
			typeof i === Z && (this._wrappedMethods = this._wrappedMethods || [], this._wrappedMethods.push(t), this[t] = function() {
				var t = i.apply(this, arguments);
				return e.call(this, t)
			})
		}, _
	}), e("echarts/component/helper/listComponent", [ve, "../../util/layout", "../../util/format", "../../util/graphic"], function(t) {
		function e(t, e, n) {
			i.positionGroup(t, e.getBoxLayoutParams(), {
				width: n[ue](),
				height: n[le]()
			}, e.get("padding"))
		}
		var i = t("../../util/layout"),
			n = t("../../util/format"),
			r = t("../../util/graphic");
		return {
			layout: function(t, n, r) {
				var a = i.getLayoutRect(n.getBoxLayoutParams(), {
					width: r[ue](),
					height: r[le]()
				}, n.get("padding"));
				i.box(n.get("orient"), t, n.get("itemGap"), a.width, a[ae]), e(t, n, r)
			},
			addBackground: function(t, e) {
				var i = n.normalizeCssArray(e.get("padding")),
					a = t[P](),
					o = e.getItemStyle(["color", C]);
				o.fill = e.get("backgroundColor");
				var s = new r.Rect({
					shape: {
						x: a.x - i[3],
						y: a.y - i[0],
						width: a.width + i[1] + i[3],
						height: a[ae] + i[0] + i[2]
					},
					style: o,
					silent: !0,
					z2: -1
				});
				r.subPixelOptimizeRect(s), t.add(s)
			}
		}
	}), e("echarts/chart/helper/SymbolDraw", [ve, "../../util/graphic", "./Symbol"], function(t) {
		function e(t) {
			this.group = new n.Group, this._symbolCtor = t || r
		}

		function i(t, e, i) {
			var n = t.getItemLayout(e);
			return !(!n || isNaN(n[0]) || isNaN(n[1]) || i && i(e) || "none" === t[v](e, "symbol"))
		}
		var n = t("../../util/graphic"),
			r = t("./Symbol"),
			a = e[de];
		return a.updateData = function(t, e) {
			var r = this.group,
				a = t.hostModel,
				o = this._data,
				s = this._symbolCtor;
			t.diff(o).add(function(n) {
				var a = t.getItemLayout(n);
				if (i(t, n, e)) {
					var o = new s(t, n);
					o.attr(L, a), t.setItemGraphicEl(n, o), r.add(o)
				}
			})[ne](function(l, u) {
				var c = o.getItemGraphicEl(u),
					h = t.getItemLayout(l);
				return i(t, l, e) ? (c ? (c.updateData(t, l), n.updateProps(c, {
					position: h
				}, a)) : (c = new s(t, l), c.attr(L, h)), r.add(c), void t.setItemGraphicEl(l, c)) : void r[ee](c)
			})[ee](function(t) {
				var e = o.getItemGraphicEl(t);
				e && e.fadeOut(function() {
					r[ee](e)
				})
			}).execute(), this._data = t
		}, a.updateLayout = function() {
			var t = this._data;
			t && t.eachItemGraphicEl(function(e, i) {
				e.attr(L, t.getItemLayout(i))
			})
		}, a[ee] = function(t) {
			var e = this.group,
				i = this._data;
			i && (t ? i.eachItemGraphicEl(function(t) {
				t.fadeOut(function() {
					e[ee](t)
				})
			}) : e[E]())
		}, e
	}), e("echarts/component/marker/markerHelper", [ve, me, n], function(t) {
		function e(t, e, i) {
			var n = -1;
			do n = Math.max(o.getPrecision(t.get(e, i)), n), t = t.stackedOn; while (t);
			return n
		}

		function i(t, i, n, r, a, o) {
			var s = [],
				l = p(i, r, t),
				u = i.indexOfNearest(r, l, !0);
			s[a] = i.get(n, u, !0), s[o] = i.get(r, u, !0);
			var c = e(i, r, u);
			return c >= 0 && (s[o] = +s[o].toFixed(c)), s
		}
		var r = t(me),
			o = t(n),
			s = r[N],
			l = r.curry,
			u = {
				min: l(i, "min"),
				max: l(i, "max"),
				average: l(i, "average")
			},
			c = function(t, e) {
				var i = t[U](),
					n = t[R];
				if ((isNaN(e.x) || isNaN(e.y)) && !r[G](e.coord) && n) {
					var a = h(e, i, n, t);
					if (e = r.clone(e), e.type && u[e.type] && a.baseAxis && a.valueAxis) {
						var o = n[w],
							l = s(o, a.baseAxis.dim),
							c = s(o, a.valueAxis.dim);
						e.coord = u[e.type](i, a.baseDataDim, a.valueDataDim, l, c), e.value = e.coord[c]
					} else e.coord = [null != e.xAxis ? e.xAxis : e.radiusAxis, null != e.yAxis ? e.yAxis : e.angleAxis]
				}
				return e
			},
			h = function(t, e, i, n) {
				var r = {};
				return null != t.valueIndex || null != t.valueDim ? (r.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim, r.valueAxis = i[a](n.dataDimToCoordDim(r.valueDataDim)), r.baseAxis = i.getOtherAxis(r.valueAxis), r.baseDataDim = n.coordDimToDataDim(r.baseAxis.dim)[0]) : (r.baseAxis = n.getBaseAxis(), r.valueAxis = i.getOtherAxis(r.baseAxis), r.baseDataDim = n.coordDimToDataDim(r.baseAxis.dim)[0], r.valueDataDim = n.coordDimToDataDim(r.valueAxis.dim)[0]), r
			},
			d = function(t, e) {
				return t && t.containData && e.coord && (null == e.x || null == e.y) ? t.containData(e.coord) : !0
			},
			f = function(t, e, i, n) {
				return 2 > n ? t.coord && t.coord[n] : t.value
			},
			p = function(t, e, i) {
				return "average" === i ? t.getSum(e, !0) / t.count() : t.getDataExtent(e, !0)["max" === i ? 1 : 0]
			};
		return {
			dataTransform: c,
			dataFilter: d,
			dimValueGetter: f,
			getAxisInfo: h,
			numCalculate: p
		}
	}), e("echarts/util/throttle", [], function() {
		var t = {},
			e = "\x00__throttleOriginMethod",
			i = "\x00__throttleRate";
		return t.throttle = function(t, e, i, n) {
			function r(r) {
				function f() {
					c = (new Date).getTime(), h = null, (d ? t : t[r]).apply(o, s || [])
				}
				var p = function() {
					l = (new Date).getTime(), o = this, s = arguments, a = l - (n ? u : c) - e, clearTimeout(h), n ? i ? h = setTimeout(f, e) : a >= 0 && f() : a >= 0 ? f() : i && (h = setTimeout(f, -a)), u = l
				};
				return p.clear = function() {
					h && (clearTimeout(h), h = null)
				}, p
			}
			var a, o, s, l = (new Date).getTime(),
				u = 0,
				c = 0,
				h = null,
				d = typeof t === Z;
			if (e = e || 0, d) return r();
			for (var f = [], p = 0; p < t[$]; p++) f[p] = r(p);
			return f
		}, t.fixRate = function(e, i) {
			return null != i ? t.throttle(e, i, !0, !1) : e
		}, t.debounce = function(e, i) {
			return null != i ? t.throttle(e, i, !0, !0) : e
		}, t.createOrUpdate = function(n, r, a, o) {
			var s = n[r];
			if (s && null != a && o) {
				var l = s[e] || s,
					u = s[i];
				u !== a && (s = n[r] = t[o](l, a), s[e] = l, s[i] = a)
			}
		}, t.clear = function(t, i) {
			var n = t[i];
			n && n[e] && (t[i] = n[e])
		}, t
	}), e("echarts/chart/helper/LineDraw", [ve, "../../util/graphic", "./Line"], function(t) {
		function e(t) {
			this._ctor = t || n, this.group = new i.Group
		}
		var i = t("../../util/graphic"),
			n = t("./Line"),
			r = e[de];
		return r.updateData = function(t, e, i) {
			var n = this._lineData,
				r = this.group,
				a = this._ctor;
			t.diff(n).add(function(n) {
				var o = new a(t, e, i, n);
				t.setItemGraphicEl(n, o), r.add(o)
			})[ne](function(a, o) {
				var s = n.getItemGraphicEl(o);
				s.updateData(t, e, i, a), t.setItemGraphicEl(a, s), r.add(s)
			})[ee](function(t) {
				r[ee](n.getItemGraphicEl(t))
			}).execute(), this._lineData = t, this._fromData = e, this._toData = i
		}, r.updateLayout = function() {
			var t = this._lineData;
			t.eachItemGraphicEl(function(e, i) {
				e.updateLayout(t, this._fromData, this._toData, i)
			}, this)
		}, r[ee] = function() {
			this.group[E]()
		}, e
	}), e("echarts/component/helper/sliderMove", [ve], function() {
		return function(t, e, i, n, r) {
			function a(t, e, i) {
				var n = e[$] ? e.slice() : [e, e];
				return e[0] > e[1] && n.reverse(), 0 > t && n[0] + t < i[0] && (t = i[0] - n[0]), t > 0 && n[1] + t > i[1] && (t = i[1] - n[1]), t
			}
			return t ? ("rigid" === n ? (t = a(t, e, i), e[0] += t, e[1] += t) : (t = a(t, e[r], i), e[r] += t, "push" === n && e[0] > e[1] && (e[1 - r] = e[r])), e) : e
		}
	}), e("echarts/coord/axisModelCommonMixin", [ve, me, "./axisHelper"], function(t) {
		function e(t) {
			return a[ie](t) && null != t.value ? t.value : t
		}

		function n() {
			return this.get("type") === i && a.map(this.get("data"), e)
		}

		function r() {
			return o.getFormattedLabels(this.axis, this.get("axisLabel.formatter"))
		}
		var a = t(me),
			o = t("./axisHelper");
		return {
			getFormattedLabels: r,
			getCategories: n
		}
	}), e("echarts/coord/axisModelCreator", [ve, "./axisDefault", me, "../model/Component", "../util/layout"], function(t) {
		var e = t("./axisDefault"),
			n = t(me),
			r = t("../model/Component"),
			a = t("../util/layout"),
			o = ["value", i, "time", "log"];
		return function(t, i, s, l) {
			n.each(o, function(r) {
				i[te]({
					type: t + "Axis." + r,
					mergeDefaultAndTheme: function(e, i) {
						var o = this.layoutMode,
							l = o ? a.getLayoutParams(e) : {},
							u = i.getTheme();
						n.merge(e, u.get(r + "Axis")), n.merge(e, this.getDefaultOption()), e.type = s(t, e), o && a.mergeLayoutParam(e, l, o)
					},
					defaultOption: n.mergeAll([{}, e[r + "Axis"], l], !0)
				})
			}), r.registerSubTypeDefaulter(t + "Axis", n.curry(s, t))
		}
	}), e("echarts/data/DataDiffer", [ve], function() {
		function t(t) {
			return t
		}

		function e(e, i, n, r) {
			this._old = e, this._new = i, this._oldKeyGetter = n || t, this._newKeyGetter = r || t
		}

		function i(t, e, i) {
			for (var n = 0; n < t[$]; n++) {
				var r = i(t[n]),
					a = e[r];
				null == a ? e[r] = n : (a[$] || (e[r] = a = [a]), a.push(n))
			}
		}
		return e[de] = {
			constructor: e,
			add: function(t) {
				return this._add = t, this
			},
			update: function(t) {
				return this._update = t, this
			},
			remove: function(t) {
				return this._remove = t, this
			},
			execute: function() {
				var t, e = this._old,
					n = this._new,
					r = this._oldKeyGetter,
					a = this._newKeyGetter,
					o = {},
					s = {};
				for (i(e, o, r), i(n, s, a), t = 0; t < e[$]; t++) {
					var l = r(e[t]),
						u = s[l];
					if (null != u) {
						var c = u[$];
						c ? (1 === c && (s[l] = null), u = u.unshift()) : s[l] = null, this._update && this._update(u, t)
					} else this._remove && this._remove(t)
				}
				for (var l in s)
					if (s.hasOwnProperty(l)) {
						var u = s[l];
						if (null == u) continue;
						if (u[$])
							for (var t = 0, c = u[$]; c > t; t++) this._add && this._add(u[t]);
						else this._add && this._add(u)
					}
			}
		}, e
	}), e("echarts/chart/helper/Symbol", [ve, me, "../../util/symbol", "../../util/graphic", n], function(t) {
		function e(t) {
			return s[G](t) || (t = [+t, +t]), t
		}

		function i(t, e) {
			u.Group.call(this), this.updateData(t, e)
		}

		function a(t, e) {
			this[c].drift(t, e)
		}
		var s = t(me),
			l = t("../../util/symbol"),
			u = t("../../util/graphic"),
			p = t(n),
			m = i[de];
		m._createSymbol = function(t, i, n) {
			this[E]();
			var r = i.hostModel,
				o = i[v](n, "color"),
				s = l.createSymbol(t, -.5, -.5, 1, 1, o);
			s.attr({
				style: {
					strokeNoScale: !0
				},
				z2: 100,
				culling: !0,
				scale: [0, 0]
			}), s.drift = a;
			var c = e(i[v](n, "symbolSize"));
			u.initProps(s, {
				scale: c
			}, r), this._symbolType = t, this.add(s)
		}, m.stopSymbolAnimation = function(t) {
			this.childAt(0).stopAnimation(t)
		}, m.getScale = function() {
			return this.childAt(0).scale
		}, m.highlight = function() {
			this.childAt(0)[Q](f)
		}, m.downplay = function() {
			this.childAt(0)[Q](d)
		}, m.setZ = function(t, e) {
			var i = this.childAt(0);
			i.zlevel = t, i.z = e
		}, m.setDraggable = function(t) {
			var e = this.childAt(0);
			e.draggable = t, e.cursor = t ? "move" : "pointer"
		}, m.updateData = function(t, i) {
			var n = t[v](i, "symbol") || "circle",
				r = t.hostModel,
				a = e(t[v](i, "symbolSize"));
			if (n !== this._symbolType) this._createSymbol(n, t, i);
			else {
				var o = this.childAt(0);
				u.updateProps(o, {
					scale: a
				}, r)
			}
			this._updateCommon(t, i, a), this._seriesModel = r
		};
		var g = ["itemStyle", d],
			y = ["itemStyle", f],
			x = ["label", d],
			_ = ["label", f];
		return m._updateCommon = function(t, i, n) {
			var a = this.childAt(0),
				l = t.hostModel,
				c = t[b](i),
				m = c[ce](g),
				M = t[v](i, "color"),
				S = c[ce](y).getItemStyle();
			a[o] = c[h]("symbolRotate") * Math.PI / 180 || 0;
			var A = c[h]("symbolOffset");
			if (A) {
				var C = a[L];
				C[0] = p.parsePercent(A[0], n[0]), C[1] = p.parsePercent(A[1], n[1])
			}
			a.setColor(M), s[te](a.style, m.getItemStyle(["color"]));
			for (var k, z = c[ce](x), P = c[ce](_), T = a.style, D = t[w].slice(), I = D.pop();
				(k = t.getDimensionInfo(I).type) === r || "time" === k;) I = D.pop();
			z.get("show") ? (u.setText(T, z, M), T.text = s.retrieve(l.getFormattedLabel(i, d), t.get(I, i))) : T.text = "", P[h]("show") ? (u.setText(S, P, M), S.text = s.retrieve(l.getFormattedLabel(i, f), t.get(I, i))) : S.text = "";
			var O = e(t[v](i, "symbolSize"));
			if (a.off(H).off(W).off(f).off(d), u.setHoverStyle(a, S), c[h]("hoverAnimation")) {
				var R = function() {
						var t = O[1] / O[0];
						this.animateTo({
							scale: [Math.max(1.1 * O[0], O[0] + 3), Math.max(1.1 * O[1], O[1] + 3 * t)]
						}, 400, "elasticOut")
					},
					E = function() {
						this.animateTo({
							scale: O
						}, 400, "elasticOut")
					};
				a.on(H, R).on(W, E).on(f, R).on(d, E)
			}
		}, m.fadeOut = function(t) {
			var e = this.childAt(0);
			e.style.text = "", u.updateProps(e, {
				scale: [0, 0]
			}, this._seriesModel, t)
		}, s[B](i, u.Group), i
	}), e("echarts/component/dataZoom/roams", [ve, me, "../../component/helper/RoamController", "../../util/throttle"], function(t) {
		function e(t) {
			var e = t.getZr();
			return e[d] || (e[d] = {})
		}

		function i(t, e, i) {
			var n = new u(t.getZr());
			return n.enable(), n.on("pan", h(r, i)), n.on("zoom", h(a, i)), n
		}

		function n(t) {
			l.each(t, function(e, i) {
				e.count || (e.controller.off("pan").off("zoom"), delete t[i])
			})
		}

		function r(t, e, i) {
			o(t, function(n) {
				return n.panGetRange(t.controller, e, i)
			})
		}

		function a(t, e, i, n) {
			o(t, function(r) {
				return r.zoomGetRange(t.controller, e, i, n)
			})
		}

		function o(t, e) {
			var i = [];
			l.each(t.dataZoomInfos, function(t) {
				var n = e(t);
				n && i.push({
					dataZoomId: t.dataZoomId,
					start: n[0],
					end: n[1]
				})
			}), t[J](i)
		}

		function s(t, e) {
			t[J]({
				type: "dataZoom",
				batch: e
			})
		}
		var l = t(me),
			u = t("../../component/helper/RoamController"),
			c = t("../../util/throttle"),
			h = l.curry,
			d = "\x00_ec_dataZoom_roams",
			f = {
				register: function(t, r) {
					var a = e(t),
						o = r.dataZoomId,
						u = r.coordId;
					l.each(a, function(t) {
						var e = t.dataZoomInfos;
						e[o] && l[N](r.allCoordIds, u) < 0 && (delete e[o], t.count--)
					}), n(a);
					var h = a[u];
					h || (h = a[u] = {
						coordId: u,
						dataZoomInfos: {},
						count: 0
					}, h.controller = i(t, r, h), h[J] = l.curry(s, t)), h.controller.rect = r[R].getRect().clone(), c.createOrUpdate(h, J, r.throttleRate, "fixRate"), !h.dataZoomInfos[o] && h.count++, h.dataZoomInfos[o] = r
				},
				unregister: function(t, i) {
					var r = e(t);
					l.each(r, function(t) {
						var e = t.dataZoomInfos;
						e[i] && (delete e[i], t.count--)
					}), n(r)
				},
				shouldRecordRange: function(t, e) {
					if (t && "dataZoom" === t.type && t.batch)
						for (var i = 0, n = t.batch[$]; n > i; i++)
							if (t.batch[i].dataZoomId === e) return !1;
					return !0
				},
				generateCoordId: function(t) {
					return t.type + "\x00_" + t.id
				}
			};
		return f
	}), e("echarts/coord/axisDefault", [ve, me], function(t) {
		var e = t(me),
			i = {
				show: !0,
				zlevel: 0,
				z: 0,
				inverse: !1,
				name: "",
				nameLocation: "end",
				nameTextStyle: {},
				nameGap: 15,
				axisLine: {
					show: !0,
					onZero: !0,
					lineStyle: {
						color: "#333",
						width: 1,
						type: "solid"
					}
				},
				axisTick: {
					show: !0,
					inside: !1,
					length: 5,
					lineStyle: {
						color: "#333",
						width: 1
					}
				},
				axisLabel: {
					show: !0,
					inside: !1,
					rotate: 0,
					margin: 8,
					textStyle: {
						color: "#333",
						fontSize: 12
					}
				},
				splitLine: {
					show: !0,
					lineStyle: {
						color: ["#ccc"],
						width: 1,
						type: "solid"
					}
				},
				splitArea: {
					show: !1,
					areaStyle: {
						color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]
					}
				}
			},
			n = e.merge({
				boundaryGap: !0,
				axisTick: {
					interval: "auto"
				},
				axisLabel: {
					interval: "auto"
				}
			}, i),
			r = e[K]({
				boundaryGap: [0, 0],
				splitNumber: 5
			}, i),
			a = e[K]({
				scale: !0,
				min: "dataMin",
				max: "dataMax"
			}, r),
			o = e[K]({}, r);
		return o.scale = !0, {
			categoryAxis: n,
			valueAxis: r,
			timeAxis: a,
			logAxis: o
		}
	}), e("echarts/chart/line/lineAnimationDiff", [ve], function() {
		function t(t) {
			return t >= 0 ? 1 : -1
		}

		function e(e, i, n) {
			for (var r, a = e.getBaseAxis(), o = e.getOtherAxis(a), s = a.onZero ? 0 : o.scale[A]()[0], l = o.dim, u = "x" === l || "radius" === l ? 1 : 0, c = i.stackedOn, h = i.get(l, n); c && t(c.get(l, n)) === t(h);) {
				r = c;
				break
			}
			var d = [];
			return d[u] = i.get(a.dim, n), d[1 - u] = r ? r.get(l, n, !0) : s, e.dataToPoint(d)
		}

		function i(t, e) {
			var i = [];
			return e.diff(t).add(function(t) {
				i.push({
					cmd: "+",
					idx: t
				})
			})[ne](function(t, e) {
				i.push({
					cmd: "=",
					idx: e,
					idx1: t
				})
			})[ee](function(t) {
				i.push({
					cmd: "-",
					idx: t
				})
			}).execute(), i
		}
		return function(t, n, r, a, o, s) {
			for (var l = i(t, n), u = [], c = [], h = [], d = [], f = [], p = [], m = [], v = s[w], g = 0; g < l[$]; g++) {
				var y = l[g],
					x = !0;
				switch (y.cmd) {
					case "=":
						var _ = t.getItemLayout(y.idx),
							b = n.getItemLayout(y.idx1);
						(isNaN(_[0]) || isNaN(_[1])) && (_ = b.slice()), u.push(_), c.push(b), h.push(r[y.idx]), d.push(a[y.idx1]), m.push(n.getRawIndex(y.idx1));
						break;
					case "+":
						var M = y.idx;
						u.push(o.dataToPoint([n.get(v[0], M, !0), n.get(v[1], M, !0)])), c.push(n.getItemLayout(M).slice()), h.push(e(o, n, M)), d.push(a[M]), m.push(n.getRawIndex(M));
						break;
					case "-":
						var M = y.idx,
							S = t.getRawIndex(M);
						S !== M ? (u.push(t.getItemLayout(M)), c.push(s.dataToPoint([t.get(v[0], M, !0), t.get(v[1], M, !0)])), h.push(r[M]), d.push(e(s, t, M)), m.push(S)) : x = !1
				}
				x && (f.push(y), p.push(p[$]))
			}
			p.sort(function(t, e) {
				return m[t] - m[e]
			});
			for (var A = [], C = [], L = [], k = [], z = [], g = 0; g < p[$]; g++) {
				var M = p[g];
				A[g] = u[M], C[g] = c[M], L[g] = h[M], k[g] = d[M], z[g] = f[M]
			}
			return {
				current: A,
				next: C,
				stackedOnCurrent: L,
				stackedOnNext: k,
				status: z
			}
		}
	}), e("echarts/chart/line/poly", [ve, "zrender/graphic/Path", "zrender/core/vector"], function(t) {
		function e(t, e, i, n, d, f, p, m, v, g) {
			for (var y = i, x = 0; d > x; x++) {
				var _ = e[y];
				if (y >= n || 0 > y || isNaN(_[0]) || isNaN(_[1])) break;
				if (y === i) t[f > 0 ? "moveTo" : "lineTo"](_[0], _[1]), l(c, _);
				else if (v > 0) {
					var b = y - f,
						w = y + f,
						M = .5,
						S = e[b],
						A = e[w];
					if (f > 0 && (y === d - 1 || isNaN(A[0]) || isNaN(A[1])) || 0 >= f && (0 === y || isNaN(A[0]) || isNaN(A[1]))) l(h, _);
					else {
						(isNaN(A[0]) || isNaN(A[1])) && (A = _), r.sub(u, A, S);
						var C, L;
						if ("x" === g || "y" === g) {
							var k = "x" === g ? 0 : 1;
							C = Math.abs(_[k] - S[k]), L = Math.abs(_[k] - A[k])
						} else C = r.dist(_, S), L = r.dist(_, A);
						M = L / (L + C), s(h, _, u, -v * (1 - M))
					}
					a(c, c, m), o(c, c, p), a(h, h, m), o(h, h, p), t.bezierCurveTo(c[0], c[1], h[0], h[1], _[0], _[1]), s(c, _, u, v * M)
				} else t.lineTo(_[0], _[1]);
				y += f
			}
			return x
		}

		function i(t, e) {
			var i = [1 / 0, 1 / 0],
				n = [-1 / 0, -1 / 0];
			if (e)
				for (var r = 0; r < t[$]; r++) {
					var a = t[r];
					a[0] < i[0] && (i[0] = a[0]), a[1] < i[1] && (i[1] = a[1]), a[0] > n[0] && (n[0] = a[0]), a[1] > n[1] && (n[1] = a[1])
				}
			return {
				min: e ? i : n,
				max: e ? n : i
			}
		}
		var n = t("zrender/graphic/Path"),
			r = t("zrender/core/vector"),
			a = r.min,
			o = r.max,
			s = r.scaleAndAdd,
			l = r.copy,
			u = [],
			c = [],
			h = [];
		return {
			Polyline: n[te]({
				type: "ec-polyline",
				shape: {
					points: [],
					smooth: 0,
					smoothConstraint: !0,
					smoothMonotone: null
				},
				style: {
					fill: null,
					stroke: "#000"
				},
				buildPath: function(t, n) {
					for (var r = n.points, a = 0, o = r[$], s = i(r, n.smoothConstraint); o > a;) a += e(t, r, a, o, o, 1, s.min, s.max, n.smooth, n.smoothMonotone) + 1
				}
			}),
			Polygon: n[te]({
				type: "ec-polygon",
				shape: {
					points: [],
					stackedOnPoints: [],
					smooth: 0,
					stackedOnSmooth: 0,
					smoothConstraint: !0,
					smoothMonotone: null
				},
				buildPath: function(t, n) {
					for (var r = n.points, a = n.stackedOnPoints, o = 0, s = r[$], l = n.smoothMonotone, u = i(r, n.smoothConstraint), c = i(a, n.smoothConstraint); s > o;) {
						var h = e(t, r, o, s, s, 1, u.min, u.max, n.smooth, l);
						e(t, a, o + h - 1, s, h, -1, c.min, c.max, n.stackedOnSmooth, l), o += h + 1, t.closePath()
					}
				}
			})
		}
	}), e("echarts/chart/pie/labelLayout", [ve, "zrender/contain/text"], function(t) {
		function e(t, e, i, n, r, a, o) {
			function s(e, i, n) {
				for (var r = e; i > r; r++)
					if (t[r].y += n, r > e && i > r + 1 && t[r + 1].y > t[r].y + t[r][ae]) return void l(r, n / 2);
				l(i - 1, n / 2)
			}

			function l(e, i) {
				for (var n = e; n >= 0 && (t[n].y -= i, !(n > 0 && t[n].y > t[n - 1].y + t[n - 1][ae])); n--);
			}

			function u(t, e, i, n, r, a) {
				for (var o = a > 0 ? e ? Number.MAX_VALUE : 0 : e ? Number.MAX_VALUE : 0, s = 0, l = t[$]; l > s; s++)
					if (t[s][L] !== k) {
						var u = Math.abs(t[s].y - n),
							c = t[s].len,
							h = t[s].len2,
							d = r + c > u ? Math.sqrt((r + c + h) * (r + c + h) - u * u) : Math.abs(t[s].x - i);
						e && d >= o && (d = o - 10), !e && o >= d && (d = o + 10), t[s].x = i + d * a, o = d
					}
			}
			t.sort(function(t, e) {
				return t.y - e.y
			});
			for (var c, h = 0, d = t[$], f = [], p = [], m = 0; d > m; m++) c = t[m].y - h, 0 > c && s(m, d, -c, r), h = t[m].y + t[m][ae];
			0 > o - h && l(d - 1, h - o);
			for (var m = 0; d > m; m++) t[m].y >= i ? p.push(t[m]) : f.push(t[m]);
			u(f, !1, e, i, n, r), u(p, !0, e, i, n, r)
		}

		function i(t, i, n, r, a, o) {
			for (var s = [], l = [], u = 0; u < t[$]; u++) t[u].x < i ? s.push(t[u]) : l.push(t[u]);
			e(l, i, n, r, 1, a, o), e(s, i, n, r, -1, a, o);
			for (var u = 0; u < t[$]; u++) {
				var c = t[u].linePoints;
				if (c) {
					var h = c[1][0] - c[2][0];
					c[2][0] = t[u].x < i ? t[u].x + 3 : t[u].x - 3, c[1][1] = c[2][1] = t[u].y, c[1][0] = c[2][0] + h
				}
			}
		}
		var n = t("zrender/contain/text");
		return function(t, e, r, a) {
			var o, s, l = t[U](),
				u = [],
				c = !1;
			l.each(function(i) {
				var r, a, h, f, p = l.getItemLayout(i),
					m = l[b](i),
					v = m[ce]("label.normal"),
					y = v.get(L) || m.get("label.emphasis.position"),
					x = m[ce]("labelLine.normal"),
					_ = x.get($),
					w = x.get("length2"),
					M = (p.startAngle + p.endAngle) / 2,
					S = Math.cos(M),
					A = Math.sin(M);
				o = p.cx, s = p.cy;
				var C = "inside" === y || "inner" === y;
				if (y === k) r = p.cx, a = p.cy, f = k;
				else {
					var z = (C ? (p.r + p.r0) / 2 * S : p.r * S) + o,
						T = (C ? (p.r + p.r0) / 2 * A : p.r * A) + s;
					if (r = z + 3 * S, a = T + 3 * A, !C) {
						var I = z + S * (_ + e - p.r),
							R = T + A * (_ + e - p.r),
							E = I + (0 > S ? -1 : 1) * w,
							B = R;
						r = E + (0 > S ? -5 : 5), a = B, h = [
							[z, T],
							[I, R],
							[E, B]
						]
					}
					f = C ? k : S > 0 ? "left" : "right"
				}
				var V = v[ce](O)[D](),
					Z = v.get("rotate") ? 0 > S ? -M + Math.PI : -M : 0,
					N = t.getFormattedLabel(i, d) || l[g](i),
					G = n[P](N, V, f, "top");
				c = !!Z, p.label = {
					x: r,
					y: a,
					position: y,
					height: G[ae],
					len: _,
					len2: w,
					linePoints: h,
					textAlign: f,
					verticalAlign: "middle",
					font: V,
					rotation: Z
				}, C || u.push(p.label)
			}), !c && t.get("avoidLabelOverlap") && i(u, o, s, e, r, a)
		}
	}), e("echarts/chart/helper/Line", [ve, "../../util/symbol", "zrender/core/vector", "./LinePath", "../../util/graphic", me, n], function(t) {
		function e(t, e, i) {
			var n = e[v](i, "color"),
				r = e[v](i, "symbol"),
				a = e[v](i, "symbolSize");
			if ("none" !== r) {
				y[G](a) || (a = [a, a]);
				var o = c.createSymbol(r, -a[0] / 2, -a[1] / 2, a[0], a[1], n);
				return o.name = t, o
			}
		}

		function i(t) {
			var e = new p({
				name: "line",
				style: {
					strokeNoScale: !0
				}
			});
			return r(e.shape, t), e
		}

		function r(t, e) {
			var i = e[0],
				n = e[1],
				r = e[2];
			t.x1 = i[0], t.y1 = i[1], t.x2 = n[0], t.y2 = n[1], t.percent = 1, r && (t.cpx1 = r[0], t.cpy1 = r[1])
		}

		function a(t) {
			return "symbol" === t.type && "arrow" === t.shape.symbolType
		}

		function s() {
			var t = this,
				e = t.childOfName("line");
			if (this.__dirty || e.__dirty) {
				var i = t.childOfName("fromSymbol"),
					n = t.childOfName("toSymbol"),
					r = t.childOfName("label"),
					s = e.pointAt(0),
					u = e.pointAt(e.shape.percent),
					c = h.sub([], u, s);
				h.normalize(c, c), i && (i.attr(L, s), a(i) && i.attr(o, l(u, s))), n && (n.attr(L, u), a(n) && n.attr(o, l(s, u))), r.attr(L, u);
				var d, f, p;
				"end" === r.__position ? (d = [5 * c[0] + u[0], 5 * c[1] + u[1]], f = c[0] > .8 ? "left" : c[0] < -.8 ? "right" : k, p = c[1] > .8 ? "top" : c[1] < -.8 ? oe : z) : (d = [5 * -c[0] + s[0], 5 * -c[1] + s[1]], f = c[0] > .8 ? "right" : c[0] < -.8 ? "left" : k, p = c[1] > .8 ? oe : c[1] < -.8 ? "top" : z), r.attr({
					style: {
						textVerticalAlign: r.__verticalAlign || p,
						textAlign: r.__textAlign || f
					},
					position: d
				})
			}
		}

		function l(t, e) {
			return -Math.PI / 2 - Math.atan2(e[1] - t[1], e[0] - t[0])
		}

		function u(t, e, i, n) {
			m.Group.call(this), this._createLine(t, e, i, n)
		}
		var c = t("../../util/symbol"),
			h = t("zrender/core/vector"),
			p = t("./LinePath"),
			m = t("../../util/graphic"),
			y = t(me),
			x = t(n),
			_ = u[de];
		return _.beforeUpdate = s, _._createLine = function(t, n, r, a) {
			var o = t.hostModel,
				s = t.getItemLayout(a),
				l = i(s);
			l.shape.percent = 0, m.initProps(l, {
				shape: {
					percent: 1
				}
			}, o), this.add(l);
			var u = new m.Text({
				name: "label"
			});
			if (this.add(u), n) {
				var c = e("fromSymbol", n, a);
				this.add(c), this._fromSymbolType = n[v](a, "symbol")
			}
			if (r) {
				var h = e("toSymbol", r, a);
				this.add(h), this._toSymbolType = r[v](a, "symbol")
			}
			this._updateCommonStl(t, n, r, a)
		}, _.updateData = function(t, i, n, a) {
			var o = t.hostModel,
				s = this.childOfName("line"),
				l = t.getItemLayout(a),
				u = {
					shape: {}
				};
			if (r(u.shape, l), m.updateProps(s, u, o), i) {
				var c = i[v](a, "symbol");
				if (this._fromSymbolType !== c) {
					var h = e("fromSymbol", i, a);
					this[ee](this.childOfName("fromSymbol")), this.add(h)
				}
				this._fromSymbolType = c
			}
			if (n) {
				var d = n[v](a, "symbol");
				if (d !== this._toSymbolType) {
					var f = e("toSymbol", n, a);
					this[ee](this.childOfName("toSymbol")), this.add(f)
				}
				this._toSymbolType = d
			}
			this._updateCommonStl(t, i, n, a)
		}, _._updateCommonStl = function(t, e, i, n) {
			var r = t.hostModel,
				a = this.childOfName("line"),
				o = t[b](n),
				s = o[ce]("label.normal"),
				l = s[ce](O),
				u = o[ce]("label.emphasis"),
				c = u[ce](O),
				h = x.round(r.getRawValue(n));
			isNaN(h) && (h = t[g](n)), a.setStyle(y[te]({
				stroke: t[v](n, "color")
			}, o[ce]("lineStyle.normal").getLineStyle()));
			var p = this.childOfName("label");
			p.setStyle({
				text: s.get("show") ? y.retrieve(r.getFormattedLabel(n, d), h) : "",
				textFont: l[D](),
				fill: l[T]() || t[v](n, "color")
			}), p.hoverStyle = {
				text: u.get("show") ? y.retrieve(r.getFormattedLabel(n, f), h) : "",
				textFont: c[D](),
				fill: c[T]()
			}, p.__textAlign = l.get("align"), p.__verticalAlign = l.get("baseline"), p.__position = s.get(L), m.setHoverStyle(this, o[ce]("lineStyle.emphasis").getLineStyle())
		}, _.updateLayout = function(t, e, i, n) {
			var a = t.getItemLayout(n),
				o = this.childOfName("line");
			r(o.shape, a), o.dirty(!0)
		}, y[B](u, m.Group), u
	}), e("echarts/component/helper/RoamController", [ve, "zrender/mixin/Eventful", me, "zrender/core/event", "./interactionMutex"], function(t) {
		function e(t) {
			if (!t.target || !t.target.draggable) {
				var e = t.offsetX,
					i = t.offsetY,
					n = this.rect;
				n && n[S](e, i) && (this._x = e, this._y = i, this._dragging = !0)
			}
		}

		function i(t) {
			if (this._dragging && (c.stop(t.event), "pinch" !== t.gestureEvent)) {
				if (h.isTaken("globalPan", this._zr)) return;
				var e = t.offsetX,
					i = t.offsetY,
					n = e - this._x,
					r = i - this._y;
				this._x = e, this._y = i;
				var a = this.target;
				if (a) {
					var o = a[L];
					o[0] += n, o[1] += r, a.dirty()
				}
				c.stop(t.event), this[Q]("pan", n, r)
			}
		}

		function n() {
			this._dragging = !1
		}

		function r(t) {
			c.stop(t.event);
			var e = t.wheelDelta > 0 ? 1.1 : 1 / 1.1;
			o.call(this, t, e, t.offsetX, t.offsetY)
		}

		function a(t) {
			if (!h.isTaken("globalPan", this._zr)) {
				c.stop(t.event);
				var e = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
				o.call(this, t, e, t.pinchX, t.pinchY)
			}
		}

		function o(t, e, i, n) {
			var r = this.rect;
			if (r && r[S](i, n)) {
				var a = this.target,
					o = this.zoomLimit;
				if (a) {
					var s = a[L],
						l = a.scale,
						u = this.zoom = this.zoom || 1;
					u *= e, o && (u = Math.max(Math.min(o.max, u), o.min));
					var c = u / this.zoom;
					this.zoom = u, s[0] -= (i - s[0]) * (c - 1), s[1] -= (n - s[1]) * (c - 1), l[0] *= c, l[1] *= c, a.dirty()
				}
				this[Q]("zoom", e, i, n)
			}
		}

		function s(t, o, s) {
			this.target = o, this.rect = s, this.zoomLimit, this.zoom, this._zr = t;
			var c = u.bind,
				h = c(e, this),
				d = c(i, this),
				f = c(n, this),
				p = c(r, this),
				m = c(a, this);
			l.call(this), this.enable = function(e) {
				this.disable(), null == e && (e = !0), (e === !0 || "move" === e || "pan" === e) && (t.on("mousedown", h), t.on("mousemove", d), t.on("mouseup", f)), (e === !0 || "scale" === e || "zoom" === e) && (t.on("mousewheel", p), t.on("pinch", m))
			}, this.disable = function() {
				t.off("mousedown", h), t.off("mousemove", d), t.off("mouseup", f), t.off("mousewheel", p), t.off("pinch", m)
			}, this.dispose = this.disable, this.isDragging = function() {
				return this._dragging
			}, this.isPinching = function() {
				return this._pinching
			}
		}
		var l = t("zrender/mixin/Eventful"),
			u = t(me),
			c = t("zrender/core/event"),
			h = t("./interactionMutex");
		return u.mixin(s, l), s
	}), e("echarts/component/axis/AxisView", [ve, me, "../../util/graphic", "./AxisBuilder", s], function(t) {
		function e(t, e) {
			function i(t) {
				var e = n[a](t);
				return e.toGlobalCoord(e.dataToCoord(0))
			}
			var n = t[R],
				r = e.axis,
				s = {},
				l = r[L],
				u = r.onZero ? "onZero" : l,
				c = r.dim,
				h = n.getRect(),
				d = [h.x, h.x + h.width, h.y, h.y + h[ae]],
				f = {
					x: {
						top: d[2],
						bottom: d[3]
					},
					y: {
						left: d[0],
						right: d[1]
					}
				};
			f.x.onZero = Math.max(Math.min(i("y"), f.x[oe]), f.x.top), f.y.onZero = Math.max(Math.min(i("x"), f.y.right), f.y.left), s[L] = ["y" === c ? f.y[u] : d[0], "x" === c ? f.x[u] : d[3]];
			var p = {
				x: 0,
				y: 1
			};
			s[o] = Math.PI / 2 * p[c];
			var m = {
				top: -1,
				bottom: 1,
				left: -1,
				right: 1
			};
			s.labelDirection = s.tickDirection = s.nameDirection = m[l], r.onZero && (s.labelOffset = f[c][l] - f[c].onZero), e[ce]("axisTick").get("inside") && (s.tickDirection = -s.tickDirection), e[ce]("axisLabel").get("inside") && (s.labelDirection = -s.labelDirection);
			var v = e[ce]("axisLabel").get("rotate");
			return s.labelRotation = "top" === u ? -v : v, s.labelInterval = r.getLabelInterval(), s.z2 = 1, s
		}
		var i = t(me),
			n = t("../../util/graphic"),
			r = t("./AxisBuilder"),
			l = r.ifIgnoreOnTick,
			u = r.getInterval,
			c = ["axisLine", "axisLabel", "axisTick", "axisName"],
			h = ["splitLine", "splitArea"],
			d = t(s).extendComponentView({
				type: "axis",
				render: function(t, n) {
					if (this.group[E](), t.get("show")) {
						var a = n[y]("grid", t.get("gridIndex")),
							o = e(a, t),
							s = new r(t, o);
						i.each(c, s.add, s), this.group.add(s.getGroup()), i.each(h, function(e) {
							t.get(e + ".show") && this["_" + e](t, a, o.labelInterval)
						}, this)
					}
				},
				_splitLine: function(t, e, r) {
					var a = t.axis,
						o = t[ce]("splitLine"),
						s = o[ce]("lineStyle"),
						c = s.get("width"),
						h = s.get("color"),
						d = u(o, r);
					h = i[G](h) ? h : [h];
					for (var f = e[R].getRect(), p = a.isHorizontal(), m = [], v = 0, g = a.getTicksCoords(), y = [], x = [], _ = 0; _ < g[$]; _++)
						if (!l(a, _, d)) {
							var b = a.toGlobalCoord(g[_]);
							p ? (y[0] = b, y[1] = f.y, x[0] = b, x[1] = f.y + f[ae]) : (y[0] = f.x, y[1] = b, x[0] = f.x + f.width, x[1] = b);
							var w = v++ % h[$];
							m[w] = m[w] || [], m[w].push(new n.Line(n.subPixelOptimizeLine({
								shape: {
									x1: y[0],
									y1: y[1],
									x2: x[0],
									y2: x[1]
								},
								style: {
									lineWidth: c
								},
								silent: !0
							})))
						}
					for (var M = s.getLineStyle(), _ = 0; _ < m[$]; _++) this.group.add(n.mergePath(m[_], {
						style: i[K]({
							stroke: h[_ % h[$]]
						}, M),
						silent: !0
					}))
				},
				_splitArea: function(t, e, r) {
					var a = t.axis,
						o = t[ce]("splitArea"),
						s = o[ce]("areaStyle"),
						c = s.get("color"),
						h = e[R].getRect(),
						d = a.getTicksCoords(),
						f = a.toGlobalCoord(d[0]),
						p = a.toGlobalCoord(d[0]),
						m = [],
						v = 0,
						g = u(o, r);
					c = i[G](c) ? c : [c];
					for (var y = 1; y < d[$]; y++)
						if (!l(a, y, g)) {
							var x, _, b, w, M = a.toGlobalCoord(d[y]);
							a.isHorizontal() ? (x = f, _ = h.y, b = M - x, w = h[ae]) : (x = h.x, _ = p, b = h.width, w = M - _);
							var S = v++ % c[$];
							m[S] = m[S] || [], m[S].push(new n.Rect({
								shape: {
									x: x,
									y: _,
									width: b,
									height: w
								},
								silent: !0
							})), f = x + b, p = _ + w
						}
					for (var A = s.getAreaStyle(), y = 0; y < m[$]; y++) this.group.add(n.mergePath(m[y], {
						style: i[K]({
							fill: c[y % c[$]]
						}, A),
						silent: !0
					}))
				}
			});
		d[te]({
			type: "xAxis"
		}), d[te]({
			type: "yAxis"
		})
	}), e("echarts/chart/helper/LinePath", [ve, "../../util/graphic"], function(t) {
		var e = t("../../util/graphic"),
			i = e.Line[de],
			n = e.BezierCurve[de];
		return e.extendShape({
			type: "ec-line",
			style: {
				stroke: "#000",
				fill: null
			},
			shape: {
				x1: 0,
				y1: 0,
				x2: 0,
				y2: 0,
				percent: 1,
				cpx1: null,
				cpy1: null
			},
			buildPath: function(t, e) {
				(null == e.cpx1 || null == e.cpy1 ? i : n).buildPath(t, e)
			},
			pointAt: function(t) {
				var e = this.shape;
				return null == e.cpx1 || null == e.cpy1 ? i.pointAt.call(this, t) : n.pointAt.call(this, t)
			}
		})
	}), e("echarts/component/helper/interactionMutex", [ve], function() {
		function t(t) {
			return t[e] || (t[e] = {})
		}
		var e = "\x00_ec_interaction_mutex",
			i = {
				take: function(e, i) {
					t(i)[e] = !0
				},
				release: function(e, i) {
					t(i)[e] = !1
				},
				isTaken: function(e, i) {
					return !!t(i)[e]
				}
			};
		return i
	}), e("echarts/component/axis/AxisBuilder", [ve, me, "../../util/graphic", "../../model/Model", n], function(t) {
		function e(t, e, i) {
			var n, r, a = h(e - t[o]);
			return d(a) ? (r = i > 0 ? "top" : oe, n = k) : d(a - f) ? (r = i > 0 ? oe : "top", n = k) : (r = z, n = a > 0 && f > a ? i > 0 ? "right" : "left" : i > 0 ? "left" : "right"), {
				rotation: a,
				textAlign: n,
				verticalAlign: r
			}
		}

		function a(t, e, i) {
			var n, r, a = h(-t[o]),
				s = i[0] > i[1],
				l = "start" === e && !s || "start" !== e && s;
			return d(a - f / 2) ? (r = l ? oe : "top", n = k) : d(a - 1.5 * f) ? (r = l ? "top" : oe, n = k) : (r = z, n = 1.5 * f > a && a > f / 2 ? l ? "left" : "right" : l ? "right" : "left"), {
				rotation: a,
				textAlign: n,
				verticalAlign: r
			}
		}
		var s = t(me),
			l = t("../../util/graphic"),
			u = t("../../model/Model"),
			c = t(n),
			h = c.remRadian,
			d = c.isRadianAroundZero,
			f = Math.PI,
			v = function(t, e) {
				this.opt = e, this.axisModel = t, s[K](e, {
					labelOffset: 0,
					nameDirection: 1,
					tickDirection: 1,
					labelDirection: 1,
					silent: !0
				}), this.group = new l.Group({
					position: e[L].slice(),
					rotation: e[o]
				})
			};
		v[de] = {
			constructor: v,
			hasBuilder: function(t) {
				return !!g[t]
			},
			add: function(t) {
				g[t].call(this)
			},
			getGroup: function() {
				return this.group
			}
		};
		var g = {
				axisLine: function() {
					var t = this.opt,
						e = this.axisModel;
					if (e.get("axisLine.show")) {
						var i = this.axisModel.axis[A]();
						this.group.add(new l.Line({
							shape: {
								x1: i[0],
								y1: 0,
								x2: i[1],
								y2: 0
							},
							style: s[te]({
								lineCap: "round"
							}, e[ce]("axisLine.lineStyle").getLineStyle()),
							strokeContainThreshold: t.strokeContainThreshold,
							silent: !!t.silent,
							z2: 1
						}))
					}
				},
				axisTick: function() {
					var t = this.axisModel;
					if (t.get("axisTick.show")) {
						for (var e = t.axis, i = t[ce]("axisTick"), n = this.opt, r = i[ce]("lineStyle"), a = i.get($), o = x(i, n.labelInterval), s = e.getTicksCoords(), u = [], c = 0; c < s[$]; c++)
							if (!y(e, c, o)) {
								var h = s[c];
								u.push(new l.Line(l.subPixelOptimizeLine({
									shape: {
										x1: h,
										y1: 0,
										x2: h,
										y2: n.tickDirection * a
									},
									style: {
										lineWidth: r.get("width")
									},
									silent: !0
								})))
							}
						this.group.add(l.mergePath(u, {
							style: r.getLineStyle(),
							z2: 2,
							silent: !0
						}))
					}
				},
				axisLabel: function() {
					function t(t, e) {
						var i = t && t[P]().clone(),
							n = e && e[P]().clone();
						return i && n ? (i[p](t.getLocalTransform()), n[p](e.getLocalTransform()), i.intersect(n)) : void 0
					}
					var n = this.axisModel;
					if (n.get("axisLabel.show")) {
						var r = this.opt,
							a = n.axis,
							s = n[ce]("axisLabel"),
							c = s[ce](O),
							h = s.get("margin"),
							d = a.scale.getTicks(),
							v = n.getFormattedLabels(),
							g = r.labelRotation;
						null == g && (g = s.get("rotate") || 0), g = g * f / 180;
						for (var x = e(r, g, r.labelDirection), _ = n.get("data"), b = [], w = 0; w < d[$]; w++)
							if (!y(a, w, r.labelInterval)) {
								var M = c;
								_ && _[w] && _[w][O] && (M = new u(_[w][O], c, n[m]));
								var S = a.dataToCoord(d[w]),
									A = [S, r.labelOffset + r.labelDirection * h],
									C = new l.Text({
										style: {
											text: v[w],
											textAlign: M.get("align", !0) || x[I],
											textVerticalAlign: M.get("baseline", !0) || x.verticalAlign,
											textFont: M[D](),
											fill: M[T]()
										},
										position: A,
										rotation: x[o],
										silent: !0,
										z2: 10
									});
								b.push(C), this.group.add(C)
							}
						if (a.type !== i) {
							if (n.getMin ? n.getMin() : n.get("min")) {
								var L = b[0],
									k = b[1];
								t(L, k) && (L[se] = !0)
							}
							if (n.getMax ? n.getMax() : n.get("max")) {
								var z = b[b[$] - 1],
									R = b[b[$] - 2];
								t(R, z) && (z[se] = !0)
							}
						}
					}
				},
				axisName: function() {
					var t = this.opt,
						i = this.axisModel,
						n = this.opt.axisName;
					if (null == n && (n = i.get("name")), n) {
						var r, s = i.get("nameLocation"),
							u = t.nameDirection,
							c = i[ce]("nameTextStyle"),
							h = i.get("nameGap") || 0,
							d = this.axisModel.axis[A](),
							f = d[0] > d[1] ? -1 : 1,
							p = ["start" === s ? d[0] - f * h : "end" === s ? d[1] + f * h : (d[0] + d[1]) / 2, s === z ? t.labelOffset + u * h : 0];
						r = s === z ? e(t, t[o], u) : a(t, s, d), this.group.add(new l.Text({
							style: {
								text: n,
								textFont: c[D](),
								fill: c[T]() || i.get("axisLine.lineStyle.color"),
								textAlign: r[I],
								textVerticalAlign: r.verticalAlign
							},
							position: p,
							rotation: r[o],
							silent: !0,
							z2: 1
						}))
					}
				}
			},
			y = v.ifIgnoreOnTick = function(t, e, i) {
				var n, a = t.scale;
				return a.type === r && (typeof i === Z ? (n = a.getTicks()[e], !i(n, a.getLabel(n))) : e % (i + 1))
			},
			x = v.getInterval = function(t, e) {
				var i = t.get("interval");
				return (null == i || "auto" == i) && (i = e), i
			};
		return v
	}), e("zrender", ["zrender/zrender"], function(t) {
		return t
	}), e("echarts", ["echarts/echarts"], function(t) {
		return t
	});
	var ge = t("echarts");
	return ge.graphic = t("echarts/util/graphic"), ge.number = t("echarts/util/number"), ge.format = t("echarts/util/format"), t("echarts/chart/line"), t("echarts/chart/pie"), t("echarts/component/grid"), t("echarts/component/title"), t("echarts/component/legend"), t("echarts/component/markPoint"), t("echarts/component/markLine"), t("echarts/component/dataZoom"), ge
});